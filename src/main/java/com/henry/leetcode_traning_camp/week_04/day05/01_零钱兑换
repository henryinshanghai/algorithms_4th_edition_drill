# 322 使用给定面额的钞票来凑够指定大小的钱；
//给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回
// -1。

// 你可以认为每种硬币的数量是无限的。

// 示例 1：
//
//
//输入：coins = [1, 2, 5], amount = 11
//输出：3
//解释：11 = 5 + 5 + 1
//

// 提示：
//
//
// 1 <= coins.length <= 12
// 1 <= coins[i] <= 231 - 1
// 0 <= amount <= 104

题设与要求：

难点分析 & 解决方案：

思路总结：

代码：
1 自顶向下的DP；
SOP：
    /* 〇 鲁棒性代码：如果total为0，就不需要做任何的事情 返回0即可 */
    /* Ⅰ 在对total进行计算之前，查看下之前有没有计算过它 */
    /* Ⅱ 遍历所有面额的硬币，并默认剩下的钱已经被凑好了（递归调用时，传入更新后的参数）*/
    /* Ⅲ 返回计算出的“凑出total所需要的最少硬币个数min” */

2 自底向上的DP：
    /* 〇 准备两个数组   用于不断更新，以获取到凑出total金额所需要的硬币个数 */
    /* Ⅰ 为T[]、R[]数组中的每一个元素(除了i为0的位置 这是一个无效位置)绑定初始值 */
    /* Ⅱ 逐一遍历每一种面额的硬币   在循环体中，使用当前面额的硬币来更新T[] 与 R[] */
    /* Ⅲ（Optional）打印 为了凑出金额i使用了哪些个硬币 */
    /* Ⅳ 返回T[]数组的最后一个元素 */
















