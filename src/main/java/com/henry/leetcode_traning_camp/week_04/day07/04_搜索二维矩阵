# 74 搜索二维矩阵

//编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
//
//
// 每行中的整数从左到右按升序排列。
// 每行的第一个整数大于前一行的最后一个整数。

// 示例 1：
//
//
//输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 3
//输出：true

======
题设与要求
题设：
    1 给定一个m×n的二维矩阵；
    2 矩阵中的每一行的整数都从左往右升序排列；
    3 矩阵中的每一行的第一个整数都大于前一行的最后一个整数；
要求：
    1 判断该二维数组中是否存在一个target；
    2 要求线性的时间复杂度；

分析难点 & 提出解决方案
难点1：如何能够在一个二维数组中判断是否存在target？
手段1：暴力列举比对；时间复杂度 O(m*n);
手段2：既然每一个子数组都是有序的，就干脆在每一个子数组中进行二分查找； 时间复杂度O(m*log(n))
can we do better? yes
手段3：手段2只使用了有序的特性，但是没有使用特性3
结合特性3，可以把二维数组视为成为一个一维数组来处理————这意味着不改变二维数组在内存中的状态；

思路：
    1 把二维数组中的每个元素列从左到右、行从上往下串联起来，视为一个一维数组；
    2 通过/与%运算来找到一维数组中的元素在二维数组中的位置；
    3 在一维数组中使用二分查找，并计算出查找到的元素在二维数组中的坐标；

代码参考：https://www.youtube.com/watch?v=eT0UqrYuqbg

SOP：
    // 〇 corner case
    // Ⅰ 获取二维数组的行列情况
    /* Ⅱ 准备进行二分查找 */
        // 1 计算左、右边界
        // 2 准备while循环，直到：1 left与right边界相遇； OR 2 找到了target元素
            // 2-1 计算数组的中间位置        技术处理：避免Integer Overflow
            // 2-2 计算中间位置在二维数组中的坐标，并从坐标索引到二维数组中的元素
            // 2-3 判断当前的中间位置上的元素是不是等于target 如果是，返回true 如果不是，调整区间边界
    // Ⅲ 准备没有查找到时的返回值😳

