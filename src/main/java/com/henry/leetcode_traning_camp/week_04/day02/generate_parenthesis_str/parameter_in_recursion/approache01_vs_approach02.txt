approach01: 在递归方法调用时 以path+"(" 作为参数 [不可变参数];
approach02: 在递归方法调用时 以SB对象作为参数 先添加(,再传入参数,最后回溯( [可变参数];

== approach01 ==
对于approach01（也就是代码实现），我们不需要在代码中做显式地回溯操作；
原因：递归调用栈 自动维护了 状态隔离 与 状态回退。
具体说明：
    #1 由于Java中字符串是不可变对象，因此 在调用 dfs(path+"(")时，会创建一个新的字符串对象。
    而原始的path保持不变
    #2 递归栈的状态隔离：
        每次递归调用 都在独立的栈帧中进行；
        每个栈帧 都有自己的参数副本（path字符串状态）；
        父调用不会被 子调用修改状态；
    #3 自动状态回退：
        当递归调用返回时，当前栈帧自动销毁，父栈帧的变量自动恢复。
结论：对字符串的修改产生了新的对象，而这个新对象只存在于子调用中。父调用始终持有 最开始传入时的字符串状态。

== approach02 ==
SB path = path.append("(");
dfs(path...);
path.deleteCharAt(path.length() - 1); // 显示回溯

原因：
#1 SB是可变对象；
#2 所有层级的递归 都共享同一个SB对象；
#3 子调用的修改会影响到父调用，因此为了得到原始值，必须要手动撤销。

=== 对比 ===
approach01
劣势：
    空间效率：每个栈帧存储独立的字符串，最差空间复杂度为O(n^2);
    时间效率：创建新的字符串 也会有开销
优势：
    代码简洁；
    各个层级调用之间没有共享状态，不会相互影响；
    代码结构接近于自然的DFS。

结论：
#1 通过 ① 把状态(path)作为不可变值在参数中传递 +
② 在递归返回时，会自动回退到该参数初始值 这两个特性，可以实现 隐式回溯；

#2 可变数据结构需要显示回溯的原因是：状态共享；

