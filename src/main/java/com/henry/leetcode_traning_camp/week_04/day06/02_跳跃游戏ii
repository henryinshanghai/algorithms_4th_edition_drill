# 45 跳跃游戏ii

//给定一个非负整数数组，你最初位于数组的第一个位置。
//
// 数组中的每个元素代表你在该位置可以跳跃的最大长度。
//
// 你的目标是使用最少的跳跃次数到达数组的最后一个位置。


// 示例:
//
// 输入: [2,3,1,1,4]
//输出: 2
//解释: 跳到最后一个位置的最小跳跃数是 2。
//     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。


// 假设你总是可以到达数组的最后一个位置。

======
题设与条件：

题设：
    1 数组中的元素都是非负整数；
    2 初始位置在数组的第一个位置；
    3 数组元素的值表示在当前位置上所能跳跃的最远距离；
    4 给定的数组arr保证“总是能够跳到终点位置”
要求：
    求出跳跃到终点位置所需要的最少步数；

分析难点 & 提出解决方案：
难点1：如何才能保证跳跃的步数最少？
    如果只是在当前位置尽可能远地往后跳，可能跳到的位置上能够跳跃的最远距离很小————这会导致跳到终点位置需要的步数变多
解决方案：
    在当前位置跳跃最远距离，然后：
        尝试当前位置 与 最远距离中的每一个数组元素，计算每一个位置所能跳跃到的最远距离
    Never Mind,这种方式不是太容易理解 直接上代码看看吧

思路1：
    // 〇 对总的台阶数进行判空
    // Ⅰ 准备两个变量
        // 记录当前所使用的梯子   当前位置 + 扩展位置
        // 记录当前梯子中的台阶数量 扩展得到的台阶数量
    // Ⅱ 准备一个变量
        // 用于记录进行跳跃的数量 初始值为1（因为从初始位置不管怎么跳都要跳一步）
    // Ⅲ 准备一个level指针来遍历所有的台阶
        // 1 判断当前台阶是不是已经到了楼顶
        // 2 在移动指针的过程中，时时地更新/存储当前台阶能够连接到最远位置的梯子
        // 3 每次向前移动指针，当前梯子中剩余的台阶就会减1
        // 4 如果当前梯子的台阶已经用完了，则：
            // 1 跳到下一个梯子
            // 2 更新当前梯子所能前进的台阶数量
    // Ⅳ 返回跳跃的总次数
