# 45 跳跃游戏ii

给定一个 非负整数数组，你最初位于 数组的第一个位置。
数组中的每个元素 代表你 在该位置 可以跳跃的最大长度。
你的目标是 使用最少的跳跃次数 到达 数组的最后一个位置。

示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
    #1 跳1步，从下标为0 跳到 下标为1的位置；
    #2 然后跳3步 到达 数组的最后一个位置。

假设你总是可以到达 数组的最后一个位置。

===
题设与条件：

题设：
    #1 数组中的元素都是 非负整数；
    #2 初始位置 在数组的第一个位置；
    #3 数组元素的值 表示 在当前位置上 所能跳跃的最远距离；
    #4 给定的数组arr 能够保证 “总是能够跳到终点位置”

要求：
    求出跳跃到终点位置所需要的最少步数；
===
分析难点 & 提出解决方案：
难点1：如何才能保证 跳跃的步数 最少？
    如果只是在 当前位置 尽可能远地往后跳，可能会出现 跳到的位置上 能够跳跃的最远距离 很小的情况————这会导致跳到终点位置需要的步数变多
解决方案：
    在当前位置跳跃最远距离，然后：
        尝试 当前位置 与 最远距离中的每一个数组元素，计算每一个位置 所能跳跃到的最远距离
    Never Mind,这种方式不是太容易理解 直接上代码看看吧

思路1：
    // 〇 对总的台阶数进行判空
    // Ⅰ 准备两个变量
        // 记录当前所使用的梯子   当前位置 + 扩展位置
        // 记录当前梯子中的台阶数量 扩展得到的台阶数量
    // Ⅱ 准备一个变量
        // 用于记录进行跳跃的数量 初始值为1（因为从初始位置不管怎么跳都要跳一步）
    // Ⅲ 准备一个level指针来遍历所有的台阶
        // 1 判断当前台阶是不是已经到了楼顶
        // 2 在移动指针的过程中，时时地更新/存储当前台阶能够连接到最远位置的梯子
        // 3 每次向前移动指针，当前梯子中剩余的台阶就会减1
        // 4 如果当前梯子的台阶已经用完了，则：
            // 1 跳到下一个梯子
            // 2 更新当前梯子所能前进的台阶数量
    // Ⅳ 返回跳跃的总次数