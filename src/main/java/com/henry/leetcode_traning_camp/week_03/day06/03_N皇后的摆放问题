# 51 N*N的棋盘中，以特定的规则摆放N个皇后。使之满足特定的要求
//n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
// 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

---
题设与要求：
题设：给定一个整数 n，在一个大小为n * n的棋盘上，按照要求摆放N个皇后；
要求：摆放后的N个皇后之间不能相互攻击；

分析难点：
    1 如何能够保证后放置的皇后不会被先前放置的皇后攻击呢？
    2 如何保证尝试了所有可能的情况呢？

难点1的解决手段：
    在摆放皇后时，如何能够保证新摆放的皇后不会被先前的皇后攻击呢？
    答：摆放之前，先使用对应的约束判断当前位置能不能用来摆放皇后————如果不能，就直接跳过该位置

难点2的解决手段：
    如何保证所有可能的摆放情况都已经被尝试了呢？
    答：按照特定的顺序，从第一行的第一列开始摆放，一直尝试到第一行的最后一列————这样就能够找到所有满足条件的摆放方式

由于每次放置皇后时都会有多个选择，所以这里可以使用回溯算法；
类比：如何找到丢失的钥匙？教室？餐厅？超市...
类比：调用栈会能够“记住”我们做出的选择，并且“知道”我们接下来会做出的选择
    每次递归调用都表示做出了一次选择
关键点：
    1 我们的选择：
        // recursion expresses decision and our decisions will be remembered in call stack
        在每一次递归调用时，我们做出了什么样的选择？
        now to the left, now to the right

    2 我们需要遵守的约束：
        什么时候我们需要 stop following a certain path?
        什么时候我们甚至不需要 go one way? 这个路径必然是不能使用的（达不到目标）

    3 我们的目标
        我们的target是什么？
        我们想要找到的到底是什么？
        注：在编写代码时goal会决定我们要如何编写base case？
        作用：找到了一个路径/结果，停止递归，然后回到上一次选择的地方，进行新的选择
