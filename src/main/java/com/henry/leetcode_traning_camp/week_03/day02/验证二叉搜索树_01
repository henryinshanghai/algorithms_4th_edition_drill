# 98 验证二叉搜索树
//给定一个二叉树，判断其是否是一个有效的二叉搜索树。
//
// 假设一个二叉搜索树具有如下特征：
//
//
// 节点的左子树只包含小于当前节点的数。
// 节点的右子树只包含大于当前节点的数。
// 所有左子树和右子树自身必须也是二叉搜索树。

// 示例 1:
//
// 输入:
//    2
//   / \
//  1   3
//输出: true
//
//
// 示例 2:
//
// 输入:
//    5
//   / \
//  1   4
//     / \
//    3   6
//输出: false

---
题设与要求：
题设：给定一个二叉树；
要求：判断这棵树是不是二叉搜索树；

分析难点与提出解决手段：
难点1：二叉搜索树的性质有哪些？
难点2：一棵二叉树如何才能满足这些性质？

手段：可以看出来这些性质中隐藏着重复性；所以递归妥妥的
一棵树是二叉搜索树：
    这棵树的左子树是一棵二叉搜索树； && 这棵树的右子树是一颗二叉搜索树 && 根节点与左右子节点之间的关系

特征：成为一棵二叉搜索树需要同时满足好些个条件，所以可以逐一排除不是二叉搜索树的情况————最后剩下的情况就一定是二叉搜索树了

SOP：
    0 递归方法的作用
    1 递归方法的触底返回条件
    2 本级递归要做的事情

二叉树的中序遍历可以使用递归来完成；可以在中序遍历的过程中判断二叉树是不是一个BST
递归地实现中序遍历的步骤：
中序遍历：左子树 - 根节点 - 右子树
之所以使用中序遍历，是因为中序遍历能够对二叉树的数值性质进行判断

任务：重复执行一段代码；
手段1：循环/迭代；
手段2：递归调用




