# 236
//给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（
//一个节点也可以是它自己的祖先）。”

// 说明:
// 所有节点的值都是唯一的。
// p、q 为不同节点且均存在于给定的二叉树中。

题设与要求：
题设：
    1 给定一个二叉树；
    2 给定树中的两个指定节点p、q；
    补充：
    3 所有节点的值都是唯一的。
    4 p、q 为不同节点且均存在于给定的二叉树中。
    5 一个节点可以是自己的最近公共祖先
要求：
    找出给定节点的最近公共祖先；

分析难点：
1 什么是节点的最近公共祖先？
答：满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）

2 如何找出两个节点的最近公共祖先？
这其实是节点p、q在二叉树中分布情况的列举问题：
    1 p、q分别在二叉树的左、右子树中；
    2 p、q两个节点全部在左子树中；
    3 p、q两个节点全部在右子树中；
    4 p、q某个节点是根节点；

已知条件：
    1 p节点、q节点在二叉树中一定存在；

尝试在左子树中查找p、q的最近公共祖先；
    如果节点p在左子树中存在，而节点q不存在。还能够查找到最近公共祖先吗？
    答：应该是查找不到了
    处理策略：只要在左子树中找到了p节点或者q节点，就把这个节点返回；
    作用：
        这样Y方法的作用就成了————在特定的树中查找是否存在两个节点p、q中的任意一个。
        如果只有一个存在，就返回查找到的节点；
        如果两个节点都存在，就返回两个节点中作为祖先节点的节点；
    现在让方法X与方法Y成为了同一个方法？？？
    方法X的作用：从指定的二叉树中查找节点p、节点q的最低公共祖先节点并返回；
    方法Y的作用：从指定的二叉树中查找是否存在节点p、q中的任意一个...

为什么这两个方法可以是同一个方法呢？
另，如果节点p、q同时出现在左子树中，怎么能够保证返回的节点是其中作为祖先节点的那一个呢？

---
重新梳理递归方法的作用：

what is LCA?

手段1：
    1 从根节点开始找到到指定的两个节点之间的路径
    2 然后比较两个路径，直到某个节点开始不同。
但是这需要额外的空间；

手段2：
    查找指定的节点p或者节点q，一旦找到了某个节点，就把该节点返回给它的父节点；
    如果某个节点从左右两侧分别得到了非nil节点，则此节点就是节点p与节点q的最低公共祖先
    然后该节点把自己返回到自己的父节点上；

从树中查找是否存在节点q或者节点q，对于每一个子树：
    如果找到了节点p或者节点q，就向父节点返回找到的节点；
    如果没有找到节点p或者q，就向都节点返回一个nil；
    当节点接收的返回值中存在nil时，该节点不是节点p与节点q的最低公共祖先
    持续向上返回值，直到根节点

场景1：待查找的节点p与节点q全部位于左子树中
先从左子树中去搜索，再去右子树中搜索；
最终左子树会把节点p与节点q的最低公共祖先返回给根节点，右子树返回的则是nil

如果返回的节点不是节点p或节点q，那么返回的节点一定是两者的最近公共祖先；

场景2：待查找的节点p、q分别位于左右子树中
如果自己不是最近公共祖先，就把自己得到的非nil节点向上传播；
最终根节点从左右两边得到了两个非nil节点，说明根节点就是节点p与节点q的最近公共祖先

场景3：待查找的节点p、q全部在右子树中
SOP：
    1 从叶子节点向上返回值（如果不是找到了节点）
    2 在右子树中找到节点后直接返回就得到了最低公共祖先；





























