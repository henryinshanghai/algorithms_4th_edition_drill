# 47 原始序列中包含重复数字的全排列结果

//给定一个可包含重复数字的序列，返回所有不重复的全排列。
// 示例:
//
// 输入: [1,1,2]
//输出:
//[
//  [1,1,2],
//  [1,2,1],
//  [2,1,1]
//]

题设与要求：
题设：给定一个序列，序列中可能包含重复数字；
要求：构造出这个序列的所有全排列结果（不能重复）；

分析难点：序列中的重复数字会如何导致全排列结果的重复？
解决手段：重复数字会导致同样的数字被多次使用（用来构造全排列结果），从而导致全排列结果是一样的/重复的

难点2：如何能够避免这种重复？
手段1：对原始序列进行去重，然后对去重后的序列进行全排列；
手段2：
    1 先对原始序列进行排序（方便后面的剪枝操作）；
    2 然后再dfs的过程中，想办法找到会导致重复全排列结果的当前遍历，再过滤掉这些遍历；
    观察递归树中的节点状态可知：
        1 当前遍历的数字与前一个数字是不是一样的（如果是一样的话，会导致完全相同的分支 aka 完全相同的全排列结果）
            手段：f(i) == f(i-1)
        2 添加的重复数字是不是合法的？（aka 是第一次出现重复的数字，还是在递归过程中第二次出现重复数字）
            手段：判断当前向全排列中添加的数字是不是刚刚被回溯过，如果是，说明这个数字之前就已经被使用过了（不干净了）。
            则，整个分支都需要剪掉
    为了使这种方式可用，需要先对原始的序列进行排序；


dfs(nums, len, i + 1, used, path, res); // EXPR：这里的depth参数绑定 depth+1 或者是 i+1都没啥关系