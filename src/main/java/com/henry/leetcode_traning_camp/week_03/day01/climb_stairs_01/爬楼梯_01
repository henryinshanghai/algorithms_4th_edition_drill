# 70
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种“不同的方法”可以爬到楼顶呢？
// 注意：给定 n 是一个正整数。


示例1：
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 一共走两步，第一步走1 阶 + 第二步走1 阶；
2. 一共走一步，第一步走2 阶；

示例 2：
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 一共走三步，第一步1 阶 + 第二步1 阶 + 第三步1 阶
2. 一共走两步，第一步1 阶 + 第二步2 阶
3. 一共走两步，第一步2 阶 + 第二步1 阶

===
题设与要求：
    题设：每一步可以爬一级台阶或者二级台阶；
    要求：爬N级台阶的方式有多少种？

===
分析难点 & 提出解决手段：
    难点：随着台阶数量n的变大，手动排列所有可能的爬法变得非常繁琐；
    解决手段1：使用”归纳法“找出 ”相邻项之间的规律“；
    解决手段2：使用递归；

===
使用递归：
前提：
    #1 当前问题能够拆解成为规模更小的同类问题吗？
        YES
    #2 更小同类问题的答案有助于解决原始问题本身吗？
        YES
    所以可以使用递归来解决当前问题；

SOP：
    0 递归方法的作用（未必与题设完全对应）：计算出在只能按照特定单步走法时，走到第N级台阶一共有多少种走法；
    1 递归终结条件：只有一级台阶————这时候就只有一种走法；
    2 本地递归需要完成的事情：
        计算走(N-1)级台阶的走法T种；
        计算走(N-2)级台阶的走法S种；
            问：M与N种有没有重合的走法？？？没有，因为它们达到的终点台阶就不一样
        (T + S)就是最终的结果

递归的解法会导致栈溢出😳

===
手段2：使用动态规划；
为什么可以使用DP来解决这个问题呢？
    祭出动态规划的4大特征：
        xxx

算法的可靠性原理：
    #1 通过上面的方式来计算得到的结果是complete & non-redundant(完整的 并且 不冗余的)；
    #2 这两种解集 覆盖了 怎么走最后一步的所有可能的场景；
    #3 由这两个解集所构造的最终解之间 不会有重叠，因为 它们的最后一步是不同的