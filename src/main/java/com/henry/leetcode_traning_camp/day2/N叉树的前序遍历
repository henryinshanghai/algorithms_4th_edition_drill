# 589 N叉树的前序遍历

---
递归解法：
// 递归方式 作用：以前序规则遍历N叉树
    List<Integer> res = new ArrayList<>();

    public List<Integer> preorder(Node root) {
        // 递归终结条件
        if(root == null) return res;

        // 本级递归需要完成的事情
        res.add(root.val);
        for(Node child:root.children){
            preorder(child);
        }

        return res;
    }

---
迭代解法：
// 迭代方式
    public List<Integer> preorder(Node root) {
        // 鲁棒性代码
        ...

        // 准备一个栈
        ...

        // 不断地更新栈中元素，并把元素以正确的顺序添加到res列表中
        while (!stack.isEmpty()) {
            // expr1:这里pop()的返回值必须要绑定到root上，否则时间会超限
            // 原因：这种做法就只是一个更新操作 如果代码是:Node currentNode = stack.pop()的话，有3个操作：1 划分空间；2 预初始化； 3 真正初始化
            root = stack.pop();
            res.add(root.val);

            // trick:把当前节点的所有子节点以从右往左的顺序入栈（这样出栈时就能保证从左往右地添加-前序遍历）
            for (int i = root.children.size() - 1; i >= 0; i--) {
                stack.push(root.children.get(i));
            }
        }

        return res;
    }