# 53 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

进阶:
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

---
题设与要求：
    题设：一个任意的整数数组；
    要求：找到数组中的一个子数组，子数组满足特定的条件————子数组中的元素的加和值最大；

分析：如何才能保证子数组中元素的加和值最大呢？
    因为数组元素既有正数又有负数，所以子数组在加和元素的过程中，加和的值可能会变大/变小。没有规则能够保证加和值一定最大
    怎么办？
    1 设置一个anchor指针，用来记录子数组的开头。
    2 设置一个int变量，用来在子数组扩展的过程中记录子数组元素当前的加和结果；
        1 当加和结果>0时，我们就继续添加新的元素进子数组；
        2 当加和结果<0时，这时候就放弃掉当前已经扩展的子数组。然后更新anchor指针，重新记录一个新的子数组...
        为什么这么做是可行的（为什么要在加和结果<0的时候使用一个新的数组）？
            如果：
                1 向当前的子数组中添加了某个元素，而且此元素导致了子数组的元素加和值为负数。
                2 然后仍旧继续添加下一个元素到此子数组。新添加的元素就没有被充分利用
                    因为 new_sum = old_sum + new_item而old_sum是小于0的。new_item的数值贡献被损耗了，因此应该重新开一个子数组
                手段：更新anchor指针，它指向子数组的头元素；

思路SOP：
    1 遍历数组中的每一个元素；
    2 选定第一个元素作为anchor指针指向的元素，然后开始扩展子数组。直到：
        1 当前子数组的sum < 0。这时候需要更新anchor指针，以便记录一个新的子数组；
        2 如果子数组的sum > 0。我们就能得到一个候选者————以anchor指针作为头元素的子数组的和；
    3 使用候选者和当前的老大哥掰掰腕子，没掰赢拉倒。掰赢了，候选者就成了新的老大哥

代码：
    // 1 准备int变量    记录当前子数组的元素加和值
            int curr_subArr_sum = nums[0];

            // 2 准备int变量    记录子数组元素加和值的最大值
            int max_subArr_sum = curr_subArr_sum;

            // 3 准备一个循环
            for (int i = 1; i < nums.length; i++) {
                // 大于0，就接着加加看 小于0，直接重置
                curr_subArr_sum = (curr_subArr_sum > 0) ? curr_subArr_sum + nums[i] : nums[i];

                max_subArr_sum = Math.max(curr_subArr_sum, max_subArr_sum);
            }

            return max_subArr_sum;

------
解法2：动态规划；
SOP：
    1 准备一个dp[]数组     用于存储状态转移方程中各个项的值
        // 1-1 状态转移方程的base case
        // 1-2 使用状态转移方程 + for loop 来求出dp[]数组中每一项的值
    2 在计算出dp[]数组所有元素的值之后，求出dp[]数组中的最大元素      aka     nums[]数组中的<元素加和值最大的子数组>的元素加和值
代码：

    // 0 鲁棒性代码
    int n = nums.length;
    if (n == 0) return 0;

    // 1 准备一个dp[]数组     用于存储状态转移方程中各个项的值
    int[] dp = new int[n];

    // 1-1 状态转移方程的base case
    dp[0] = nums[0]; // 第一个元素前面没有子数组

    // 1-2 使用状态转移方程来求出dp[]数组中每一项的值
    for (int i = 1; i < n; i++) {
        dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
    }

    // 2 在计算出dp[]数组所有元素的值之后，求出dp[]数组中的最大元素      aka     nums[]数组中的<元素加和值最大的子数组>的元素加和值
    // 得到 nums 的最大子数组
    int res = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;

