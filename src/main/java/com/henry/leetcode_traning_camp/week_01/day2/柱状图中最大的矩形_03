# 84
---
题设与要求：
给定数组，数组中第i个元素的值arr[i]表示第(i + 1)个位置上的柱子的高度

要求：计算柱状图中所能勾勒出来的矩形的最大面积；

--
分析：如何能够计算某一状态下，矩形的面积；
S = 底边长度 * 当前区间中柱子的高度；
BUT 底边长度是会随着指针位置而变化的，AND 当前区间中柱子的高度又应该选择哪个柱子呢？

手段1：使用双指针；
SOP:
    1 固定第一个指针anchor，然后让第二个指针explorer向后移动。
        explorer指针每向后移动一次，就计算一次当前所能围成的矩形的面积；
        这行不通，因为随着explorer指针的后移，所能围成的矩形的情况会发生变化————没有统一的公式来计算矩形面积；

        为什么这一套在盛水的桶中好用，但是放在这里求能够围成的最大矩形面积就不好使了呢？
        因为盛水的桶中的面积是由左右两个挡板的高度决定的；因此能够很容易地得出面积的计算公式： S = （b - a） * Math.min(height(b), height(a))
        但是这里所能围成的矩形面积却不是仅仅由区间的左右边界决定的，而是从一根柱子向左右扩展得到的；
        也就是说，有以下特征：
            1 不是指针创建出的整个区间都能参与面积的计算；
            2 只有相邻的柱子比当前柱子更高时，才能扩展矩形的面积；
            所以计算“围成的矩形面积”的核心不在于区间左右指针，而在于当前柱子；
            3 当前柱子所能扩展出的最大面积 由 当前柱子向左第一个小于当前柱子的柱子(aka 左边界) 与 当前柱子向右第一个大于当前柱子的柱子（aka 右边界）决定
            这两个边界决定了当前柱子能够扩展面积的范围

经过上述分析后，新的手段：
SOP:
    1 遍历柱状图中的每一棵柱子；
    2 计算从当前柱子所能扩展得到的矩形的面积；
    3 迭代计算每个柱子所能围成的矩形面积，以更新2中的值得到最大面积；

代码：
    class Solution {
        public int largestRectangleArea(int[] heights) {
            int area = 0, n = heights.length;
            // 遍历每个柱子，以当前柱子的高度作为矩形的高 h，
            // 从当前柱子向左右遍历，找到矩形的宽度 w。
            for (int i = 0; i < n; i++) {
                int w = 1, h = heights[i], j = i;

                // 向左找到第一个小于当前柱子高度的柱子
                // 手段：while循环，直到条件不成立时，指针刚好指在预期的位置
                while (--j >= 0 && heights[j] >= h) {
                    w++; // 累计宽度
                }
                // 把指针调整回来
                j = i;
                // 向右找到第一个小于当前柱子高度的柱子
                // 手段：while循环，直到条件不成立时，指针刚好指在预期的位置
                while (++j < n && heights[j] >= h) {
                    w++; // 累计宽度
                }

                // 更新area的值
                area = Math.max(area, w * h);
            }

            return area;
        }
    }

------
手段2：单调栈；
作用：避免暴力解法中的重复计算；
手段：
    1 遍历柱状图中的每一个柱子；
    2 在遍历过程中，把柱子的相关信息（高度/下标）入栈到一个单调栈中；
        为什么是一个单调栈而不是普通的栈呢？这是因为单调栈的特性刚好适合在这里使用
        原理：
            1 在单调栈中，当前柱子的左边界就是单调栈中上一个元素的值；
            2 在单调栈中，当前柱子的右边界就是————遍历过程中，第一次出现的小于当前柱子（栈顶元素）的柱子
            3 一旦某个柱子的左右边界确定了，就可以使用一个固定的公式来计算当前柱子所能扩展的面积大小；

        规则：遍历过程中，不断尝试把当前柱子入栈；
            1 一旦柱子成功入栈，那么栈顶元素就代表当前柱子；
            2 如果下一个尝试入栈的元素大于栈顶元素，说明栈顶元素所表示柱子的右边界还不确定。则：把该元素入栈
            3 如果下一个尝试入栈的元素小于栈顶元素，说明栈顶元素所表示柱子的右边界已经出现。则：
                计算当前柱子所能围成的矩形面积； 注：这个过程，会重新调整单调栈中的元素
            4 持续整个过程，更新矩形面积的大小；
代码：
class Solution {
    public int largestRectangleArea(int[] heights) {
        // 这里为了代码简便，在柱体数组的头和尾加了两个高度为 0 的柱体。
        int[] tmp = new int[heights.length + 2];
        System.arraycopy(heights, 0, tmp, 1, heights.length);

        Deque<Integer> stack = new ArrayDeque<>();
        int area = 0;
        for (int i = 0; i < tmp.length; i++) {
            // 对栈中柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」；
            // 若当前柱体 i 的高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」。
            // 因此以栈顶柱体为高的矩形的左右宽度边界就确定了，可以计算面积🌶️ ～
            while (!stack.isEmpty() && tmp[i] < tmp[stack.peek()]) {
                int h = tmp[stack.pop()];
                area = Math.max(area, (i - stack.peek() - 1) * h);
            }
            stack.push(i);
        }

        return area;
    }
}


