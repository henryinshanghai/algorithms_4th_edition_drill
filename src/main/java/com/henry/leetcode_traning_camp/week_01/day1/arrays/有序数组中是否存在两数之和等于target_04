# 167 在有序数组中找到两个元素，使得元素之和等于target

分析（难点）：如何能够列举数组中所有可能的两个元素？
手段1：通过两层循环来逐一列举任意两个元素的可能组合情况；
特征：这种方式其实计算了很多不可能的组合
---
代码：
    xxx

---
分析2：既然数组是有序的，如何充分利用这个条件呢？
有序数组的左边元素总是小于右边元素，所以在加和时，就可以根据加和值与target的大小来判断如何选择新的元素；

手段：准备两个指针，一边判断。一边移动；
代码：
// 对于已经升序排列的数组，使用双指针非常合适

        // 准备两个指针
        int front = 0;
        int back = numbers.length - 1;

        // 准备一个循环，在循环中：1 查找是否存在满足条件的数据对； 2 更新指针
        while (front < back) {
            // 数组中有没有包含重复的元素呢？
            int calSum = numbers[front] + numbers[back];
            if (calSum == target) {
                return new int[]{front + 1, back + 1};
            } else if (calSum < target) {
                front++; // 因为这里只要找到一个满足条件的数据对就会返回，所以即便存在重复元素，也不会导致重复结果
            } else {
                back--;
            } //  注：这种移动指针的方式默认数组中没有存在重复元素
        }

        return new int[]{0, 0};
这里其实偷了懒（题目允许的），没有单独处理数组中有重复元素时可能导致的二元组重复。