# 213 沿着一个圈来打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。
这个地方所有的房屋都 围成一圈，这意味着第一个房屋 和 最后一个房屋是紧挨着的。
同时，相邻的房屋 装有相互连通的防盗系统，
如果 两间相邻的房屋 在同一晚上被小偷闯入，系统会自动报警。

给定一个 代表每个房屋存放金额的 非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。

示例 2：
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
偷窃到的最高金额 = 1 + 3 = 4 。

======
题设与要求
题设：
    1 所有的房屋围成了一圈；
    2 每个房屋中都有相应价值的财务（为正数）可以偷取；
    3 不能连续偷取相邻的两间房屋，因为这样会触发警报；

要求：
    计算作为小偷，所能偷到的最大金额；

===
分析难点 & 提出解决方案
难点1：既然是形成了一个环，没有起点，应该从什么地方偷起呢？
答：它本质上是一个首尾相接的数组，所以就从数组的第一个元素开始就行

难点2：一个房子能不能偷，取决于这个房子的前一个房子有没有偷过了。如何能够表示出这种逻辑？
答：动态规划（最优子结构）。
dpTable[i]表示 以i作为结束位置的房子序列中 所能偷到的最大金额
因此有 dpTable[i] = Math.max(dpTable[i - 2] + nums[i], dpTable[i - 1])

难点3：现在第一所房子与最后一所房子相邻，而相邻的房子不能够同时抢劫。
这相当于添加了一些限制条件，要如何处理这些限制条件呢？
答：分类讨论；具体的做法是把原始的房子序列 人为分解成为 两个序列A与序列B；
    序列A包含第一所房子，但是不包含最后一所房子；
    序列B不包含第一所房子，但是包含最后一所房子；
这样相当于 人为地保证 第一所房子与最后一所房子不会被同时抢劫；
然后分别求出 序列A与序列B中所能抢劫到的最大金额，再求取一个Max即可

===
思路参考：https://www.youtube.com/watch?v=mFT2bIFKUFE

代码：
    // Ⅰ 处理边界情况：如果房子序列中就只有一所房子，则：最大金额就是偷这所房子
    // Ⅱ 如果房子序列中有多个房子，则：
        /*
            人为地把房子序列分解成两个子序列：
                序列A: [0, houses.length - 1];
                序列B: [1, house.length]; // 这样下标不会越界吗？
         */
        ---
        // ① 准备两个额外的变量prevOne、prevTwo & 一个变量max
        // ② 开始遍历当前区间中的每一个位置，并累加max
            // 注意：这里需要为 防止出现IndexOutOfBoundary 额外留心 比如循环变量i的范围
            // 是否抢劫当前房子：1 抢； 2 不抢； 取两者中的较大值绑定到max
            // 更新指针的值 用于计算下一个max
        // ③ 返回循环结束后求取到的max