# 1143 两个字符串之间的最长公共子序列

//给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
//
// 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
//例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

// 若这两个字符串没有公共子序列，则返回 0。

// 输入：text1 = "abc", text2 = "abc"
//输出：3
//解释：最长公共子序列是 "abc"，它的长度为 3。

======
题设与要求
题设：
    1 给定两个字符串text1 与 text2；
    2 字符串的子序列定义————对原始字符串来说，字符保持原有的相对顺序所构成的子串（可能删除掉了部分字符）；

要求：
    1 返回text1 与 text2的最长公共子序列
    2 如果没有公共子串，就返回0

分析难点 & 提出解决方案
难点1：什么叫做字符串的子序列？
答：这样一个字符串，它满足以下几个特征：
    1 所有的字符都在原始字符串中出现了；
    2 所有字符之间的相对顺序与原始字符串中字符的相对顺序一致；

难点2：如何根据原始字符串来得到它的子序列？
手段：？？？

难点3：简化问题，对于字符串text1 与 text2，如何能够得到它们的公共子串？
手段：？？？

难点4：在难点3的基础上，如何能够更快地找到公共子串中的最长公共子串？
手段：？？？


------
手段1：DP
参考链接：https://www.youtube.com/watch?v=NnD96abizww&t=2s
tushor
疑问：对于动态递推的递推公式 does it happen to to be? or does it has to be ?
代码：xxx

参考链接2：https://www.youtube.com/watch?v=Dumq-rceuac
happygirl

参考链接3:https://www.youtube.com/watch?v=ASoaQq66foQ
backToBackSWT
top north, 可惜没有代码了 因为代码被迁移到他自己的网站上了。每次解释都非常精彩

为什么会要用动态规划？
逐个回答上面的难点；
难点2：如何根据原始字符串来得到它的子序列？
答：既然字符串都是有一个个字符拼接起来得到的，那么就可以把原始字符串分解成一个个的字符。然后再对字符进行顺序地组合

难点3：简化问题，对于字符串text1 与 text2，如何能够得到它们的公共子串？
手段：直接考虑感觉无从下手，因为 从直觉上拼接 与 使用代码进行描述 中间差了些距离
具体方法：使用递归的方式来减小问题的规模；
tips:
    1 把字符串视为 “前(n-1)个字符组成的子字符串” + 最后一个字符
    2 根据text1 与 text2 最后一个字符串的异同来分类地 减少问题的规模：
        2-1 如果text1 与 text2 的最后一个字符是相同的，则：
            lcs(text1, text2)= 1 + lcs(subText1, subText2); // subText1与subText2分别是text1与text2去掉最后一个字符之后的结果
        2-2 如果text1 与 text2 的最后一个字符是不一样的，则：
            既然text1的最后一个字符对构成公共子序列没有帮助，就去掉text1的最后一个字符。然后计算 剩余的字符串 与 text2 之间的最长公共子序列
            既然text2的最后一个字符对构成公共子序列没有帮助，就去掉text2的最后一个字符。然后计算 剩余的字符串 与 text1 之间的最长公共子序列
            # Q：为什么不直接把 text1 与 text2的最后一个字符同时去掉呢？
            # A：因为虽然最后一个字符相互之间不相同，但是 text1的最后一个字符 可能与 text2中其他的字符相同————这会导致公共子序列的长度+1
            对于text2 vice versa
    3 不断分解问题的规模，直到出现 空字符串 与 某个字符串 求lcs的最简问题；
        空字符串 与 任何字符串的lcs都是0
至此，递归的思路通透。

难点：对于这样的思路，如何能够转化成为代码呢？
答：上面的思路其实是一种top-down的思路；
    aka 把大问题拆解成更小规模的问题，然后使用小问题的结果来解决大问题；
    这个过程中可能会出现 规模相同的重复小问题。
解决手段：使用bottom-up的思路 aka 动态规划
    列举小问题，一步步扩展成为大问题；
    特征：DP规划总离不开一个二维数组；

代码：
    /* 〇 准备一些DP所需要的基础变量 */
    /* Ⅰ 准备两层的嵌套循环    在循环中，填充二维数组中的每一个位置 */
    /* Ⅱ 返回最大值 */

    // EXPR1：确定需要创建的DP二维数组的大小
    // EXPR2：在创建DP数组时，多出一行 & 一列
    // EXPR3：在进行计算数组元素值时，从0开始
    // EXPR4：最后返回DP数组最右下角的元素值

// NEW EXPR:这里需要控制遍历的次数，以防止越界

一道题做一晚上 😄




