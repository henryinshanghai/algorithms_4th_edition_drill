# 120 求三角形中的最小路径和

给定一个三角形，找出自顶向下的 最小路径和。
每一步只能移动到 下一行中 相邻的结点上。
相邻的结点 在这里指的是
    #1 下标 与“上一层结点下标”相同 或者
    #2 等于“上一层结点下标 + 1”的 两个结点。

例如，给定三角形：
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

===
题设与要求：
题设：
    #1 给定一个由数字组成的三角形；
    #2 路径中的下一个节点只能是三角形中下一行中相邻的节点；
    #3 相邻的节点指的是，节点的坐标与上一层的节点坐标相同 或者 坐标+1

要求：
    找到三角形中sum值最小的数值路径

===
分析难点 & 提出解决方案
难点1：如何能够形成一条路径？
手段：在每一层按照规则选择其中的一个元素即可

难点2：如何能够保证形成的路径的sum是最小的？
手段：既然路径的形成过程是一个逐步扩展的过程，我们可以尝试使用贪心算法
aka 在每次选择元素时，都选择当前所能够找到的最小元素；
这种做法并不可行，因为当前选择了较小元素，并不能保证在此元素之后选择的其他元素也比较小

同样地，一个逐步扩展的过程。为了在这样一个过程中实现一个目标，可以使用分治的思路
分治的N多具体实现：递归、回溯、动态规划；
这里计算sum的过程可以逐步递推吗？ 可以的，所以使用动态规划

具体实现手段1：从上往下地扩展出路径；
特征：有一个限制条件/题设不好用————选择下一个元素时，只能选择与当前元素相邻的元素；
解决手段：把三角形处理成为一个二维矩阵，然后使用元素在二维数组中的位置来索引到可以选择的元素；
特性：
    在扩展的过程中需要记录两件事：1 已经使用过的元素的位置； 2 下一列中可以选择的元素的位置
    这会导致较大的空间复杂度

深情疑问：能不能不存储行的信息，而只存储列的信息呢？
可以的，手段：从下往上地来扩展路径；
rows /cols       0 1 2 3
0                   2
1                  3 4
2                 6 5 7
3                4 1 8 3 👆
👉      dpTable[0 0 0 0 0]

事实：可以把三角形放在一个n * n的正方形中。比如上面的三角形就可以在 4 * 4的方形中
这里就只需要一个一维数组作为存储空间

遵守同一个递推公式：当前位置的sum = 原始数组当前位置的元素 + 路径中的下一个元素的值 aka 下一层邻居中的较小者
rows=3
dp[0] = 4 + min(0, 0) = 4
dp[1] = 1 + min(0, 0) = 1
dp[2] = 8 + min(0, 0) = 8
dp[3] = 3 + min(0, 0) = 3

dp[] = {4, 1, 8, 3, 0}

rows=2
dp[0] = 6 + min(4, 1) = 7
dp[1] = 5 + min(1, 8) = 6
dp[2] = 7 + min(8, 3) = 10

dp[] = {7, 6, 10, 3, 0}

rows=1
dp[0] = 3 + min(7, 6) = 9
dp[1] = 4 + min(6, 10) = 10

dp[] = {9, 10, 10, 3, 0}

rows=0
dp[0] = 2 + min(9, 10) = 11
dp[] = {11, 10, 10, 3, 0}

Mark: this isn't really clear😳

特征：
1 从下往上地来更新dpTable[];
2 最终dpTable[]的第一个元素就是 从第一层到最后一层的路径的最小值

这里之所以感觉不清晰，是因为dpTable[i]的含义并不清楚
由此因此动态递推问题的三步曲：
1 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2]...)
2 存储中间状态： opt[i]
3 递推公式 aka 状态转移方程/DP方程

---
1 确定状态是什么；
2 写出状态转移方程；
3 列举状态转移方程的初始值；
4 找出状态转移方程的哪一个位置是最终要求的结果
---

Fib： opt[i] = opt[n-1] + opt[n-2]
二位路径： opt[i,j] = opt[i+1, j] + opt[i, j+1]

初学时，比较难的是第二步————定义出正确的dp状态

所以这里dpTable[i]的值到底是什么意思呢？
this is very unclear, you may need to ask the teacher about it

---
1 重复性(分治)
    problem(i, j) = min(sub(i+1, j), sub(i+1, j+1)) + a[i, j];
    大的问题(到当前层指定元素的路径) = 到上一层邻居中的路径中的较小者 + 当前层指定元素的值
2 定义状态数组；
    f(i, j)
3 确认DP方程；
    f(i, j) = min(f[i+1, j], f[i+1, j+1]) + a[i, j]

不要额外使用空间？？？
为什么Java的解法使用的是一维DP数组呢？
    因为没有存储行的信息，就只存储了列的信息

超哥的视频没有很好地解释这个问题 😳
再看一下happygirl的视频
她的说法是：
    1 我们不使用二维数组来存储：当前行选择的元素 + 上一行可选择元素的位置
    2 我们可以不去存储行的信息，而只是把每次选择的列的信息存储到一维数组中

dp[i]表示的含义 aka 定义状态：
从第i行的最后一个元素作为🔺顶部元素 开始扩展，扩展到最后一行得到的最小路径

验证：
最终的dpTable {11, 10, 10, 3, 0}
dp[0] = 11
从第0行开始，扩展到最后一行得到的最小路径的sum值为11； √
dp[1] = 11
从第1行的最后一个元素开始(a[1][1]),扩展到最后一行(在自己的🔺中)得到的最小路径的sum值为10； √
so on and so forth, the value stands!