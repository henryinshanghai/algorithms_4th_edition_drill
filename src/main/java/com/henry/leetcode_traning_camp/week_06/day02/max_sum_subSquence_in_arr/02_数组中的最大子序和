# 53 找到数组中的最大子数组的和

给定一个整数数组 nums ，找到一个 “具有最大和的连续子数组”（子数组最少包含一个元素），并 返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释:连续子数组[4,-1,2,1] 的和最大，为6。

// 如果你已经实现复杂度为 O(n) 的解法，尝试使用 更为精妙的分治法求解。

======
题设与要求
题设：
    #1 给定一个整数数组 nums;
    #2 数组中可能包含有负数元素；
    #3 子数组中至少要包含有一个元素；
    #4 子数组中的元素需要是连续的

要求：
    找到该给定的数组中的xxx最大的子数组；

===
分析难点 & 提出解决方案
难点1：如何能够构建出元素连续的子数组？
手段：可以在数组元素上使用两个指针 start与end
在构建子数组时，固定住start指针，然后移动end指针即可

难点2：如何能够得到最大的子数组？
手段：可以构建出所有可能的子数组，然后再逐一求出这些子数组的和 再进行比较，得到最大值
特诊：时间复杂度很高，为O(n^2)

===
这里既然是求 最值的问题，可以考虑 堆数据结构 & 动态规划的算法思想
动态规划问题的特征：
    1 每一个具体的问题，都有不同的“分解为子问题”的方式；
    2 对于每具体的问题，每个子问题之间如何关联的方式也都会有不同；

思路：
    1 准备一个与原始数组等大的dpTable;
    2 定义dpTable[i]的含义：以array[i]为结束位置的所有子数组中，加和值最大的子数组的sum值；
    3 遍历array中的每一个元素，对于每一个元素，根据具体情况做出具体选择：
        1 尝试把当前元素扩展到当前子数组中，然后计算扩展后子数组的sum值；
        2 尝试直接刨掉先前扩展出的子数组，然后把当前元素作为新的子数组的第一个item；
        3 比较两种方案的结果，得到最大值。并把最大值绑定到 dpTable[]中

代码：
    /* 〇 准备一个dpTable */
    /* Ⅰ 初始化dpTable[]中的一些数据，以便进行递推 */
    /* Ⅱ 遍历原始数组arr中的每一个元素
        按照给定的规则，使用递推的方式来计算dpTable[]中剩余元素的值 */
    /* Ⅲ 循环结束后，返回max的值 */
















