原则上我们能够构造出一个数学模型 来 描述任意程序的运行时时间。

影响程序运行时长的主要因素：
#1 执行每条语句的耗时；
#2 每条语句被执行的频率。

== 语句的执行频率 ==
结论：对语句执行频率的分析，很可能会产生复杂冗长的数学表达式。
我们可以通过忽略较小项的手段 来 简化这些数学公式。
表示方法：~
应用：
    #1 我们使用 ~f(N) 来 表示所有那些 随着N的增大，其除以f(N)的结果趋近于1的函数。
    #2 使用 g(N)~f(N) 来 表示 随着N的增大，g(N)/f(N)的结果会趋近于1.
    #3 如果存在 g(N)~af(N), 则称：f(N) 是 g(N)增长的数量级；
        其中g(N)为原始的数学表达式，f(N)为近似后的数学表达式

== 近似运行时间 ==
目标：得到一个Java程序的总运行时长的表达式；
手段：#1 获取到每条 "Java指令" 所对应的 "机器指令"（根据Java编译器的规范）; #2 获取到每条具体指令的执行时长（根据计算机指令规范）; #3 加和运算得到总时长；
简化手段：假设每个机器指令所需要的执行时间是固定的(对应#2);
结论：执行最频繁的指令 决定了 程序运行的总时长；
定义：把 执行最频繁的指令 成为 “程序的内循环”。

ThreeSum程序的内循环：
    #1 把k+1的语句; #2 判断是否小于N的语句; #3 判断三数之和是否等于0的语句。

== 对增长数量级的猜想 ==
结论：ThreeSum的运行时长 的增长数量级为 N3.
定义：性质 表示需要用实验进行验证的猜想；
预测手段：先假设数学模型，然后对数学模型进行分析；
验证手段：更多的实验；
如果数学分析的结果 与 实验分析的结果相同，则：说明数学模型得证 -> 程序的性质得证。

== 算法的分析 ==
结论：你所使用的算法（&输入模型）决定了 程序运行时长的增长数量级；
应用：我们对于算法的认识 可以应用于任何计算机。

== 成本模型 ==
是：一个概念；
直接作用：用于定义 所研究算法中的基础操作；
衍生作用：
    一旦确定了算法的成本模型后，具体实现所需的 运行时长增长数量级 就会与 它背后算法的 成本增长的数量级 相同。
推论：成本模型 应该与 内循环中的操作相关。
应用：基于这个“基础操作”，我们就能用精确的数学语言 来 说明算法（而非某个实现）的性质。

命题
是：一个概念；
作用：用于表示在某个成本模型下，算法所具有的数学性质。


== 研究某个算法的MO. ==
#1 研究算法准确的数学性质（命题）；
#2 对算法具体实现的性能做出猜想（性质）；
#3 通过实验 来 验证这些猜想。

黑话：命题B的数学结论 支持了 性质A中由科学方法得到并由实验验证过的猜想。

== 目标：对于任意程序，得到 其运行时长的数学模型 的步骤==
#1 确定 输入模型 -> 定义问题的规模；
#2 识别出内循环 // 频繁执行的操作；
#3 根据内循环的操作集合 来 确定成本模型；
#4 对于特定的输入，判断内循环中操作的执行频率；// 手段：数学分析?

