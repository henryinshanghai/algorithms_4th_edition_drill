锤子：学习程序的增长数量级。
应用：为同一个问题设计更快的算法；

案例：找到解决3-sum问题的更快的算法；
但我们都还没有开始学习算法，要怎么直到 如何设计一个更快的算法呢？
答：我们已经讨论过的两个经典算法 - 归并排序与二分查找；
归并排苏是线性对数级别的，二分查找是对数级别的。

== 2-sum热身 ==
方案：使用归并排序和二分查找 来 在线性对数级别 解决2-sum问题；
思路：a[i] + (-a[i]) = 0.
即对于a[i]而言，数组中存在和为0的整数对 等价于 数组中存在(-a[i])这个元素。
具体手段：
    #1 先把原始数组排序（方便进行二分查找）；
    #2 对于数组中的当前元素a[i],对(-a[i])执行二分查找 - 手段：BinarySearch的rankOf()方法
    如果结果为j 且 j>i(说明在后面的元素中找到了(-a[i])),则：把计数器+1

== 3-sum的快速算法 ==
照猫画虎

== 新问题的处理方式 ==
#1 实现并分析 该问题的一种简单解法；
#2 尝试算法的各种改进 - 通常会降低算法所需的运行时长的增长数量级；
#3 用实验证明 新的算法更快。

🐖 现实世界中，程序的运行时长只是需要考虑的多种因素之一。