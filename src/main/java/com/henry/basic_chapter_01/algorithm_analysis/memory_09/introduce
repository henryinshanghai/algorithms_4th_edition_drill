和运行时间一样，一个程序对内存的使用 也和物理世界直接相关：
计算机中的电路 很大一部分的作用 就是帮助程序保存一些值 并在 稍后取出它们。

在任意时刻需要保存的值越多，需要的电路 也就越多。
你可能知道 计算机能够使用的内存上限（知道这一点的人 应该比 直到运行时间限制的人 要多）
因为你很可能已经 在内存上 花了不少额外支出。

计算机上的Java 对内存的使用 经过了精心的设计（程序的每个值 在每次运行时所需的内存量 都是一样的），
但是 实现了Java的设备 非常多，而内存的使用 是和具体实现直接相关的。
简单起见，我们使用 “典型” 这个词 来 暗示“和机器相关的值”。

Java最重要的特性之一就是 它的内存分配系统。
他的任务就是 把你从对内存的操作中 解脱出来。
显然，你肯定已经知道 应该在 适当的时候 利用这个功能，但是你也应该（至少是大概）
直到 程序对内存的需求 在何时 会成为 解决问题的障碍。

分析内存的使用 比起 分析程序所需要的运行时长 要简单得多，主要原因是 它所涉及的程序语句比较少（就只有声明语句）
并且 在分析中 我们会 将复杂的对象 简化为 原始数据类型，而 原始数据类型的内存使用 是预先定义好的，而且非常容易理解：
只需要把 变量的数量 和 它们的类型所对应的字节数 分别相乘并汇总即可。
比如，在java中，int数据类型是 -2147483648 到 2147483647之间的整数值的集合，也就是 总数量为2^32个不同的值。
所以,"典型的Java实现" 就会使用32位 来 表示int值。
其他原始数据类型的内存使用 也是基于 类似的考虑：
典型的java实现，使用8位表示字节，使用2字节表示一个char值，使用4字节表示一个int值，使用8字节 表示一个double或者long值，
使用1字节 表示一个boolean值（因为计算机访问内存的最小单元 就是一次一字节）。

根据可使用内存的总量 就能够计算出 保存这些值的极限数量。
比如，如果计算机有1GB的内存（10亿字节），那么同一时间 最多能够 在内存中保存 2.56亿万个int值 或者 1.28亿万个 double值。

从另一方面来说， 对内存使用的分析 与 硬件、Java的不同实现中的各种差异 都有关系。
因此 我们列举出的特定的例子 并不是 一成不变的 - 你应该 以它为参考 来 学习在条件允许的情况下 如何分析内存的使用。
比如，许多数据结构 都涉及 对机器内存地址的表示。而在各种不同的计算机中，表示一个机器地址所需要的内存会各不相同。

为了保持一致，我们假设 表示机器地址会需要8个字节 - 这是 现在广泛使用的 64位结构中的典型表示方式，而
许多老式的32位架构 会使用4字节 来 表示内存地址。

#1 对象

如果想要知道 一个对象所使用的内存用量，则：
需要将所有实例变量 所使用的内存 与 对象本身的开销（一般是16字节）相加。

对象本身的开销：一个指向对象的类引用、垃圾收集信息以及同步信息。
另外，一般内存的使用 都被被填充为8个字节（它是64位计算机中的机器字）的倍数。
例如，一个Integer对象 会使用24字节（16字节的对象开销、4字节用于保存它的int值，还有4个填充字节）。
类似地，一个Date对象 会需要使用32个字节（16字节的对象开销、3个int实例变量各需要4个字节，以及4个填充字节）。

对象的引用 一般都是一个内存地址，因此会使用8个字节。
比如，一个Counter对象会需要使用32个字节：16个字节的对象开销、8个字节用于它的String实例变量，4个字节用于int实例变量，还有4个填充字节。
🐖 当使用 “一个引用所占用的内存”的说法时，我们会单独说明 它所指向的对象所占用的内存。
所以这里的 内存使用总量 并没有包含 String值 所使用的内存。

#2 链表
如图总结了 Java中的 各种类型的数组 对内存的典型需求。
Java中数组被实现成为 对象，它们一般都会因为记录长度而需要额外的内存。
一个 原始数据类型的数组 一般需要24字节的头信息（16个字节的对象开销，4个字节用于保存长度以及4个填充字节）
再加上 所保存的值 所需要的内存。
比如，一个含有N个int值的数组 需要使用(24+4N)字节（会被填充为8的倍数）。

一个对象的数组 就是 对象的引用所构成的数组。所以 我们需要在 对象所需要的内存之上，加上 引用所需的内存。
比如，一个含有N个Date对象的数组 会需要使用 24字节（数组开销） 加上 8N字节（所有引用）加上 每个对象的32字节，
总共（24+40N）字节。

二维数组是一个 数组的数组（每个数组都是一个对象）。
例如一个大小为 M*N的double类型的二维数组，会需要使用24字节（数组的数组的开销）加上 8M字节（所有元素数组的引用）加上24M字节（所有元素数组的开销）
加上 8MN字节（M个长度为N的double类型的数组），总共（8MN+32M+24） ~ 8MN字节；

当数组元素是对象时，计算方法类似，结果相同 - 用来保存 充满指向数组对象的引用的数组 以及 所有这些对象本身。

#3 字符串对象
我们可以 用相同的方式 来 说明Java的String类型对象 所需要的内存，只是
对于字符串来说 别名是非常常见的。
String的标准实现中 包含有4个实例变量：#1 一个指向字符数组的引用（8个字节）和 #2 3个int值（各4个字节）。
第一个int值描述的是 字符数组中的偏移量，第二个int值是一个计数器（字符串的长度）。

按照如图所示的实例变量名，对象所表示的字符串 由 value[offset] 到 value[offset + count - 1]中的字符所组成。
String对象中的第三个int值 是一个散列值 - 它在某些情况下可以节省一些计算，目前我们可以忽略它。
因此，每个String对象总共会使用40字节（16字节表示对象，3个int实例变量各自需要4字节，加上数组引用的8字节和4个填充字节）。

这就是除了字符数组之外，字符串所需要的内存空间，而所有字符所需要的内存则需要另外计算，因为String中的char数组 常常是 在多个字符串之间共享的。
因为String对象是不可变的，这种设计
使String的实现 能够 在多个对象都含有相同的value[]数组时 节省内存。

#4 字符串的值和子字符串
一个长度为N的String对象一般需要使用 40字节（String对象本身） 加上 (24+2N)字节（字符数组），总共 (64+2N)字节。
但是字符串处理 经常会与子字符串打交道，所以
Java对字符串的表示 希望能够避免复制字符串中的字符。
当你调用subString()方法时，就会创建一个新的String对象（40字节），但是它仍旧重用了 相同的value[]数组，因此
该字符串的子字符串只会使用40字节的内存。

含有原始字符串的 字符数组的别名 存在于 子字符串中。
子字符串对象的偏移量 和 长度域 标记了 子字符串的位置。
换句话说，一个子字符串所需要的额外内存 是一个常数，构造一个子字符串所需要的时长也是常数 - 即便字符串与子字符串的长度很大时也是这样。

某些简陋的字符串表示方法 在创建子字符串时，会需要 复制其中的字符 - 这会导致 线性的时间和空间。
"确保子字符串的创建所需要的空间和时间 与其长度无关" 是 许多基础字符串处理算法效率的关键所在。

字符串的值与子字符串示例如图所示。

这些基础机制能够 有效帮助我们 来 估计很多程序的内存使用情况，但是很多复杂的因素仍然会使这个任务变得更加困难。
我们已经提到了 别名 可能产生的潜在影响。
另外，当涉及函数调用时，内存的消耗就变成了一个复杂的动态过程。
因为Java系统的内存分配机制 在此扮演了一个重要的角色，而这套机制 与Java的具体实现有关。
比如，当你的程序调用一个方法时，系统会从内存的一个特定区域中 来 为方法分配 方法所需要的内存（用于保存局部变量）- 这个区域叫做“栈区域”。
当方法返回时，它所占用的内存 也会被返回给系统栈。
因此，在递归程序中创建数组 或者是 其他大型对象是危险的，因为 这意味着每次递归调用 都会占用大量的内存。

当通过new来创建对象时，系统会从内存的另一块特定区域（“堆区域”） 来 为该对象分配所需要的内存空间。
而且，所有的对象都会一直存在，直到它的引用消失为止 - 这时候，系统的“垃圾回收进程”会把它所占用的内存 回收到堆中。
这种动态过程 使得 准确估计一个程序的内存使用 变得极为困难。
