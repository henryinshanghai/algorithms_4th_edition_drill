目标：预测任意程序的性能 并判断它们的运行时长的大致增长数量级。
手段：
#1 开发一个输入生成器 来 生成实际情况下的各种可能输入；
#2 运行DoublingRatio程序，来计算每次实现和上次运行时间的比值；
#3 反复运行，直到该比值趋近于极限 2^b.

特征：这个实现对于那些个 比值没有极限的算法 是无效的，但它其实适用于很多的程序。
结论：
    #1 所适用的程序的运行时长增长数量级 约为N^b;
    #2 如果想要预测一个程序的运行时间，可以 把上次观察得到的运行时间 乘以 2^b，并将N加倍，如此反复。
🐖 如果你所希望预测的输入规模不是 N乘以2的幂，则：可以相应地调整这个比例。

这个测试类似于 之前所描述的过程(运行实验，绘制出 对数图像来得到运行时间为 aN^b的猜想。然后从直线的斜率得到b的值，进而算出a)
但它更容易使用。

事实上，可以手动使用 DoublingRatio 来 准确地预测程序地性能。

当比例趋近于极限时，只需要 不断乘以该比例 就能够得到 更大规模地问题的运行时长。
增长数量级的近似模型 是一个幂次法则，其中指数是 该比例的以2为底的对数。

追问：为什么这个比例会趋于一个常数呢？
简单的数学计算 显示出 我们讨论过的所有常见的增长数量级函数(指数级别除外)都会出现这种情况👇

命题C(倍率定律) 如果T(N)~aN^blgN, 则：T(2N)/T(N) ~ 2^b;
证明
    T(2N)/T(N) = a(2N)^blg(2N)/aN^blgN
               = 2^b(1+lg2/lgN)
               ~ 2^b
一般来说，数学模型中的对数项 是不能够忽略的，但是 在倍率假设中，它在预测性能的公式中的作用 不太重要。

应用：在有性能压力的情况下，应该考虑对编写过的所有程序 进行倍率实验。
因为倍率实验 是一种评估运行时长的增长数量级 的简单方法。
或许能够发现一些性能问题，比如你的程序并没有想象的那样高效。
一般来说，我们可以使用 下面的方式 来 对程序的运行时长的增长数量级 做出假设 并 预测它的性能。

#1 评估它解决大型问题的可能性；
    对于每一个编写的程序，你都需要能够回答这个基本问题：“该程序能在 可接受的时间内 处理这些数据吗？”
    对于大量数据，如果想要回答一个问题 我们就需要一个 比乘以2更大的系数（比如10） 来 进行推断，参考表格。
    无论是 投资银行家处理 每日的金融数据 还是 工程师对设计进行模拟测试，定期运行一个 需要若干小时才能完成的程序是很常见的。
    了解程序的运行时长的增长数量级 能够为你提供精确的信息，而从帮助你 理解你能够解决的问题规模的上线。

    理解注入此类的问题，是研究性能的首要原因。
    没有这些知识，你对一个程序所需的时间一无所知；
    而如果你有了它们，一张信封的背面就足够你 计算出运行所需时长 并 采取相应的行动。

#2 评估“使用更快的计算机”所能够产生的价值
    你可能会面临的另外一个基础问题是：“如果我能够得到一台更快的计算机，那 解决问题的速度能够加快多少？”
    一般而言，如果新的计算机 比起 老的计算机 快上x倍，那么 运行时长也会变成原来的x分之一。
    但你一般都会 用新计算机 来 处理更大规模的问题。这会怎么样影响 所需要的运行时长呢？
    同样，增长的数量级信息 也正是你 回答这个问题 所需要的信息。

    著名的摩尔定律告诉我们，18个月后 计算机的速度和内容容量都会翻一番，5年后计算机的速度和内存通量都会变成现在的10倍。
    下表说明，如果你所使用的是平方 或者 立方级别的算法，摩尔定律就不适用了。
    进行倍率测试 并检查随着输入规模的倍增，前后运行时间之比 是趋向于2 而不是4或者8，就能够验证这种情况。

表 - 根据增长的数量级函数所做出的预测
运行时长的增长数量级 系数为2 系数为10   处理输入规模为N的数据会需要若干个小时的某程序
  描述     函数                     处理10N的预计时间      在快10倍的计算机上处理10N的预计时间

