在对程序的性能进行仔细分析时，有很多种原因 可能会导致一个不一致 或者有误导性的结果。
它们都是由于我们的才行所基于的一个或者多个假设 并不完全正确所导致的。

我们可以根据新的假设得到新的猜想，但是我们考虑的细节越多，在分析中需要注意的方面也就越多。

#1 大常数；
在首项近似中，我们一般会忽略低级项中的常数系数。但这可能是错误的做法。
比如 当我们取函数 2N^2+cN的近似为 ~2N^2时，我们的假设是c很小。
如果事实不是这样（比如c是10^6）,这种近似就是错误的。因此 我们要对可能的大常数 保持敏感

#2 非决定性的内循环；
内循环是绝对性因素的假设 并不总是正确的。
错误的成本模型，可能会导致无法得到真正的内循环，问题的规模N 也许没有达到
对指令的执行频率的数学描述中的首项 大大超过其他低级项 并可以忽略它们的程度。
有些程序在内循环之外也有大量的指令需要考虑。
换句话说，成本模型可能还需要改进。

#3 指令时间；
每条指令执行所需的时间总是相同的假设 并不总是正确的。
比如，大多数现代计算机系统 都会使用缓存技术 来 组织内存。
在这种条件下，访问大数组的若干个并不相邻的元素 所需要的时长可能会很长。
如果让 DoublingRation运行的时间久一些，你可能 能够观察到缓存对ThreeSum所产生的效果。
在运行时长的比例看似收敛到8之后，由于缓存，对于大数组 该比例也可能突然变成很大的值。

#4 系统因素；
一般来说，计算机上会同时运行着很多的程序。
Java只是增多资源的众多应用程序之一，而且
java本身也有很多 能够大大影响程序性能的选项和设置。
某种垃圾收集器 或者 JIT编译器 或者 正在从因特网中进行的下载 都可能极大地影响实验的结果。
这些因素可能会干扰到 “实现必须是可重复的” 这条科学研究的基本原则，因为此时此刻 计算机上所发生的一切 是无法再次重现的。
原则上来说，此时系统中运行的其他程序 应该是可以忽略 或者 可以控制的。


#5 不分伯仲；
在我们比较执行相同任务的两个程序时，常常出现的情况是 其中一个在某些场景中更快，
而在另一些场景中更慢。
我们已经提到过的一些因素 可能会造成这种差异。
有些程序员（以及一些学生）特别喜欢投入大量精力 进行比赛 并找出“最佳的”实现，但此类工作最好还是留给专家。

#6 对输入的强烈依赖；
在研究程序运行时长的增长数量级时，我们首先做出的几个假设之一就是 运行时间应该和输入“相对无关”。
当这个条件无法满足时，我们很可能无法得到一致的结果 或是 验证我们的猜想。
比如 为了回答“输入中是否存在和为0的三个整数？”，我们可以 修改ThreeSum并返回boolean值，
把count++替换成为 return true，然后在最后加上return false作为结尾。
对于这种任务，如果输入的头三个整数的和 就为0，则：该程序的运行时长的增长数量级为常数级别；
如果输入中 不存在满足条件的三个整数，则：程序的运行时长 增长数量级就是立方级别。

#7 多个问题参量；
我们过去的重点一直是使用 仅需要一个参量的函数 来 衡量程序的性能，参量一般是 命令行参数 或者 输入的规模。
但是，多个参量也是可能的。
典型的例子是 需要构造一个数据结构 并 使用该数据结构 进行一系列操作的算法。
在这种应用程序中，数据结构的大小 和 操作的次数 都是问题的参量。
我们已经见过一个这样的例子，也就是 对于使用二分查找的白名单问题 的分析。
其中白名单中有N个整数 而输入中有M个整数，这种情况下，运行时长一般和MlogN成正比。

===
尽管需要注意的问题有很多，但对于每个程序员来说，对程序的运行时长的增长数量级的理解  都是非常有价值的。
这里所描述的方法都十分强大 并且 应用范围广泛。

Knuth证明了 原则上 只要我们完整并正确地使用这些方法，我们就能够对程序做出详细而准确地预测。

计算机系统一般都非常复杂，完整精确地分析最好留给专家们，但 相同的方法也能有效地估计出 任何程序所需要的运行时长。

火箭科学家需要大致直到 一枚实验火箭的着陆点实在大海中还是城市中；
医学研究者 需要直到一次药物测试是会杀死还是治愈实验对象；
任何使用计算机程序的科学家 或者这是 工程师 也应该能够语句 它是会运行一秒钟 还是 一年。