对于许多问题，刚才所提到的注意事项中 最突出的一个就是对于输入的依赖。
因为在这种情况下，程序的运行时长的变化范围 可能非常大。

ThreeSUm的修改版本的运行时间的范围 根据输入的不同可能在常数级别到立方级别之间。
因此 如果我们想要预测它的性能，就需要对它 进行更加细致的分析。

在这里我们 会简要讨论 一些有效的方法，我们会在学习本书中的其他算法是用到它们。

#1 输入模型；
一种方法是更加小心地对我们待解决的问题 所需要处理的输入 进行建模。
比如，我们可能会 假设ThreeSum的所有输入 都是随机int值。
使用这种方法的困难主要有两点：
① 比如模型 可能是 不切实际的；
② 对输入的分析可能极端困难，所需要的数学技巧 远非一般的学生或者程序员能够掌握的。

其中前者更为重要，因为计算的目的 就是发现输入的性质。
比如我们编写了 一个程序 来 处理基因组，那么 我们要怎么样才能够估算出 它在处理不同的基因组 时的性能呢？
科学家们正在竭力 找寻 能够描述自然界中的基因组 的优秀模型。
所以 预计我们的程序在处理自然界中得到的数据时所需要的运行时长，实际上也正在为寻找这个模型做出贡献！

第二个困难只与最重要的几个算法的数学结果有关。

我们将会看到 几个使用简单可靠的输入模型 + 经典的数学分析 来 帮助我们预测程序性能的例子。

#2 对最坏情况下的性能的保证；
有些应用程序要求程序 对于任意输入的运行时间 均小于 某个指定的上限。
为了提供 这种性能保证，理论研究者们 要从极度悲观的角度 来 估计算法的性能：
在最坏的情况下，程序的运行时长是多少？
例如，这种保守的做法 对于运行在核反应堆、心脏起搏器或者刹车控制器之中的软件是非常必要的。
我们希望此类软件能够在某个指定的时间范围内 完成任务，否则 结果就会非常糟糕。

科学家在研究自然界时，一般不会去考虑最坏的情况：在生物学中，最坏的情况也许是人类的灭绝；
在物理学中，最坏的情况可能是宇宙的结束。
但是，在计算机系统中，最坏的情况是非常现实的忧虑，因为程序的输入 可能来自于 另外一个（可能是恶意的）用户 而不是自然界。
比如，没有使用 提供性能保证算法的网站，会无法低于 “拒绝服务攻击” - 这是一种使用大量请求 来 淹没服务器的攻击，它会是的 网站的运行速度 相比于正常状态 大幅下降。

因此，我们许多算法的设计 都已经考虑了 为性能提供保证。比如
结论：在 Bag、Stack、Queue的链表实现中，所有操作 在最坏情况下 所需要的运行时长 都是常数级别的。
证明：由代码可知，每个操作所执行的指令数量 都小于一个很小的常数。
🐖 该论证依赖于一个合理的假设，也就是说 Java系统能够在尝试时间内创建出一个 新的Node对象。

#3 随机化算法；
为性能提供保证的一种重要方法是 引入随机性。
比如，在之后学习的快速排序算法（它可能是 使用最为广泛的排序算法）在最坏情况下的的性能是平方级别的。
但是通过 随机打乱输入，根据概率我们能够保证它的性能是线性对数的。
每次运行该算法，它所需要的时间 都会不相同，但是 它的运行时长 超过 线性对数级别 的可能性 小到可以忽略不计。
与此类似，在3.4节，我们会学习 用于符号表的散列算法（也算是使用最广泛的同类算法）
它在最坏情况下的性能 是线性级别的，但是根据概率，我们可以保证 它的运行时间是常数级别的。

这些保证 并不是绝对的，但是它们失效的可能性甚至小于 你的电脑被闪电击中的可能性。
所以，这种保证 在实际中 也可以用来 作为最坏情况下的性能保证。

#4 操作序列
对于许多应用来说，算法的“输入”可能并不只是数据，还包括 用例进行的一系列操作的顺序。
例如，对于一个下压栈来说，用例先压入N个值，然后再将它们全部弹出 所得到的性能，
与N次压入&弹出的混合操作序列 所得到的新能 可能是大不相同的。
我们的分析要将所有这些情况都考虑进去（或者要 包含一个操作序列的合理模型）

#5 均摊分析

相应地，提供性能保证的另一种方式是 通过记录所有操作的总成本 并处理操作总数 来 将成本均摊。
在这里，我们可以先 允许一些 昂贵的操作，但保持所有操作的平均成本 较低。
这种类型分析的典型例子是 我们再1.3节中 对 “基于动态调整数组大小的Stack数据结构”的研究。
简单起见，假设N是2的幂。
如果数据结构初始为空，N次连续的push()调用 会需要访问数组多少次？
计算这个答案很简单，数据的访问次数为：
    N+4+8+16+...+2N=5N-4
其中，首项表示N次push()调用，其余的项 表示每次数组长度加倍时 初始化数据结构所访问数组的次数。
因此，每次操作访问数组的平均次数 都是常数，但是 最后一次操作所需要的时间是线性的。
这种计算 被称为 均摊分析，因为我们 将少量昂贵操作的成本 通过各种大量 廉价的操作 摊平了。

VisualAccumulator 能够很容易地 展示这个过程。如图所示

命题： 再“基于可调整大小的数组来实现的”Stack数据结构中，对空数据结构所进行的任意操作序列 对数组的平均访问次数
在最坏的情况下 均为常数。

简略证明： 对于每次会使数组增加（假设大小从N变成2N）的push操作，对于N/2+2到N之间的任意k，
考虑 使栈大小增长到k的最近N/2-1次push()操作。
将 使数组长度加倍 所需要的4N次访问 和 所有push()操作所需要的N/2次数组访问（每次push()操作都会需要访问一次数组）取平均，
我们就可以得到 每次操作的平均成本 为 9次数组访问。
要证明 长度为M的任意操作序列 所需的数组访问次数 和M成正比 则会更加复杂（练习1.4.32）

这种分析的应用范围很广，我们会使用 可动态调整大小的数组 作为数据结构 来 实现 本书中的若干算法。

算法分析者的任务 就是 尽可能地揭示 关于某个算法的更多信息，
而程序员的任务 则是利用这些信息 来 开发有效解决现实问题的程序。
在理想状态下，我们希望根据算法能够得到 清晰简洁的代码 并 能够为我们 所感兴趣的输入 来 提供良好的保证和性能。

我们在本章中讨论的许多经典算法 之所以对众多应用都十分重要，就是因为 他们具备这些性质。
以它们作为样板，在编程中遇到典型问题时，你也能独立给出很好的解决方案。

