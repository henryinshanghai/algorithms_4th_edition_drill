目标：说明/展示 设计与分析算法的基本方法；
手段：学习一个具体的例子。
takeaway：
    #1 优秀的算法 会能够真正解决实际问题；
    #2 高效算法的代码 也可能非常简单；
    #3 理解“某个具体实现的性能特点” 是一项有趣而令人满足的挑战；
    #4 在 “解决同一个问题的多种算法” 之间做选择时，“科学方法”是一种重要的工具；
    #5 “迭代式改进”能够让算法的效率越来越高。

agenda：
    #1 问题的提出 - 一个非常基础的计算性问题；
    #2 问题的解决 - 我们的解决方案会被应用于很多实际应用中；
    #3 流程：#1 给出一个简单的解决方案； #2 对方案的性能进行研究； #3 根据#2的结论 来 改进我们的算法；

===
动态连通性问题

输入：一列“整数对”；
    其中，每个整数 都表示一个某种类型的对象；
    一对整数 p-q 可以理解为 “p与q是相连的”。
    假设：”相连“的属性 是一种 ”等价关系“。也就是说它具有
        #1 自反性：p与p本身是相连的；
        #2 对称性：如果p与q是相连的，则：q与p也是相连的；
        #3 传递性：如果p与q是相连的，而且 q与r是相连的，则：p与r也是相连的。
    ”等价关系“的作用：用于 将对象分成多个”等价类“；
    在这个问题中，当且仅当两个对象相连时，它们才属于 同一个等价类；
    简单理解：”等价类“ 就是一个 组。

目标：编写一个程序，它能够过滤掉程序中 所有”无意义的整数对“；
”无意义的整数对“： 数对中的两个整数 来自于 同一个”等价类“；

对目标的理解：
程序读取了 整数对p q时，如果已知所有的整数对 都不能说明 p与q是相连的，则：把这样的整数对 写入到 输出中；
而如果 ”已知的数据“ 能够说明 p与q是相连的，则：忽略此数对，并处理下一个数对。

重述：对于当前数对，如果两个数没有相连，则：将它们连通；如果已经相连了，则：跳过它们。

图示过程：对象的图形化分布 + 一列整数对；

手段：
为了达到预期的效果，我们需要：
设计一个数据结构 来
    #1 保存程序当前已知的 整数对的足够多的信息，并且
    #2 能够使用这些信息 来 判断一个新的数对中的两个数 是否相互连通；

抽象问题本身的所属分类：动态连通性问题；
所谓”动态“，是因为 会在读取数对的过程中，逐步生成 数据结构；

===
动态连通性问题的具体应用：

#1 网络；
抽象 -> 具体
    整数 -> 大型计算机网络中的计算机单体；
    整数对 -> 网络中的连接；

程序的具体作用：
    #1 判断我们是否需要 在p与q之间架设一条新的连接，才能进行通信；
    #2 通过已有的连接，如何在 p与q之间建立通信。

    整数 -> 电子电路中的触点；
    整数对 -> 连接触点的电路；

    整数 -> 社交网络中的人；
    整数对 -> 朋友关系；
特征：对于这一类应用，我们可能会 需要处理 数百万个对象 与 数十亿连接。

#2 变量名的等价性：
事实：有些编程环境中，会允许声明两个等价的变量名, aka, 这两个/多个引用 指向同一个对象；
衍生需求：在一系列这样的声明之后，系统需要能够 判断出 两个给定的变量名之间 是否是等价的。

事实：这种比较早出现的应用（比如 FORTRAN语言） 推动了 我们即将讨论的 算法的发展。

#3 数学集合；
在更抽象的层次上，可以有以下映射关系：
    整数 -> 整数
    整数对 -> 两个整数
    程序的作用：
        #1 判断整数对中的两个整数 是否属于 相同的组/集合；
        #2 如果不是的话，则：把整数p所属的集合 与 整数q所属的集合 归并到同一个集合中去（连通操作）；

===
为了进一步限定话题，我们会使用 网络相关的术语👇
把”对象“称为”触点“；
把”整数对“称为”连接“；
把”等价类“称为”连通分量“（分量）；

对输入的限定：由[0, N-1]区间内的每个整数所表示的 N个触点；
🐖 这样做不会降低算法的通用性，在第3章中，我们会学习一些高效算法 - 使用它们，我们就能够把 整数标识符 与 任意名称关联起来。

”连通性问题“的难度评估：
看一眼图，嗯，比较困难。
625个触点，900条边，3个连通分量(组/集合)

难点：
程序本身只知道 触点的名称与连接，而不知道 触点在图像中的几何位置。
这样要怎么判断 网络中两个给定的触点 是不是相互连接的呢？

我们在设计算法时，面对的第一个问题 就是 精确地定义问题。
我们希望算法能够解决的问题越大，那么 它完成任务所需要的时间和空间 可能就越多。
而我们不可能预先知道 两者之间的量化关系。并且我们通常会发现：
    #1 解决问题很困难，或是代价巨大；
    #2 算法所提供的信息 比起 原始问题所需要的信息 更加有用，这时候我们会反过来修改问题（比如 是否存在xxx -> 满足xxx的最短路径）

连通性问题只会要求 我们的程序判定 给定的整数对p-q是不是相连的，而没有要求给出 连接通路上的所有连接。
🐖 这样的要求会使得问题更加复杂，我们需要完全不同的算法才能够回答它（第四章）

为了说明问题本身，我们设计了一份API 来 封装所有需要的基本操作：
#1 初始化；- UnionFind()
#2 对两个触点进行连接； unionToOneGroup(p, q)
#3 获取包含了某个触点的分量； findGroupIdOf(p) p所在的分量的标识符
#4 判断两个触点是否存在于同一个分量之中；isConnectedBetween(p, q)
#5 返回所有分量的数量。 groupAmount()

为解决“动态连通性问题”来设计算法的任务 转换为 实现这份API；
所有的实现都应该：
#1 定义一个数据结构 表示 已知的连接；
#2 然后在这个数据结构，实现高效的 unionToOneGroup, findGroupIdOf(), isConnectedBetween(),  groupAmount()方法。

众所周知，数据结构的性质 会直接影响到 算法的效率，因此 数据结构和算法的设计 是紧密相关的。
API已经说明了 触点和分量都会使用int值来表示，
所以我们可以使用 一个以触点为索引的数组 nodeToItsGroupArray[] 作为基础数据结构 来 表示所有的分量。
我们会使用 分量中的某个触点的名称 来 作为分量的标识符。 aka， 每个分量都是由它的一个触点来表示的。
最开始时，存在有N个分量 - 每个触点都构成了 一个仅包含它自己的 分量。

最开始，我们把 nodeToItsGroupArray[node] 的值初始化为 node本身，
对于每一个触点node，我们会使用findGroupIdOf()方法 来 判断它所在的分量。
然后把 分量的Id 保存到 nodeToItsGroupArray[node]中。

isConnected()方法的实现 只用一条语句就可以实现 - findGroupIdOf(p) == findGroupIdOf(q)
它返回一个布尔值，在所有方法的实现中，都会使用到 isConnected()方法