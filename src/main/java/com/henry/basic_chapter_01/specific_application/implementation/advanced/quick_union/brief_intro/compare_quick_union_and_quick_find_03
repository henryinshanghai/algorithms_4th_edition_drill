quick-union算法分析

quick-union算法 看起来 比 quick-find算法 更快，因为它 不需要 为 每一对输入都 遍历整个数组。
但具体 快多少呢？

分析 quick-union算法的成本 比起 分析 quick-find算法的成本 更加困难，因为 这会 依赖于 输入的特点。
在 最好的情况 下，find() 只需要 访问数组一次 就能够得到 一个触点所在的分量 的标识符。
而 在 最坏的情况 下，这会 需要 2N+1次数组访问，如图所示的 0触点 -
这个估计 是 较为保守的，因为 while循环中 经过编译的代码 对id[p]的第二次引用 一般都 不会访问数组。

由此 我们不难构造一个 最佳情况的输入 使得 解决动态连通性问题的用例 的运行时长 是 线性级别的；
另一方面，我们也可以构造出 一个最坏情况的输入，这种情况下，它的运行时长 是平方级别的。

所幸我们不需要 面对分析quick-union算法的问题 - 我们也不会 仔细对比 quick-union算法 和 quick-find算法的性能。
因为我们会学习一种 比两者效率都要高很多 的算法。

目前，我们可以 把 quick-union算法 视为 quick-find算法的 一种改进版本，因为
它解决了 quick-find算法中 最主要的问题：union()操作 总是线性级别的。

对于 一般的输入数据，这个变化 显然会是 一次改进。
但是 quick-union算法 仍旧存在问题，因为 我们不能保证 在所有情况下 它都能够比起 quick-find算法 快得多。
事实上，对于某些输入 quick-union算法 不会 比 quick-find算法 更快。

定义：
    一棵树的大小(size) 是 它所包含的所有节点的总数量。
    树中某个节点的深度(depth) 是 该节点到根结点的路径上 所有链接的数量(link's amount)。
    树的高度(height) 是 所有节点深度中的最大深度。

命题：
    quick-union算法中的 find()方法 所访问数组的次数 为 1 加上 给定触点所对应的节点的深度 的两倍。
    union() 和 connected() 访问数组的次数 为 两次find()操作 - 如果 union()中 给定的两个触点 分别存在于 不同的树中，则 还会需要+1.

同样，假设我们 使用 quick-union算法 来 解决”动态连通性问题“，并 最终只得到了一个分量。
根据 以上命题，可以推论：算法的运行时长 在最坏情况下 是平方级别的。

假设 输入的整数对 是 有序的 0-1、0-2、0-3等，
N-1对之后 我们的N个触点 将 全部处于 相同的集合 之中，
且 由 quick-union算法 所得到的 树的高度为 N-1，其中0链接到1，2链接到3，如此下去。

再 由命题G推论，对于 整数对0-i，union()操作 所访问的数组的次数 为 2i+3(触点0的深度为i，触点i的深度为0).
因此，处理N对整数 所需要的 所有find()操作 所访问数组的总次数 为 2(1+2+...+N) ~ N^2.