quick-find算法

一种方式是 保证 当且仅当 nodeToGroupIdArray[nodeP] 等于 nodeToGroupIdArray[nodeQ]时，nodeP 与 nodeQ是 相互连通的。
aka 在同一个连通分量中的所有触点 在nodeToGroupIdArray[]数组中的值 都必须要 完全相同。
在 此基础上 推论：
实现 isConnectedBetween(nodeP, nodeQ) 就只需要 判断 nodeToGroupIdArray[nodeP] == nodeToGroupIdArray[nodeQ] 就行了。
原理：当且仅当 nodeP 与 nodeQ 存在于 同一个连通分量中 时，上述语句 才会 返回true。

处理策略：
#1 如果 两个触点 已经在同一个分量中 了，则：不对它们 做任何处理，直接跳到 下一个数对；
#2 如果 两个触点 不在同一个分量中，则：调用unionToSameGroup(nodeP, nodeQ) 来 把它们 添加到同一个分量中。
目标：把 两个触点 添加到 同一个分量中；
手段：把 两个触点 在nodeToGroupIdArray[]数组中的元素值 设置为 相同的值；
具体做法：遍历 整个nodeToGroupIdArray[]数组，把 所有满足条件的元素的值，都设置为 另一个值；

===
quick-find算法分析

#1 find()操作
操作的速度会非常快，因为它 只需要访问 nodeToGroupIdArray[]数组一次；

但是 quick-find算法 没办法处理 大规模的问题，因为 每一次unionToSameGroup()的操作都 会需要遍历 整个nodeToGroupIdArray[]数组。

命题：在 quick-find算法中，每次find()调用都 只会需要访问数组一次，但是 归并两个元素/分量的union()操作 访问数组的次数 在(N+3)到(2N+1)之间。
证明：略

推论：
假设我们 使用 quick-find算法 来 解决“动态连通性问题”，而且 最终 只得到了一个连通分量。
则：这会 最少需要 调用 (N - 1)次union()操作，也就是 最少 (N+3)(N-1) ~ N^2次 数组访问.
因此，结论 - 动态连通性问题 的quick-find解法 是 平方级别的。
推广 这个分析，可知：对于那些个 最终只会得到 少数连通分量的一般应用，quick-find算法的运行时长 是 平方级别的。

在计算机上 使用 倍率实验 很容易验证 这个猜想。

现代计算机 每秒钟能够执行 数亿甚至数十亿条指令，所以 当N比较小的时候，这个成本 不会太明显。
但是 某些现代应用 中，可能会需要处理 数百万 或者 数亿的触点 与 连接，这时候 quick-find算法 就明显 捉襟见肘了。