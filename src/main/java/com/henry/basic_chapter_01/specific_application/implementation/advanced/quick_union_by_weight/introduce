加权quick-union算法

所幸，我们只需要 简单地修改 quick-union算法 就能保证 像这样糟糕的情况(平方级别的运行时长)不再出现。
手段：与其 在union()中 随意地 将一颗树 连接到 另一棵树上（quick-union的做法），
我们现在 会记录每一个棵树的大小(treeSize) 并 总是把 较小的树 连接到 较大的树上。

这项改动 需要添加一个数组 和 一些代码 来 记录树中的结点数(treesNodeAmount)。
如图所示 （图略）

该算法 在 处理tinyUF.txt 时 所构造的森林 如图所示。
即使对于 这个较小的例子，该算法 所构造的树的高度 也远远小于 未加权的版本 所构造的树的高度。

===
加权quick-union算法的分析

如图 显示了 加权quick-union算法的最坏情况。
特征：其中 要被归并的树的大小 总是相等的。
这些树的结构 看起来 很复杂，但是它们都含有 2^n个节点。所以高度 都正好是 n。
另外，当 我们 归并两个 含有2^n个节点的树 时，我们 所得到的树 会含有 2^n+1个节点 - 由此 将 树的高度 增加到了 n+1.

推广：加权 quick-union算法 能够保证 对数级别的性能。
加权 quick-union算法的具体实现： WeightedQuickUnionTemplate
