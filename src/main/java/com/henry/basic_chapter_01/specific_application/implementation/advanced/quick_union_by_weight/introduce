加权quick-union算法

所幸，我们只需要 简单地修改 quick-union算法 就能保证 像这样糟糕的情况不再出现。
与其 在union()中 随意地 将一颗树 连接到 另一棵树上，我们现在 会记录每一个棵树的大小(treeSize) 并 总是把 较小的树 连接到 较大的树上。

这项改动 需要添加一个数组 和 一些代码 来 记录树中的结点数(treesNodeAmount)。如图所示

该算法在处理tinyUF.txt时 所构造的森林如图所示。
即使对于 这个较小的例子，该算法 所构造的树的高度 也远远小于 未加权的版本 所构造的树的高度。

甲醛quick-union算法的分析

如图显示了 加权quick-union算法的最坏情况。
特征：其中 要被归并的树的大小 总是相等的。
这些树的结构 看起来 很复杂，但是它们都含有 2^n个节点。所以高度都正好是n。
另外，当我们归并两个含有 2^n个节点的树时，我们得到的树 含有 2^n+1个节点 - 由此将树的高度 加到了 n+1.

推广：加权 quick-union算法 能够保证 对数级别的性能。
加权 quick-union算法的具体实现： WeightedQuickUnionTemplate
