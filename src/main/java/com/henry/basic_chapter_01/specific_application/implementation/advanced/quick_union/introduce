更好的算法：quick-union算法

我们要讨论的下一个算法的重点是 提供unionToSameGroup()的速度，它和 quick-find算法是互补的。
这个算法也基于相同的数据结构 nodeTo???Array[] - 但是我们会赋予这些值 不同的意义，因为要使用这个数组 来 定义更加复杂的结构。
具体来说，每个触点所对应的数组元素 都是 同一个分量中的另一个触点的名称（也可能是它自己）。
我们把这种指向关系 叫做 链接。

实现findGroupIdOf(node):
从给定的触点开始，由它链接到另一个触点，然后一直链接，直到到达了根触点（链接指向自己的触点）。
推论：当两个触点 能够最终达到同一个根触点时，说明 两个触点属于同一个连通分量。

为了保证这个过程的有效性，我们需要union(p, q)来保证这一点。
union()的实现：
#1 由p、q分别找到它们的根触点；
#2 将一个根触点 链接到 另一个，这样就能够把一个分量 给重命名为 另一个分量了。
算法的名称由此而来 - quick union(因为算法可以很快地完成 把两个触点合并到同一个分量中的操作)

代码实现：QuickUnionTemplate

===
quick-union图形化地理解：

quick-union算法的代码很简洁，但有些难以理解。
用 节点（带标签的圆圈） 来 表示触点， 用 一个节点到另一个节点的箭头 来 表示“链接”；
推论：由此可以得到 数据结构的图像表示；
应用：这样的图像表示 可以使 我们理解算法的操作变得 相对容易。

我们得到的结构是“树” —— 从技术上来讲，id[]数组 用父链接的形式 来 表示一片森林。
为了简化图表，我们常常会 省略链接的箭头（因为它们的指向都向上）和 树的根结点中指向自己的链接。

tinyUF.txt中的id[]数组 所对应的森林 如图所示。

无论我们从任何触点所对应的节点 开始跟随链接，最终 都会到达 含有该节点的 树的根结点。

可以使用归纳法 来 证明这个性质的正确性：
在数组被初始化之后，每个节点的链接 都会指向 它自己；
如果 在某次union()操作之前，这条性质成立，则 操作之后，他也必然成立。


因此，quick-union中的find()方法 能够返回 根结点所对应的 触点的名称（这样connected()才能够判定两个触点 是否在同一棵树中）。

这种表示方法 对于这个问题很实用，因为 当且仅当 两个触点 存在于 相同的分量之中 是 它们对应的节点 才会在同一个棵树中。

另外，构造书并不困难：quick-union中 union()的实现 只用了一条语句，就 将一个根结点 变为 另一个根结点的父结点。
从而归并了两棵树。

===
quick-union算法分析

quick-union算法 看起来 比 quick-find算法更快，因为它 不需要为没对输入 都遍历整个数组。
但具体快多少呢？

分析 quick-union算法的成本 比起 分析 quick-find算法的成本 更加困难，因为 这会 依赖于 输入的特点。
在最好的情况下， find()只需要访问数组一次 就能够得到 一个触点所在的分量 的标识符。
而在最坏的情况下，这回需要 2N+1次数组访问，如图所示的0触点 - 这个估计是较为保守的，
因为while循环中 经过编译的代码 对id[p]的第二次引用 一般都不会访问数组）。

由此 我们不难构造一个 最佳情况的输入 使得 解决动态连通性问题的用例 的运行时长 是线性级别的；
另一方面，我们也可以构造出 一个最坏情况的输入，这种情况下，它的运行时长 是平方级别的。

所幸我们不需要 面对分析quick-union算法的问题 - 我们也不会 仔细对比 quick-union算法 和 quick-find算法的性能。
因为我们会学习一种 比两者效率都要高很多 的算法。

目前，我们可以把 quick-union算法 视为 quick-find算法的一种改进版本，因为
它决解了 quick-find算法中 最主要的问题：union()操作 总是线性级别的。

对于一般的输入数据，这个变化显然会是一次改进。
但是 quick-union算法 仍旧存在问题，因为 我们不能保证 在所有情况下 它都能够比起 quick-find算法 快得多。
事实上， 对于某些输入 quick-union算法 不会比 quick-find算法更快。

定义：
一棵树的大小 是 它所包含的所有节点的总数量。
树中某个节点的深度 是 该节点到根结点的路径上 所有链接的数量。
树的高度 是 所有节点深度中的最大深度。

命题：
quick-union算法中的 find()方法 所访问数组的次数 为 1 加上给定触点 所对应的节点的深度的两倍。
union() 和 connected() 访问数组的次数 为 两次find()操作 - 如果union()中给定的两个触点 分别存在于 不同的树中，则还会需要+1.

同样，假设我们使用 quick-union算法 来 解决动态连通性问题，并最终只得到了一个分量。
根据以上命题，可以推论：算法的运行时长 在最坏情况下是平方级别的。

假设输入的整数对是有序的 0-1、0-2、0-3等，N-1对之后 我们的N个触点 将全部处于 相同的集合之中，
且由 quick-union算法得到的 树的高度为 N-1，其中0链接到1，2链接到3，如此下去。

再由命题G推论，对于整数对0-i，union()操作 所访问的数组的次数 为 2i+3(触点0的深度为i，触点i的深度为0).
因此，处理N对整数 所需要的 所有find()操作 所访问数组的总次数 为 2(1+2+...+N) ~ N^2.