quick-union 图形化地理解：

quick-union算法的代码 很简洁，但有些 难以理解。
手段：
    ① 用 节点（带标签的圆圈） 来 表示触点；
    ② 用 一个节点 指向 另一个节点的箭头 来 表示“链接”；
推论：由此 可以得到 数据结构的图像表示；
应用：这样的图像表示 可以使 我们理解算法的操作 变得 相对容易。

我们得到的结构 是 “树” —— 从技术上来讲，id[]数组 使用 父链接的形式 来 表示一片森林。
为了简化图表，我们常常会 省略链接的箭头（因为 它们的指向 都向上）和 树的根结点中 指向自己的链接。

tinyUF.txt中的id[]数组 所对应的森林 如图所示。

无论我们 从 任何触点所对应的节点 开始 跟随链接，最终 都会到达 “含有该节点的”树的根结点。

可以 使用归纳法 来 证明这个性质的正确性：
在 数组被初始化 之后，每个节点的链接 都会指向 它自己；
如果 在 某次union()操作 之前，这条性质成立，则 操作之后，他也 必然成立。

因此，quick-union中的find()方法 能够返回 根结点所对应的 触点的名称（这样connected() 才能够判定 两个触点 是否在同一棵树中）。

这种表示方法 对于这个问题 很实用，因为 当且仅当 两个触点 存在于 相同的分量之中 时，它们所对应的节点 才会在同一个棵树中。

另外，构造树并不困难：
quick-union中 union()的实现 只用了一条语句，就 将 一个根结点 变为 另一个根结点的父结点，
从而 归并了两棵树。