我们要学习的另一个栈的用例（它同时也是一个展示泛型应用的典型例子）就是 算术表达式求值；

比如
(1 + ((2 + 3) * (4 * 5))) 这个算术表达式。

计算过程如下：
#1 4 * 5 => 20;
#2 (2+3) => 5;
#3 1 + (5 * 20) = 101.

Java系统是怎么完成这个计算过程的呢？
我们也可以编写一个Java程序 来 解决这个问题。

程序 会接受一个输入字符串（表达式），并能够输出 表达式的结算结果。
为了简化问题，首先看一下 这份 明确的递归定义👇
算术表达式可能是：
#1 一个数；
#2 或者是 由一个左括号、一个算术表达式、一个运算符、另一个算术表达式 和右括号 所组成的表达式。

简单起见，这里定义的是 “未省略括号的算术表达式”，它明确地说明了 所有运算符的操作数👇
你可能更熟悉 省略了括号的算术表达式，比如 1 + 2 * 3 - 这种形式 省略了括号，进而使用Java中的优先级规则。
但这里我们不想要把问题复杂化。

为了突出重点，我们只支持 最常见的二元运算符 +、-、*、/，
以及 只接受一个参数的平方根运算符 sqrt。

我们也可以 轻易地支持 更多数量和种类地运算符 来  计算更多中 大家所熟悉的数学表达式，包括
三角函数、指针和对数函数。
但我们的重点在于， 怎么解析由括号、数字和运算符所组成的字符串，并按照 正确的顺序 来 完成各种初级算术运算的操作。

要怎么样才能得到 一个由字符串表示的算术表达式的值呢？
E.W.Dijkstra在20世纪60年代 发明了一个非常简单的算法👇
使用两个栈（一个英语保存运算符，另一个用于保存操作数）来 完成这个任务。

表达式由 括号、运算符和操作数组成。
我们根据以下4种情况 从左到右地 逐个地把这些实体送到栈中处理👇
#1 把操作数 压入 操作数栈中；
#2 把运算符 压入 运算符栈中；
#3 忽略左括号；
#4 在遇到右括号时，弹出一个运算符，再弹出所需数量的操作数，最后再把 运算符和操作数的计算结果 压入到 操作数栈中。

在处理完成 最后一个右括号 之后，操作数栈中 就只会有一个值 - 它就是算术表达式的值。

这种方法乍一看有些难以理解，但证明通过它能够得到正确的值 其实很简单👇
每当算法遇到一个 被括号包围、并 由一个运算符和两个操作数所组成的子表达式 时，
算法都会 把 元素安抚和操作数的计算结果 压入操作数栈。

从结果上看，就好像 在输入中使用这个值 代替了 该子表达式。
所以 使用这个值 代替子表达式 所得到的结果 和 原表达式的结果 必然相同。
我们可以反复应用 这个规律 来 得到一个最终值。

应用此等价规律的具体过程如下👇
(1+((2+3) * (4*5)))
(1+(5*(4*5)))
(1+ (5*20))
(1+100)
101

代码：
Evaluate类 是该算法的一个实现。
这段代码 是一个 简单的解释器 - 它能够 解释 给定字符串所表示的运算，并 给出运算的具体结果。