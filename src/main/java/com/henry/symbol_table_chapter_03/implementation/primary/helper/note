在符号表中， 命中 表示一次成功的查找；
未命中 表示一次失败的查找；

--- 使用链表 来 实现符号表 ---
初级实现手段#1：使用一个链表，链表中的节点 封装着 键值对；
特征：
    #1 链表中的节点没有按照键的大小排序；
    #2 在执行查找操作时，需要沿着链表的节点 向后顺序查找；

对 基于链表实现的符号表实现的 分析：👇
    get()方法所需的平均比较次数： ~N/2
    put()方法所需的比较次数：N
    未命中的查找 所需要的比较次数：N
    命中的查找 在最坏情况下所需要的比较次数：N

向空表中插入N个不同的键 所需要的比较次数为 ~N2/2.
简单来说，使用链表实现的符号表的各种操作 都是非常低效的。

--- 使用数组 来 实现符号表 ---
底层数据结构：一个Key数组、一个Value数组；
实现中，会维护Key数组中元素的有序性。从而实现 rank(key)的操作。

虽然使用有序数组能够快捷地实现 获取操作（以及其他的便捷操作），
但是 put()方法仍旧很慢（增长数量级为N） - 在随机键条件下，构造一个 基于有序数组的符号表 所需要访问数组的次数 是 数组长度N的平方级别。
对于大型应用，这是不能被接受的。

Recap：
符号表基础实现的两种方式：
#1 （单向）链表：能够高效插入；
#2 有序数组：能够快速查找（二分查找）；

next: combine 链表的插入效率 & 有序数组的查找效率 -> 二叉查找树（Binary Search Tree）