== 构造标准的BST ==
手段：以独立结点的形式, 把待插入的key依附到叶子节点上；
原理：BST中，对新插入的key的查询会结束于某个nil结点，然后“新添加的独立结点”会落在这个空结点的位置上。
特征：因此，BST会从上往下生长（aka 在叶子结点的位置不断向下延伸）；

== 构造2-3树 ==
手段：直接把待插入的key融合进叶子节点中，从而得到键数+1的结点；
原理：2-3树中，对新插入的key的查询会结束于某个叶子结点（为了保持2-3树的平衡性）；
特征：
    #1 如果查询结束于2-结点，则：融合待插入的key之后，会得到一个3-结点；
    #2 如果查询结束于3-结点，则：融合待插入的key之后，会得到一个4-结点(在2-3树中，它是不合法的)；
        目标：遵守2-3树的节点类型约束（仅存在2-结点与3-结点）与 维护2-3树的平衡性；
        手段：我们需要在保证平衡性的前提下，分解/转换4-结点为合法的结点[参考：invariant_while_transform_temp4node_02]；
        特征：这样的操作会从叶子节点开始，沿着查找路径从下往上进行。
    #3 （由#2所衍生）因此，2-3树的生长是从下往上的。

-- 使用同一组键 来 构造BST VS. 构造2-3树 的对比 --
    使用标准索引用例（某一特定顺序） 所构造产生的2-3树； - 是一个高度为2的2-3树
    使用同一组键，按照升序依次插入2-3树中 所产生的2-3树； - 是一个高度为2的2-3树
    使用同一组键，按照升序依次插入BST中 所产生的BST； - 是一个高度为9的最差查找树（一个链表）
评价：从平衡性上来看，2-3树的表现比起BST优秀很多

-- 对2-3树的性能分析 --
🐖 分析2-3树的性能时，我们会分析最差情况下的性能。
原因：因为我们没办法控制用例会按照什么样的顺序 向符号表中插入键，所以只有分析最坏的情况，才能够真正地提供性能保证。

结论：在一棵大小为N的2-3树中， 查找操作 & 插入操作 所访问的结点数量 不会超过lgN个。
推论：2-3树在最坏的情况下，其search 与 insert操作仍然会有较好的性能（对数级别）。

-- 2-3树的直观成就 --
相比较于BST，同一组键构造出的2-3树要矮胖地多(flat).
具体来说，一个 含有10亿个结点的一棵2-3树的高度 只会在19-30之间。
也就是说，我们只需要 最多访问30个结点 就能够 在10亿个键中进行任意的查找操作 & 插入操作。

