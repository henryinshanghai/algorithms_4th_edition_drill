基于以上分析，想要实现2-3树。我们可以
    为2-结点准备对应的类型；
    为3-结点准备对应的类型；
    写出结点之间变换所需要的代码...

特征：使用这样直白的表示方式 来 实现大多数的操作 并不方便 - 因为需要处理的情况实在太多。
具体来说：
    #1 维护两种不同的结点类型；
    #2 比较传入的键 与 结点中的每一个键；
    #3 把链接和其他信息 从一种结点 复制到 另一种结点；
    #4 把结点从一种数据类型 切换到另一种数据类型...
🐖 这些操作需要大量的代码来实现，而且这些代码的额外开销可能会是算法比起BST还要更慢。

--- 红黑二叉查找树 ---
直观上讲，二叉搜索树的结构 比起 2-3树的结构 要更简洁易懂。
所以 我们尝试 使用“添加了某些约束（123）”的二叉查找树 来 表示2-3树。
    BST的约束：有序性
    2-3树引入的新约束：平衡性

思路：使用标准的二叉查找树（完全由2-结点组成） 与 一些额外的信息（用于替换3-结点） 来 表示2-3树。

-- 使用“有颜色的链接” 来 等价替换2-3树中的3-结点，从而得到“红黑树”这种数据结构 --
手段：把树中的链接分成两种类别 👇
    1 红链接 - 用于把两个2-结点连接起来，形成一个3-结点；
    2 黑链接 - 用于表示2-3树中的普通链接。
具体来说，我们把2-3树中的3-结点 表示为 红黑树中一条左斜的红色链接（一个2-结点 是另一个2-结点的左子结点）。
副作用（好的）：使用以上对3-结点的表示方式，红黑树中的get()方法实现 与 标准二叉查找树中的get()方法的实现 会完全一样
作用：在红黑树中，我们可以使用结点的链接信息 来 表示它是不是一个3-结点。
应用：用于建立 2-3树 与 红黑树之间的等价关系。aka
    对于任意的2-3树，只要对结点进行转换，我们就能够马上派生出一棵 它所对应的二叉查找树。

-- 红黑树的另一种定义 --
如果一个二叉查找树 包含有红黑链接 并 满足如下约束 👇
    关于红链接的约束：#1 所有的红链接都是左链接；#2 没有任何一个结点同时与两条红链接相连接；
    关于平衡性的约束：#3 树是完美黑色平衡的 aka 从任意空链接到根结点的路径，所有路径上的黑链接数量相同。
则，称之为红黑树。

结论：满足以上约束的红黑树 与 相应的2-3树 是一一对应的。

-- 一一对应关系(correspondence) --
从红黑树 转换成为 2-3树的步骤：
    #1 把红黑树中所有的红链接画平；
    #2 把 由红链接所连接的两个结点 进行合并，就会得到一棵2-3树。

从2-3树 转换成为 红黑树的步骤：
    把3-结点画作为 由红链接连接的两个2-结点；

按照 ”2-3树中的3-结点 = 红黑树中由红色左链接连接的两个2-结点“的规则，可以推论：
    红黑树既是 二叉查找树，又是2-3树。

衍生结论：如果我们能够在保持一一对应关系的基础上，实现2-3树的插入算法。那么 我们就能够把两种算法的优点结合起来
    {二叉查找树中的高效的search()方法 & 2-3树中高效的平衡插入算法}

