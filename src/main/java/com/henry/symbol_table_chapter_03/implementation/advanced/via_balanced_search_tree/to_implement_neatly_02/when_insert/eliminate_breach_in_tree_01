-- 旋转操作（rotation） --
在插入新节点（总是以一个红链接来添加新节点）时，可能违反(breach)红黑树的三个约束
（红链接约束：#1 仅存在红色左链接； #2 不存在两个连续的红色链接; 平衡性约束：#3 完美黑色平衡）
针对于所有出现的breach, 我们会使用“旋转操作” 来 修复这个breach。

作用：用于改变红链接的指向。
应用：修复树中出现的红链接约束breach，使之成为一棵红黑树；
用法：
    方法接受 一条指向某个结点的链接作为参数。
    如果 结点的右链接是红色的，则：对结点（的右链接）执行左旋转操作；
        rotateLeft()会 对树进行必要的调整 & 返回一个 包含同一组键的子树并且左链接为红色的根结点（的链接）。
特征：从表现上来看，我们只是把 “用两个键中的较小者作为根结点” 改变为 “用较大者作为根结点”。

-- 在旋转操作完成后，重置 指向父节点的链接--
目标：使用旋转操作后得到的子树 来 替换原始的子树；
手段：
    #1 保持原始子树的（指向）根结点的链接的颜色；
        具体做法（h表示原始子树的根结点、x表示旋转后子树的根结点）：x.color = h.color;
    #2 替换原始子树；
        h = rotateLeft(h); // 使h指向 旋转后的子树的根结点 / 把旋转后的子树的根结点 赋值到 指向原始子树的变量上
特征：代码的简洁性。
应用：使得旋转操作 成为了 普通插入操作的一个简单补充。

结论：在插入新的键后，我们可以 使用旋转操作 来 帮助我们保证 2-3树 和 红黑树之间的一一对应关系。
原理：旋转操作 保持了 红黑树的两个重要性质 {有序性 & 完美平衡性}。因此在进行旋转操作时，不会breach这两个特性/约束。

-- next: 旋转操作 与红黑树的另外两个性质（约束）：#1 不存在红色的右链接； #2 不存在两条连续的红链接；

根据08的补充👇
-- 颜色转换（flipColor）--

作用：转换某个结点的两个红色子节点的颜色；
应用：消除向3-结点的中键插入新结点（红色）所引入的 “红色右链接breach”;
特征：
    #1 父节点的颜色也会同步变成红色；
    #2 是一个局部变换，不会影响到树的平衡性。
