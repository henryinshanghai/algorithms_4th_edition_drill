总的来说，二叉查找树的实现不算困难。
结论：当BST树的构造过程与随机模型接近时，它都能够在各种实际应用场景中，执行快速地插入与查找操作。

原理：BST树遵守特定的约束(结构约束+数值约束)，并因此展示出了一些特性 - 这些特性使得先前不可能的工作 变成了可能。
特征：
    #1 它支持高效的 rank(), select(), delete() & searchInRange()操作。
        🐖 很多程序员 钟爱 二叉查找树实现的符号表 的原因是：
    #2 二叉查找树所实现的符号表 在最坏情况下的恶劣性能 仍旧是无法被接受的。
        原理：二叉查找树实现的良好性能 依赖于 树中键的分布足够随机 来 消除树中的长路径。

=== 二叉查找树 VS. 快速排序 ===
对于快速排序来说，在具体实现的过程中，可以先把原始数组打乱；
对于二叉查找树实现的符号表，由于用例决定了 各种操作的先后顺序，因此 实际应用中可能会出现最坏的情况。
🐖 如果用例把所有的键 按照升序或逆序 插入符号表中，就会增加 最坏情况出现的可能性。
按照经验，如果没有明确的警告来避免这种行为（user training），那么 必然有些用例会尝试这么做。

以上，我们需要寻找更好的算法和数据结构。先有更好的数据结构，才可能找到基于它的更好的算法。

Next👇
更好的数据结构：平衡查找树(Balanced Search Tree)