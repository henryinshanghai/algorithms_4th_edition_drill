向2-3树中添加新键操作的分类：

-- #1 向单个2-结点中插入新键 --
向只有一个结点（且结点为2-结点）的红黑树中，插入新键。
🐖 为新键创建新节点时，结点总是以红链接依附到其父节点上。

如果新的键 小于已经存在的键，说明 新节点会是 已经存在的结点的左子结点。则：
    为新的键创建一个新的结点，然后使用红链接连接到 已经存在的结点即可 => 等价于一个3-结点
如果新的键 大于已经存在的键，说明 新节点会是 已经存在的结点的右子节点。则：
    新增红色结点后，会产生一个红色的右链接。这种情况 违反了红黑树的约束（不能存在红色的右链接）
    解决手段：对红色右链接的父节点进行左旋转，从而得到红色左链接（合法）；
    具体代码： root = rotateLeft(root);
    旋转操作完成后，我们就得到了一个 合法的红黑树（也可以等价为一棵2-3树）

最终得到的红黑树，都等价于一个3-结点。

-- #2 向单个3-结点中插入新键 --
过程：略 参考👇

-- #3 向红黑树底部的结点中插入一个新键 --
🐖 为了维持红黑树的有序性，新键会被插入到树的底部。

分类讨论：
① 新键的父节点是一个2-结点：
    则：#1中讨论的两种情形都适用👇
    如果新节点是原始2-结点的左子结点，则：直接得到一个3-结点；
    如果新结点 是原始2-结点的右子结点，则：产生一个红色的右链接，需要执行旋转操作，将之转换为红色的左链接。

② 新键的父节点是一个3-结点：
    则：可能会有如下3种情况（等价于临时的4-结点）👇
    Ⅰ 新结点是 3-结点的右子结点；
        则：会产生一个红色的右链接（违反红黑树约束），但树本身是平衡的。
        手段：把两条链接的颜色从红色变成黑色，从而得到一个 由三个2-结点组成、高度为2的平衡树（2-3树）。
    Ⅱ 新结点是 3-结点的左子结点；
        则：会产生连续的红链接（左 - 左 违反了红黑树约束）。
        手段：对上层的红色左链接的父节点进行右旋转，从而得到Ⅰ中的情形；
    Ⅲ 新结点是 3-结点的中子结点；
        则：会产生连续的红链接（左 - 右 违反了红黑树约束）
        手段：对下层红色右链接的父节点进行左旋转，从而得到Ⅱ的情形。
    总之，使用0次、1次与2次旋转操作 & 颜色变化的操作，就能够在插入结点后，得到合法的红黑树。

-- #4 颜色转换的操作 --
🐖 在转换结点的颜色时，除了把子节点的颜色(指向子节点的链接的颜色)从红变黑之外，需要同时也把父节点的颜色 由黑变红。
特征：颜色变换的操作 是一个局部操作，因此不会影响到整棵树的 "黑色平衡性".

-- 补充协议：根结点总是黑色的 --
从概念上说，如果得到了一个红色的根结点，我们会预期它是 3-结点的一部分 - 但实际上它已经是根结点了，不存在父节点，无法构成3-结点了。
解决手段：在每次插入操作后，手动把根结点的颜色变成黑色 - 🐖 这会使得树的黑链接高度+1

-- #5 旋转操作&颜色转换操作的副作用：把红链接沿着 树中的查找路径 向上传递 --
在2-3树中的插入算法中，我们需要分解4-结点 并 “将其中键插入到其父节点中” 来 完成插入新结点后2-3树的重新平衡。（直到约到了2-结点或者根结点）
#3-②中所描述的操作中，结果会 “使得中结点的颜色变红”。然后变红的结点 会像 插入的红节点一样被处理 - 继续把红链接转移到中结点上。
🐖 “中结点颜色变红” 等价于 “把中键插入到其父节点中”

目标：在红黑树中，实现2-3树的插入算法；
步骤：当在3-结点中插入新结点时👇
    ① 先创建一个临时的4-结点；
    ② 分解临时的4-结点，并把红链接 由中间键传递给它的父节点；
    ③ 重复以上过程，直到红链接遇到一个2-结点 或者 遇到根结点。

