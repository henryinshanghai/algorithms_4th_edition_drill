--- warmup round2: 在2-3树中删除最小键的算法 ---
最简单的情形：“删除最小键”发生在 树底部的3-结点中 - 在删除结点后，我们可以很容易地恢复红黑树的平衡。
更复杂的情形：从一个2-结点中删除一个键 - 因为在删除结点后，会留下一个空的链接（这会破坏树的平衡，并且很难处理）。
解决手段：通过一些技巧，避免“删除2-结点”的情形发生；
具体做法：在查询路径往下走的过程中，我们沿着左链接（因为最小的键必然在2-3树的最左侧）向下变换 来 确保当前结点不是2-结点；
特征：这个过程与 上一节中“2-3-4树中插入新键”的过程 有很大的相似性（确保当前结点不是4-结点）

分类讨论：
- 对根结点的分类讨论 -
#1 如果根结点的两个子节点都是2-结点，则：直接把这3个节点变成一个4-结点；
#2 如果根结点的两个子节点不全是2-结点，则：需要通过一些技巧/约定 来 保证根结点的左子结点（原因同上）不是2-结点
    手段：可以从它右侧的兄弟结点“借”一个键过来。

- 沿着左链接向下的过程中，通过一些手段，来使树满足“当前结点不是2-结点”的要求 👇 -
① 如果 当前结点的左子结点不是2-结点，则：满足要求；
② 如果 当前结点的左子结点 是2-结点 而它的亲兄弟结点不是2-结点，则：把 左节点的兄弟节点中的一个键 移动到 左节点中；
③ 如果 当前节点的左子结点 以及 它的兄弟结点 都是2-结点，则：
    左节点、父结点中的最小键、左节点最近的兄弟节点 合并成为一个 4-结点（这会是父结点变成2-结点或者3-结点）
作用：在完成上述变换后，最终就能够得到一个 “包含有最小键的”3-结点 或 4-结点。然后就能够便捷地执行删除操作了

🐖：在删除完成后，我们还需要 向上消除查询路径上所有的（由于避免2-结点而产生）临时4-结点。

