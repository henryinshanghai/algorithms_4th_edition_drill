-- 构造标准的BST --
分析：对新插入的结点的查询会结束于某个空结点，然后新添加的结点会落在此空结点出。
特征：因此，BST会从上往下生长；

-- 构造2-3树 --
分析：对新插入的结点的查询会结束于某个叶子结点（为了保持2-3树的平衡性），然后新添加的结点会使得叶子结点发生变化，
为了维持2-3树的特性，我们会进行4-结点的各种变换操作。
这样的操作会沿着查找路径从下往上进行。
因此，2-3树的生长是从下往上的。

-- 使用同一组键 来 构造BST VS. 构造2-3树 的对比 --
标准索引用例构造产生的2-3树； - 是一个高度为2的2-3树
同一组键，按照升序依次插入2-3树中 所产生的2-3树； - 是一个高度为2的2-3树
同一组键，按照升序依次插入BST中 所产生的BST； - 是一个高度为9的最差查找树（一个链表）

-- 对2-3树的性能分析 --
🐖 分析2-3树的性能时，我们会分析最差情况下的性能。
原因：因为我们没办法控制用例会按照什么样的顺序 向符号表中插入键，所以只有分析最坏的情况，才能够真正地提供性能保证。

结论：在一棵大小为N的2-3树中， 查找操作 & 插入操作 所访问的结点数量 不会超过lgN个。
推论：2-3树在最坏的情况下，其search 与 insert操作仍然会有较好的性能（对数级别）。

相比较于BST，同一组键构造出的2-3树要矮胖地多(flat).
具体来说，一个 含有10亿个结点的一棵2-3树的高度 只会在19-30之间。
也就是说，我们只需要 最多访问30个结点 就能够 在10亿个键中进行任意的查找操作 & 插入操作。

