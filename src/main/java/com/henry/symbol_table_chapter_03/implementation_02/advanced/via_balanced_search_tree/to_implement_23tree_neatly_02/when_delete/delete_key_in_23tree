参照 delete_minKey_in_23tree, 我们可以把删除算法分成如下三个阶段：
#1 保证向下查找过程中，不会出现2-结点；
#2
    ① 如果 与传入的键相等的键 出现在树的底部，则：直接删除它；
    ② 如果 与传入的键相等的键 不在树的底部，则：
        Ⅰ 把这个键 与 它的后继结点交换（参考二叉查找树的删除算法）。
        Ⅱ 从右子树中删除最小键，并使用删除后的子树作为新的右子树；
        Ⅲ 使用原始节点的左子树，作为新的左子树。
    分析：由于#1中的操作，因此当前结点必然不是一个2-结点。
    所以 原始的删除问题 等价于/被转化为 “在一个根结点不是2-结点的树中删除最小键”（参考BST的删除算法）
#3 删除结点后，向上回溯查找路径，并分解路径上余下的4-结点。

评论：这是我们所学习的第一种 能够同时实现高效的 #1 查找、#2 插入和 #3 删除操作的符号表实现。
