== 红黑树 是 ”添加了约束的BST“；==
具体约束(为什么有这些约束?)：
    红链接约束：#1 所有的红链接 都是 左链接；#2 没有任何一个结点 同时 与两条红链接 相连接；
    平衡性约束：#3 树是 完美黑色平衡的 aka 对于 从 任意空链接 到 根结点 的路径，所有路径上的黑链接数量 相同。

🐖 在红黑树中 插入新的key 时，我们会把 待插入的key 以”独立的红色结点“的形式 依附到叶子节点上。
原理：新添加的红色结点 不会破坏 红黑树的“平衡性约束”；
特征：新添加的红色节点 可能会破坏 红黑树的“红链接约束”；

目标：在插入key后，维护 红黑树所要满足的约束(从而保持 与23树的一一对应关系)；
-- 手段#1：旋转操作（rotation） --
作用：用于 改变 红链接的指向。
应用：修复树中出现的 “对红链接约束breach”，使之成为 一棵“合格的红黑树”；
具体实现：
    方法接受 一条指向某个结点的链接 作为参数。
    如果 结点的右链接 是红色的，则：对结点（的右链接）执行 左旋转操作；
        rotateLeft()会 ① 对树进行必要的调整 && ② 返回一个 包含同一组键的子树 并且 左链接为红色 的根结点（的链接）。
特征：从表现上来看，我们只是把 “用 两个键中的较小者 作为 根结点” 改变为 “用 较大者 作为 根结点”。

-- 辅助操作：在 旋转操作 完成后，重置 ”指向父节点的链接“--
目标：使用 旋转操作后 ”得到的子树“ 来 替换 ”原始的子树“；
手段：
    #1 保持 原始子树的（指向）根结点的 链接的颜色；
        具体做法（h 表示 原始子树的根结点、x 表示 旋转后子树的根结点）：x.color = h.color;
    #2 替换 原始子树；
        h = rotateLeft(h); // 使h指向 旋转后的子树的根结点[从左往右读] OR 把旋转后的子树的根结点 赋值到 指向原始子树的变量上[从右往左读]
特征：代码的简洁性。
应用：使得 旋转操作 成为了 普通插入操作 的一个简单补充。

结论：在 插入新的键 后，我们可以 使用旋转操作 来 帮助我们保证 ”2-3树 和 红黑树 之间的一一对应关系“。
原理：旋转操作 保持了 红黑树的两个重要性质 {① 数值的有序性 & ② 结构的完美平衡性}。所以在进行旋转操作时，不会breach这两个特性/约束。