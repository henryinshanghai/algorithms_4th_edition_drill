Efficient implementation of the delete operation is a challenge
in many symbol-table implementations, and red-black trees are no exception（红黑树也不例外）.

Industrial-strength implementations run to over 100 lines of code,
and text books generally describe the operation in terms of（以...方式） detailed case studies,
eschewing（刻意避开） full implementations.

Guibas and Sedgewick presented a delete implementation in [7],
but it is not fully specified（完全指定） and
depends on a call-by-reference approach
not commonly found in modern code（在现代的代码中并不常见）.

The most popular method in common use is based on a parent pointers（父指针） (see [6]),
which adds substantial overhead（很大的开销） and
does not reduce the number of cases to be handled.

结论：红黑树的删除操作的实现 是非常复杂的，一般的教科书中 都会刻意回避它。
Sedgewick的实现 使用了 不常见的技巧，而 常用的方法 又需要处理 太多的情形。

=== meat肉👇 ===

The code on the next page is a full implementation of delete() for LLRB 2-3 trees（用左倾红黑树实现的2-3树）.
It is based on the reverse of（逆过程）
the approach used for insert in top-down 2-3-4 trees（自上而下的2-3-4树的插入所使用的方式）:
we perform rotations and color flips
on the way down the search path（沿着搜索路径往下） to
ensure that the search does not end on a 2-node（本次搜索不会终止于一个2-结点）,
so that we can just delete the node at the bottom.（因此我们可以直接从底部删除结点）

结论：在左倾红黑树中删除结点的操作 是 基于 2-3-4树中插入操作 的逆操作。
在查询路径上，通过 旋转 与 颜色翻转 来 确保 查询不会终止于一个2-结点 ———— 这样我们就能直接删除 想要删除的结点。

We use the method fixUp() to
share the code for the color flip and rotations
following（紧跟着） the recursive calls in the insert() code.

我们使用 fixUp()方法 来 复用insert()方法中 紧跟着递归调用的、用于旋转 和 颜色翻转的代码。

With fixUp(), we can leave right leaning red links（右倾的红链接） and unbalanced 4-nodes（未平衡的4-结点）
along the search path（在查询路径中）, secure that
these conditions（有问题的状况） will be fixed
on the way up the tree（沿着树向上的过程中）.

有了fixUp()方法，我们就可以 暂时留下 查询路径中所存在的 右倾红链接 与 未平衡的4-结点，
因为我们可以确保 这些违法约束的情形 会在 沿着树向上的过程中 被修复。

(The approach is also effective 2-3-4 trees,
but requires an extra rotation
when the right node off the search path
is a 4-node.)
这种方式在 2-3-4树 中也是 有效的，但是 当搜索路径的右节点 是4-结点 时，会需要 额外的旋转操作。

As a warmup, consider the delete-the-minimum operation, where the goal is
to delete the bottom node on the left spine（删除左脊上的底部节点）
while maintaining balance（同时维护树的平衡性）.

作为热身，考虑 删除最小结点 的操作，其目标是 在维护 树的平衡性 的同时，删除 左脊上的底部结点

To do so, we maintain the invariant（不变性） that
the current node or its left child is red（当前节点 或者 它的左子结点为红色）.

为了 做到这一点，我们需要 在整个过程中 维护一个”不变性“：当前节点 或者 它的左子节点 需要是红色的

We can do so by
moving to the left（把xxx移动到左边）
unless the current node is red and its left child and left grandchild are both black.

通过 moving to the left??(除非 当前节点为红色 && 其左子节点与左孙节点 都是黑色的), 我们可以实现这个不变性

In that case（当前结点为红色&它的左子结点与左子结点的左子结点都是黑色）,
we can do a color flip, which restores the invariant（line44）
but may introduce successive reds on the right（在右侧引入连续的红链接）.
In that case（右侧出现连续的红链接）, we can correct the condition with two rotations and a color flip.

对于 除非的情形，我们可以 做一次颜色翻转，这样 我们就会重建”不变性“,
但却同时 可能会引入 右侧连续出现的红链接。
我们可以进一步地 使用两次旋转 与 一次颜色翻转 来 修正这个状况。

These operations are implemented in the moveRedLeft() method on the next page.
With moveRedLeft(), the recursive implementation of deleteMin() above is straightforward（直白的）.

上述操作 都实现在 moveRedLeft()方法中，有了这个方法后，上述 deleteMin()方法的 递归实现 就很直接了。

For general deletion, we also need moveRedRight(), which is similar, but simpler,
and we need to
rotate left-leaning red links to the right on the search path（在搜索路径上把左倾的红链接 旋转成为右倾）
to maintain the invariant.

对于一般的删除，我们还需要 moveRedRight(),它 与moveRedLeft()相似，但是 更简单。
我们需要 在搜索路径中 把左倾的红链接 旋转为 右倾 来 维持不变性。

If the node
to be deleted is an internal node（内部节点/非叶子节点）, we replace its key and value fields
with those in the minimum node in its right subtree（右子树中的最小节点）
and then delete the minimum in the right subtree (or
we could rearrange pointers to
use the node instead of copying fields).
如果 待删除的结点 是一个内部结点，我们就 使用其右子树中的最小节点 来 代替它的key与value，
然后删除 右子树中的最小节点（我们可以 重新安排指针 来 使用结点，而不需要 拷贝字段）

The full implementation of delete() that derives from this discussion（由此讨论所衍生的删除操作的实现）
is given on the facing page.
It uses one-third to one-quarter the amount of code
found in typical implementations.

基于上述讨论所得到的 delete()方法的完整实现 在下一页给出了。
它只用了 典型实现 的1/3 到 1/4的代码量。

It has been demonstrated before [2, 11, 13] that
maintaining a field in each node containing its height
can lead to code for delete that is similarly concise,
but that extra space is a high price to pay
in a practical implementation.

已有研究[2,11,13]表明，通过 在每个节点中维护存储其高度的字段(这是AVL树的做法)，同样可以实现简洁的删除操作代码，
但在实际实现中，这种额外的空间开销代价过高。

With LLRB trees, we can arrange for concise code
having a logarithmic performance guarantee
and using no extra space.

通过使用左倾红黑树（LLRB），我们既能保证代码简洁性，又能确保对数级的时间复杂度，同时无需额外的存储空间开销。