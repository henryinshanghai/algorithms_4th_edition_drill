Efficient implementation of the delete operation is a challenge
in many symbol-table implementations, and red-black trees are no exceptionï¼ˆçº¢é»‘æ ‘ä¹Ÿä¸ä¾‹å¤–ï¼‰.

Industrial-strength implementations run to over 100 lines of code,
and text books generally describe the operation in terms ofï¼ˆä»¥...æ–¹å¼ï¼‰ detailed case studies,
eschewingï¼ˆåˆ»æ„é¿å¼€ï¼‰ full implementations.

Guibas and Sedgewick presented a delete implementation in [7],
but it is not fully specifiedï¼ˆå®Œå…¨æŒ‡å®šï¼‰ and
depends on a call-by-reference approach
not commonly found in modern codeï¼ˆåœ¨ç°ä»£çš„ä»£ç ä¸­å¹¶ä¸å¸¸è§ï¼‰.

The most popular method in common use is based on a parent pointersï¼ˆçˆ¶æŒ‡é’ˆï¼‰ (see [6]),
which adds substantial overheadï¼ˆå¾ˆå¤§çš„å¼€é”€ï¼‰ and
does not reduce the number of cases to be handled.

ç»“è®ºï¼šçº¢é»‘æ ‘çš„åˆ é™¤æ“ä½œçš„å®ç° æ˜¯éå¸¸å¤æ‚çš„ï¼Œä¸€èˆ¬çš„æ•™ç§‘ä¹¦ä¸­ éƒ½ä¼šåˆ»æ„å›é¿å®ƒã€‚
Sedgewickçš„å®ç° ä½¿ç”¨äº† ä¸å¸¸è§çš„æŠ€å·§ï¼Œè€Œ å¸¸ç”¨çš„æ–¹æ³• åˆéœ€è¦å¤„ç† å¤ªå¤šçš„æƒ…å½¢ã€‚

=== meatè‚‰ğŸ‘‡ ===

The code on the next page is a full implementation of delete() for LLRB 2-3 treesï¼ˆç”¨å·¦å€¾çº¢é»‘æ ‘å®ç°çš„2-3æ ‘ï¼‰.
It is based on the reverse ofï¼ˆé€†è¿‡ç¨‹ï¼‰
the approach used for insert in top-down 2-3-4 treesï¼ˆè‡ªä¸Šè€Œä¸‹çš„2-3-4æ ‘çš„æ’å…¥æ‰€ä½¿ç”¨çš„æ–¹å¼ï¼‰:
we perform rotations and color flips
on the way down the search pathï¼ˆæ²¿ç€æœç´¢è·¯å¾„å¾€ä¸‹ï¼‰ to
ensure that the search does not end on a 2-nodeï¼ˆæœ¬æ¬¡æœç´¢ä¸ä¼šç»ˆæ­¢äºä¸€ä¸ª2-ç»“ç‚¹ï¼‰,
so that we can just delete the node at the bottom.ï¼ˆå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥ä»åº•éƒ¨åˆ é™¤ç»“ç‚¹ï¼‰

ç»“è®ºï¼šåœ¨å·¦å€¾çº¢é»‘æ ‘ä¸­åˆ é™¤ç»“ç‚¹çš„æ“ä½œ æ˜¯ åŸºäº 2-3-4æ ‘ä¸­æ’å…¥æ“ä½œ çš„é€†æ“ä½œã€‚
åœ¨æŸ¥è¯¢è·¯å¾„ä¸Šï¼Œé€šè¿‡ æ—‹è½¬ ä¸ é¢œè‰²ç¿»è½¬ æ¥ ç¡®ä¿ æŸ¥è¯¢ä¸ä¼šç»ˆæ­¢äºä¸€ä¸ª2-ç»“ç‚¹ â€”â€”â€”â€” è¿™æ ·æˆ‘ä»¬å°±èƒ½ç›´æ¥åˆ é™¤ æƒ³è¦åˆ é™¤çš„ç»“ç‚¹ã€‚

We use the method fixUp() to
share the code for the color flip and rotations
followingï¼ˆç´§è·Ÿç€ï¼‰ the recursive calls in the insert() code.

æˆ‘ä»¬ä½¿ç”¨ fixUp()æ–¹æ³• æ¥ å¤ç”¨insert()æ–¹æ³•ä¸­ ç´§è·Ÿç€é€’å½’è°ƒç”¨çš„ã€ç”¨äºæ—‹è½¬ å’Œ é¢œè‰²ç¿»è½¬çš„ä»£ç ã€‚

With fixUp(), we can leave right leaning red linksï¼ˆå³å€¾çš„çº¢é“¾æ¥ï¼‰ and unbalanced 4-nodesï¼ˆæœªå¹³è¡¡çš„4-ç»“ç‚¹ï¼‰
along the search pathï¼ˆåœ¨æŸ¥è¯¢è·¯å¾„ä¸­ï¼‰, secure that
these conditionsï¼ˆæœ‰é—®é¢˜çš„çŠ¶å†µï¼‰ will be fixed
on the way up the treeï¼ˆæ²¿ç€æ ‘å‘ä¸Šçš„è¿‡ç¨‹ä¸­ï¼‰.

æœ‰äº†fixUp()æ–¹æ³•ï¼Œæˆ‘ä»¬å°±å¯ä»¥ æš‚æ—¶ç•™ä¸‹ æŸ¥è¯¢è·¯å¾„ä¸­æ‰€å­˜åœ¨çš„ å³å€¾çº¢é“¾æ¥ ä¸ æœªå¹³è¡¡çš„4-ç»“ç‚¹ï¼Œ
å› ä¸ºæˆ‘ä»¬å¯ä»¥ç¡®ä¿ è¿™äº›è¿æ³•çº¦æŸçš„æƒ…å½¢ ä¼šåœ¨ æ²¿ç€æ ‘å‘ä¸Šçš„è¿‡ç¨‹ä¸­ è¢«ä¿®å¤ã€‚

(The approach is also effective 2-3-4 trees,
but requires an extra rotation
when the right node off the search path
is a 4-node.)
è¿™ç§æ–¹å¼åœ¨ 2-3-4æ ‘ ä¸­ä¹Ÿæ˜¯ æœ‰æ•ˆçš„ï¼Œä½†æ˜¯ å½“æœç´¢è·¯å¾„çš„å³èŠ‚ç‚¹ æ˜¯4-ç»“ç‚¹ æ—¶ï¼Œä¼šéœ€è¦ é¢å¤–çš„æ—‹è½¬æ“ä½œã€‚

As a warmup, consider the delete-the-minimum operation, where the goal is
to delete the bottom node on the left spineï¼ˆåˆ é™¤å·¦è„Šä¸Šçš„åº•éƒ¨èŠ‚ç‚¹ï¼‰
while maintaining balanceï¼ˆåŒæ—¶ç»´æŠ¤æ ‘çš„å¹³è¡¡æ€§ï¼‰.

ä½œä¸ºçƒ­èº«ï¼Œè€ƒè™‘ åˆ é™¤æœ€å°ç»“ç‚¹ çš„æ“ä½œï¼Œå…¶ç›®æ ‡æ˜¯ åœ¨ç»´æŠ¤ æ ‘çš„å¹³è¡¡æ€§ çš„åŒæ—¶ï¼Œåˆ é™¤ å·¦è„Šä¸Šçš„åº•éƒ¨ç»“ç‚¹

To do so, we maintain the invariantï¼ˆä¸å˜æ€§ï¼‰ that
the current node or its left child is redï¼ˆå½“å‰èŠ‚ç‚¹ æˆ–è€… å®ƒçš„å·¦å­ç»“ç‚¹ä¸ºçº¢è‰²ï¼‰.

ä¸ºäº† åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦ åœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­ ç»´æŠ¤ä¸€ä¸ªâ€ä¸å˜æ€§â€œï¼šå½“å‰èŠ‚ç‚¹ æˆ–è€… å®ƒçš„å·¦å­èŠ‚ç‚¹ éœ€è¦æ˜¯çº¢è‰²çš„

We can do so by
moving to the leftï¼ˆæŠŠxxxç§»åŠ¨åˆ°å·¦è¾¹ï¼‰
unless the current node is red and its left child and left grandchild are both black.

é€šè¿‡ moving to the left??(é™¤é å½“å‰èŠ‚ç‚¹ä¸ºçº¢è‰² && å…¶å·¦å­èŠ‚ç‚¹ä¸å·¦å­™èŠ‚ç‚¹ éƒ½æ˜¯é»‘è‰²çš„), æˆ‘ä»¬å¯ä»¥å®ç°è¿™ä¸ªä¸å˜æ€§

In that caseï¼ˆå½“å‰ç»“ç‚¹ä¸ºçº¢è‰²&å®ƒçš„å·¦å­ç»“ç‚¹ä¸å·¦å­ç»“ç‚¹çš„å·¦å­ç»“ç‚¹éƒ½æ˜¯é»‘è‰²ï¼‰,
we can do a color flip, which restores the invariantï¼ˆline44ï¼‰
but may introduce successive reds on the rightï¼ˆåœ¨å³ä¾§å¼•å…¥è¿ç»­çš„çº¢é“¾æ¥ï¼‰.
In that caseï¼ˆå³ä¾§å‡ºç°è¿ç»­çš„çº¢é“¾æ¥ï¼‰, we can correct the condition with two rotations and a color flip.

å¯¹äº é™¤éçš„æƒ…å½¢ï¼Œæˆ‘ä»¬å¯ä»¥ åšä¸€æ¬¡é¢œè‰²ç¿»è½¬ï¼Œè¿™æ · æˆ‘ä»¬å°±ä¼šé‡å»ºâ€ä¸å˜æ€§â€œ,
ä½†å´åŒæ—¶ å¯èƒ½ä¼šå¼•å…¥ å³ä¾§è¿ç»­å‡ºç°çš„çº¢é“¾æ¥ã€‚
æˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥åœ° ä½¿ç”¨ä¸¤æ¬¡æ—‹è½¬ ä¸ ä¸€æ¬¡é¢œè‰²ç¿»è½¬ æ¥ ä¿®æ­£è¿™ä¸ªçŠ¶å†µã€‚

These operations are implemented in the moveRedLeft() method on the next page.
With moveRedLeft(), the recursive implementation of deleteMin() above is straightforwardï¼ˆç›´ç™½çš„ï¼‰.

ä¸Šè¿°æ“ä½œ éƒ½å®ç°åœ¨ moveRedLeft()æ–¹æ³•ä¸­ï¼Œæœ‰äº†è¿™ä¸ªæ–¹æ³•åï¼Œä¸Šè¿° deleteMin()æ–¹æ³•çš„ é€’å½’å®ç° å°±å¾ˆç›´æ¥äº†ã€‚

For general deletion, we also need moveRedRight(), which is similar, but simpler,
and we need to
rotate left-leaning red links to the right on the search pathï¼ˆåœ¨æœç´¢è·¯å¾„ä¸ŠæŠŠå·¦å€¾çš„çº¢é“¾æ¥ æ—‹è½¬æˆä¸ºå³å€¾ï¼‰
to maintain the invariant.

å¯¹äºä¸€èˆ¬çš„åˆ é™¤ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ moveRedRight(),å®ƒ ä¸moveRedLeft()ç›¸ä¼¼ï¼Œä½†æ˜¯ æ›´ç®€å•ã€‚
æˆ‘ä»¬éœ€è¦ åœ¨æœç´¢è·¯å¾„ä¸­ æŠŠå·¦å€¾çš„çº¢é“¾æ¥ æ—‹è½¬ä¸º å³å€¾ æ¥ ç»´æŒä¸å˜æ€§ã€‚

If the node
to be deleted is an internal nodeï¼ˆå†…éƒ¨èŠ‚ç‚¹/éå¶å­èŠ‚ç‚¹ï¼‰, we replace its key and value fields
with those in the minimum node in its right subtreeï¼ˆå³å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼‰
and then delete the minimum in the right subtree (or
we could rearrange pointers to
use the node instead of copying fields).
å¦‚æœ å¾…åˆ é™¤çš„ç»“ç‚¹ æ˜¯ä¸€ä¸ªå†…éƒ¨ç»“ç‚¹ï¼Œæˆ‘ä»¬å°± ä½¿ç”¨å…¶å³å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ æ¥ ä»£æ›¿å®ƒçš„keyä¸valueï¼Œ
ç„¶ååˆ é™¤ å³å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼ˆæˆ‘ä»¬å¯ä»¥ é‡æ–°å®‰æ’æŒ‡é’ˆ æ¥ ä½¿ç”¨ç»“ç‚¹ï¼Œè€Œä¸éœ€è¦ æ‹·è´å­—æ®µï¼‰

The full implementation of delete() that derives from this discussionï¼ˆç”±æ­¤è®¨è®ºæ‰€è¡ç”Ÿçš„åˆ é™¤æ“ä½œçš„å®ç°ï¼‰
is given on the facing page.
It uses one-third to one-quarter the amount of code
found in typical implementations.

åŸºäºä¸Šè¿°è®¨è®ºæ‰€å¾—åˆ°çš„ delete()æ–¹æ³•çš„å®Œæ•´å®ç° åœ¨ä¸‹ä¸€é¡µç»™å‡ºäº†ã€‚
å®ƒåªç”¨äº† å…¸å‹å®ç° çš„1/3 åˆ° 1/4çš„ä»£ç é‡ã€‚

It has been demonstrated before [2, 11, 13] that
maintaining a field in each node containing its height
can lead to code for delete that is similarly concise,
but that extra space is a high price to pay
in a practical implementation.

å·²æœ‰ç ”ç©¶[2,11,13]è¡¨æ˜ï¼Œé€šè¿‡ åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸­ç»´æŠ¤å­˜å‚¨å…¶é«˜åº¦çš„å­—æ®µ(è¿™æ˜¯AVLæ ‘çš„åšæ³•)ï¼ŒåŒæ ·å¯ä»¥å®ç°ç®€æ´çš„åˆ é™¤æ“ä½œä»£ç ï¼Œ
ä½†åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™ç§é¢å¤–çš„ç©ºé—´å¼€é”€ä»£ä»·è¿‡é«˜ã€‚

With LLRB trees, we can arrange for concise code
having a logarithmic performance guarantee
and using no extra space.

é€šè¿‡ä½¿ç”¨å·¦å€¾çº¢é»‘æ ‘ï¼ˆLLRBï¼‰ï¼Œæˆ‘ä»¬æ—¢èƒ½ä¿è¯ä»£ç ç®€æ´æ€§ï¼Œåˆèƒ½ç¡®ä¿å¯¹æ•°çº§çš„æ—¶é—´å¤æ‚åº¦ï¼ŒåŒæ—¶æ— éœ€é¢å¤–çš„å­˜å‚¨ç©ºé—´å¼€é”€ã€‚