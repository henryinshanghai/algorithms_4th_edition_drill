总的来说，二叉查找树的实现 不算困难。
结论：当 BST树的构造过程 与 随机模型 接近时，它能够 在各种实际应用场景中，快速地执行 插入与查找操作。

原理：BST树 遵守 特定的约束(结构约束+数值约束)，并因此 展示出了 一些特性 - 这些特性 使得 先前不可能的工作 变得可能。
特征：
    #1 它 支持 高效的 rankingOf(key), selectKeyWhoseRankingIs(), delete() & searchInRange()操作。
        🐖 这就是 很多程序员 钟爱 由二叉查找树实现的符号表 的原因；
    #2 二叉查找树所实现的符号表 在最坏情况下的恶劣性能 仍旧是 无法被接受的。
        原理：二叉查找树实现的良好性能 依赖于 树中键的分布 足够随机 来 消除 树中的长路径。

=== 二叉查找树 VS. 快速排序 ===
对于 快速排序 来说，在 具体实现的过程 中，可以先 把原始数组打乱 来 得到 随机分布的元素序列；
但对于 使用二叉查找树实现的符号表，由于用例 决定了 各种操作的先后顺序，因此 实际应用中 可能会出现 最坏的情况。
🐖 如果用例 把 所有的键 按照升序或逆序 插入符号表中，就会增加 最坏情况 出现的可能性。
按照经验，如果没有 明确的警告 来 避免这种行为（user training），那么必然有些用例 会尝试 这么做。

以上，我们 需要寻找 更好的算法 和 数据结构。
先有 更好的数据结构，才可能 找到 基于它的 更好的算法。

Next👇
更好的数据结构：平衡查找树(Balanced Search Tree)