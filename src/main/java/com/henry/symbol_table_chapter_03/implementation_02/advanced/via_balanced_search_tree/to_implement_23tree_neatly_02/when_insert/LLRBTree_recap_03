结论：只要谨慎地使用 左旋转、右旋转以及颜色转换这三个操作，我们就能够保证 ”插入结点后的树“ 仍旧是一棵红黑树（2-3树）。

红黑树中 插入算法 的实现概要（overview）：
    #1 对于从 插入结点 到 根结点 的路径，我们从 插入结点 开始，沿着 路径上的每个结点 向上移动；
    #2 在 路过每个结点 时，完成如下👇操作（来消除breach，维持红黑树）：
        ① 如果 右子结点为红色，而 左子结点为黑色（说明出现了红色的右链接），则：对 红色链接的父节点 进行左旋转；
        ② 如果 左子结点为红色，而 左子结点本身的左子结点 也是红色的（说明出现了 连续的红链接），则：对 上层红色链接的父节点 进行右旋转；
        ③ 如果 左右子结点 都是红色，则：执行 颜色翻转。

向3-结点中 插入新结点后 的所有3种情形 & 情形转化图：
略

再回顾一下到底发生了什么？
== 我们的起点是：BST数据结构（有序性约束）；==
特征：
    #1 它兼具了数组的二分查找特性 & 链表的快速插入特性。
    #2 但是它没办法保证最坏情况下的性能（因为用例构造出的BST可能是不平衡的）

== 平衡的23树 ==
为了引入 平衡性约束，我们 扩展了BST，引入了 2-3树：
原理：普遍来说，2-3树 相比于 BST外观上会 更加地矮胖（因为单个节点中能够容纳更多的key），也因此 更容易维护 它的平衡性；

-- 23树的平衡性 --
为了维护 2-3树的平衡性约束，我们引入了
    #1 “临时4-结点”（3个key，4个分叉） &&
    #2 breakdown 临时4-结点的规则 - 分解4-结点时，它的中键 会被移动到 它的父结点 中；

== 与23树等价的红黑树 ==
使用 临时4-结点，理论上能够 在插入结点后，维护 2-3树的平衡性。
但是相关的代码实现 会非常繁琐（因为scenario太多）。
为了能够 更简单地实现 23树，我们引入了 红黑树：
    原理：红黑树使用 “2-结点 + 结点链接颜色（黑结点 + 红色的左子结点）” 来 等价表示 2-3树中的3-结点。

-- 红黑树的平衡性 --
平衡的红黑树 与 平衡的2-3树完全等价。
为了保持这种等价性，我们为红黑树(相比于BST)引入了”新的约束“：
    红链接约束：#1 不存在 红色的右链接； #2 不存在 连续的红链接;
    平衡性约束：#3 树是 完美黑色平衡的 aka 对于从 任意空链接 到 根结点 的路径，所有路径上的黑链接数量 相同;
为了能够 在 插入新结点 后，使 “插入结点后的树” 变回 “一棵平衡的红黑树”，我们引入了 如下的局部操作👇
    #1 左旋转; #2 右旋转; #3 颜色转换；
为了遵守 红黑树 与 2-3树的转换(transformation)规则，我们添加了一个 ”补充约束“：
    红黑树的根结点 总是黑色（否则：红色的根结点 在2-3树中不存在对应的模型）

以上 2023/06/21 0:33 AM
