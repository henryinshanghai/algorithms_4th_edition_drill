我们可以使用 第一章中介绍的调整数组大小的方法 来 保证散列表的使用率低于1/2.

首先，LinearProbingHashST 会需要一个新的构造函数，它能接受一个固定的容量作为参数；
然后，为 LinearProbingHashST 添加一个 resize()方法；

resize()方法代码 参考 LinearProbingHashST类；

resize()原理：
它会创建一个 新的指定大小的 LinearProbingHashST对象，并
使用它来保存原表中的 keys 与 values变量，
最后再把原表中的所有键 重新散列并插入到 新表中；

结果：这样我们可以使得 数组的长度加倍。

put()方法中的第一条语句 会调用resize()方法 来 确保散列表最多为半满状态。

这段代码所构造的散列表比起原始散列表 大一倍，因此α的值就会减半。

其他需要调整数组大小的场景：删除操作
原则：当符号表中的元素数量小于某个阈值后，减小符号表的大小。
手段：再delete()方法的末尾加上
if(pairAmount > 0 && pairAmount <= tableSize / 8)
    resize(tableSize / 2);

这样就能够保证 所使用的内存量 和 表中的键值对数量的比例 总是在一定的范围中。
动态调整数组大小可以保证 α不会大于 1/2.

===
拉链法 VS. 均摊分析

我们可以使用相同的方法 再拉链法中 来 保持较短的链表（平均长度在2-8之间）
在 resize()中将 LinearProbingHashST 替换成 SeparateChainingHashST,
当 pairAmount >= tableSize / 2时，调用 resize(2*M).

对于拉链法，如果你能够准确地 估计用例所需要的散列表大小N，则：调整数组的工作 不是必须的。
只需要 根据 查找耗时和(1+pairAmount/tableSize)成正比 来 选取一个适当的M即可。

而对于线性探测法，调整数组的大小是必须的，因为当用例所插入的 键值对的数量 超过预期时，
它的查找时间 不仅会变得非常长，而且还会 在散列表被填满的时候，进入无限循环。

===
均摊分析

从理论的角度来说，当我们 动态调整 数组的大小时，需要找出 均摊成本的上限，
因为我们直到 使散列表长度加倍的插入操作 会需要 进行大量的探测。

命题N
假设一张散列表 能够自己调整数组的大小，初始为空。
基于 均匀分布假设，执行任意顺序的t次查找、插入和删除操作 所需要的时间和t成正比，
所适用的内存量 总是在 表中键的总数 的常数因子范围内。

证明：
对于拉链法和线性探测法，结合命题K 和 命题M可知，这个命题知识 我们在第一章中第一次
讨论过的 数组增长的均摊分析 的简单重复而已。

如图所示，在 FrequencyCounter的例子中，累计平均的曲线 很好地显示出 散列表中调整数组大小地动态行为。
每次数组长度加倍后，累计平均值都会增加约1 - 因为表中每个键 都会需要重新计算散列值。
然后这个值慢慢下降，因为半数左右的键 被重新分配到了 表的不同位置。
随着表中键的增加，这个值的下降速度也在慢慢降低。