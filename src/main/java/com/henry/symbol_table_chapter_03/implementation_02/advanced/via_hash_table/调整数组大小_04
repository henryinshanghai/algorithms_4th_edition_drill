我们可以使用 第一章中介绍的调整数组大小的方法 来 保证散列表的使用率低于1/2.

首先，LinearProbingHashST 会需要一个 新的构造函数，它 能接受 一个固定的容量 作为参数；
然后，为 LinearProbingHashST 添加一个 resize()方法；

resize()方法代码 参考 LinearProbingHashST类；

resize()原理：
它会 ① 创建一个 新的指定大小的 LinearProbingHashST对象，并
② 使用它 来 保存原表中的 keys 与 values变量，
③ 最后再 把 原表中的所有键 重新散列 并 插入到 新表中；

结果：这样我们可以使得 数组的长度加倍。
应用：put()方法中的第一条语句 会 调用resize()方法 来 确保散列表最多为 半满状态。

这段代码所构造的散列表 比起 原始散列表 大一倍，因此α的值就会减半。

其他 需要调整数组大小 的场景：删除操作
原则：当 符号表中的元素数量 小于 某个阈值后，减小 符号表的大小。
手段：在delete()方法的末尾加上如下代码👇
    if(pairAmount > 0 && pairAmount <= tableSize / 8)
        resize(tableSize / 2);

这样就能够保证 所使用的内存量 和 表中的键值对数量的比例 总是在一定的范围中。
动态调整数组大小可以保证 α不会大于 1/2.

===
拉链法 VS. 均摊分析

我们可以使用 相同的方法 在”拉链法“中 来 保持较短的链表（平均长度在2-8之间）
在 resize()中，把 LinearProbingHashST 替换成 SeparateChainingHashST，
当 pairAmount >= tableSize / 2（符号表中键的数量增加到一定阈值）时，调用 resize(2*M).

对于拉链法，如果你 能够准确地估计 用例所需要的散列表大小N，则：调整数组的工作 不是必须的。
只需要 根据 查找耗时和(1+pairAmount/tableSize)成正比 来 选取一个适当的M即可。

而对于 线性探测法，调整数组的大小 是必须的，因为当 用例所插入的键值对的数量 超过预期时，
它的查找时间 不仅会变得非常长，而且还会 在散列表被填满的时候，进入无限循环。

===
均摊分析

从理论的角度来说，当我们 动态调整 数组的大小时，需要找出 均摊成本的上限，
因为我们知道 使散列表长度加倍的插入操作 会需要 进行大量的探测。

命题N
假设一张散列表 能够自己调整 数组的大小，初始为空。
基于 均匀分布假设，执行任意顺序的 t次查找、插入和删除操作 所需要的时间 和t成正比，
所使用的内存量 总是 在 ”表中键的总数“的常数因子范围 内。

证明：
对于 拉链法 和 线性探测法，结合命题K 和 命题M可知，这个命题只是
”我们在第一章中第一次所讨论过的“ 数组增长的均摊分析 的简单重复 而已。

如图所示，在 FrequencyCounter的例子中，累计平均的曲线 很好地显示出 散列表中 调整数组大小 的动态行为。
每次 数组长度加倍 后，累计平均值 都会增加约1 - 因为 表中每个键 都会需要 重新计算散列值。
然后这个值 慢慢下降，因为 半数左右的键 被重新分配到了 表的不同位置。
随着表中 键的增加，这个值的下降速度 也在慢慢降低。