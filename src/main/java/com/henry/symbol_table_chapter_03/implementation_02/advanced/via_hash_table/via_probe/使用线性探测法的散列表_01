实现散列表的另一种方式 就是 使用大小为M的数组 来 保存 N个键值对，其中 M > N.
原理：我们需要依靠 数组中的空位 来 解决键的碰撞冲突。

所有基于这种策略的方法 都被统称为 “开放地址散列表”。

开发地址散列表中，最简单的方法 叫做 “线性探测法”：
当碰撞发生时（当前键的散列值 已经被另外一个键占用了），我们 直接检查散列表中的下一个位置（aka 将索引值+1）.
这样的线性探测 可能产生三种结果：
#1 命中 - 该位置的键 与 待查找的键 相同；
#2 未命中 - 该位置还没有任何的键；
#3 继续查找 - 该位置上的键 与 待查找的键 不相同。

步骤：
#1 我们使用散列函数 来 找到 键在数组中的索引；
#2 然后检查 其中的键 与 待查找的键 是不是相同；
    如果不同，则：继续查找（索引+1，到达数组末尾时再折回数组开头），直到 找到键 或者 遇到空元素；
特征：只要散列值对应的位置上存在有值，就 探测/查看下一个位置是否为空（直到找到某个位置上的元素为空），并添加元素

术语：我们把 检查一个数组位置是否含有 被查找的键 的操作 叫做 “探测”。
在这里，它等价于 “比较操作”。而有些探测，实际上是在测试键是否为空。

开放地址类别的散列表的核心思想是：
与其把内存用作链表，不如将它们作为 在散列表中的空元素。
原理：使用这些空元素 可以作为 查找结束的标志。

在 LinearProbingHashST中 可以看到，使用这种思想 来 实现符号表的API是非常容易的。
在实现中，我们使用了并行数组 - 一个用来保存键，一个用来保存值。