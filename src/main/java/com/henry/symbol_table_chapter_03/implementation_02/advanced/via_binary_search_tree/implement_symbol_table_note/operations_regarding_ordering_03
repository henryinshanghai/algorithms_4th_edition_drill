--- 对二叉查找树中 与有序性相关的操作 的性能分析 ---
概念：树的高度 aka 树中任意结点的最大深度。
结论：在一棵二叉查找树中，所有操作（除了“范围查找”，它的成本 与合法键的数量成正比） 在最坏情况下 执行所需要的时间 与 树的高度 成正比；
证明：
    #1 树的所有操作 都是 沿着树的某一条(或者两条)路径 进行的 &&
    #2 根据定义/概念，树中 路径的长度 不可能大于 树的高度。

目标：计算 最坏情况下，树的高度 到底有多高？
这个证明 比较困难，但以下 罗列出了 一些结论👇
结论#1 使用随机键 所构造出的二叉查找树，其平均高度 是 树中结点数量N 的对数级别（J. Robson）；
结论#2 对于 足够大的N，BST树的平均高度 趋近于 2.99lgN;

综上，我们可以认为 使用随机键 所构造出的BST中，所有路径的长度 都小于 3lgN.
衍生问题：如果 用来构造BST的键 不是随机的呢？那还会有 这种对树的高度的保证吗？
答：我们可以 绕开这个问题（via 使用 新的逻辑数据结构——“平衡二叉查找树”）
    🐖 它 能够保证 无论键的插入顺序如何（随机模型 或者 其他），树的高度 都总会是 总键数的对数。

