命题K：
在一张含有M条链表 和 N个键的散列表中，（在假设J成立的前提下）任意一条链表中的键的数量
均在N/M的常数因子范围内的概率无限趋近于1.

简略的证明：
有了假设J，这个问题就变成了一个 经典的概率论问题。
在这里我们为 有一些概率论基础知识的读者 给出一个简要的证明。

由 二项分布 可知，一条 给定链表中刚好含有k个键的概率为：
（...）（...）（...）
因为我们实际上是从N个键中取出了其中的k个。
这k个键 被散列到 某一个链表的概率均为 1/M, 而剩下的(N-k)个键 不被散列到 给定的链表中的概率均为 (1-1/M).
现在令α=N/M, 这个公式可以写作：
(...)(...)(...)

对于比较小的α，经典的泊松分布可以非常近似地表示它：
()

由此可得，一条链表中含有超过 tα个键的概率 不会超过(αe/t)^te^-α。
对于实际应用来说，这个数字非常小。

比如，如果平均链表长度为10，那么 一个键的散列值落在一条长度超过20的链表中 的概率
不会超过 0.0084(简化的泊松公式计算结果)；
如果平均链表长度为20，那么 一个键的散列值 落在 一条长度超过40的链表中 的概率
不会超过 0.000 0016.
这个结果并不会保证每条链表都很短，但是我们可以知道
当α一定时，最长链表的平均增长速度为 logN/loglogN.

===
这段数学分析非常有力，但需要注意的是 它完全依赖于假设J。如果散列函数 不是 均匀与独立的，
那么 查找和插入的成本 就可能和N成正比（也就是和顺序查找类似）。

假设J比起 我们见过的其他 和概率有关的算法中相应的假设 都更有效，但是也更加难以验证。

在计算散列值时，我们假设每个键都有均等的机会 被散列到 M个索引中的任意一个（无论键由多复杂）。
我们没法使用实验来验证 所有可能的数据类型，所以我们会进行更加复杂的实验 -
在实际应用中可能出现的一组键中，随机取样 来 进行验证，然后统计结果并分析。

好消息是 我们在测试中，仍然可以使用这个算法 来 验证假设J 以及 由它所得出的数学推论。