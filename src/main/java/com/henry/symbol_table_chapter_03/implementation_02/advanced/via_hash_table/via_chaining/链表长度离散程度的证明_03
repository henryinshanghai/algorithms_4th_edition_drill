命题K：
在一张含有 M条链表 和 N个键的散列表中，（在假设J成立的前提下）任意一条链表中的键的数量
均 在N/M的常数因子范围内的概率 无限趋近于1.

简略的证明：
有了 假设J，这个问题 就变成了一个 经典的概率论问题。
在这里我们 为 有一些概率论基础知识的读者 给出一个 简要的证明。

由 二项分布 可知，一条给定链表中”刚好含有k个键“ 的概率为：
（...）（...）（...）
因为我们实际上是 从N个键中 取出了 其中的k个。
这k个键 ”被散列到某一个链表“的概率 均为 1/M,
而 剩下的(N-k)个键 ”不被散列到 给定的链表中“的概率 均为 (1-1/M).
现在 令α=N/M, 这个公式 可以写作：
(...)(...)(...)

对于 比较小的α，经典的泊松分布 可以非常近似地表示它：
()

由此可得，一条链表中含有 超过tα个键的概率 不会超过 (αe/t)^te^-α。
对于 实际应用 来说，这个数字 非常小。

比如，如果 平均链表长度 为10，那么 一个键的散列值 落在一条 长度超过20的链表中 的概率
不会超过 0.0084(简化的泊松公式计算结果)；
如果 平均链表长度 为20，那么 一个键的散列值 落在 一条长度超过40的链表中 的概率
不会超过 0.000 0016.
这个结果 并不会保证 每条链表都很短，但是我们可以知道
当 α一定 时，最长链表的平均增长速度为 logN/loglogN.

===
这段数学分析 非常有力，但需要注意的是 它完全依赖于 假设J。
如果散列函数 不是 均匀与独立的，那么 查找和插入的成本 就可能和N成正比（也就是和顺序查找类似）。

假设J比起 我们见过的其他 和概率有关的算法中相应的假设 都更有效，但是也更加难以验证。

在 计算散列值 时，我们假设 每个键都有均等的机会 被散列到 M个索引中的任意一个（无论键由多复杂）。
我们 没法使用实验来验证 所有可能的数据类型，所以我们会 进行更加复杂的实验👇
在实际应用中 可能出现的一组键中，随机取样 来 进行验证，然后 统计结果 并分析。

好消息是 我们在测试中，仍然可以使用这个算法 来 验证假设J 以及 由它所得出的数学推论。