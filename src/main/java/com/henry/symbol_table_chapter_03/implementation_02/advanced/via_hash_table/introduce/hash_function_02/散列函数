散列函数

我们面对的第一个问题就是散列函数的计算，这个过程会将键转化为数组的索引。
如果我们有一个 能够保存M个键值对的数组，那么 我们就需要一个 能够将任意键 转化成为 该数组范围内的索引([0, M-1]范围内的整数)的散列函数。

我们要找的散列函数 应该是易于计算 并且 能够均匀分布 所有的键。
即 对于任意键， 0 到 M-1之间的每个整数 都会有 相等的可能性 与之对应（与键无关）。

这个要求似乎有些难以理解。那么要理解散列， 就要 首先 仔细思考 如何去实现 这样一个函数。

散列函数 和 键的类型有关。
严格来说，对于 每一种类型的键，我们都需要一个  与之对应的散列函数。

如果键是一个数，比如社会保险号，我们就可以 直接使用这个数；
如果键是一个字符串，比如一个人的名字，我们就需要 把这个字符串 转化成为 一个数；
如果键 包含有 多个部分，比如邮件地址，我们需要 使用某种方法 把这些部分结合起来。

对于许多常见类型的键，我们可以利用 Java提供的默认实现。

我们会 简要讨论 多种数据类型的 散列函数。
你应该看看它们 是如何实现的， 因为你也需要 为自定义的类型 实现散列函数。

==
典型的例子

假设在我们的应用中，键是美国的社会保险号。
一个社会保险号 包含有 9位数字 并且 被分为3个部分，比如 123-456-789.
第一组数字 表示 该号码的签发地区（比如035表示 罗德岛州， 214表示马里兰州）
另外两组数字 表示个人身份。

社会保险号 共有10亿个，但假设 我们的应用程序只需要处理几百个，这样 我们可以使用一个 大小M=1000的散列表。

散列表的一种实现方式是 使用 键中的三个数字：用第三组中的3个数字 看起来 比起 使用第一组中的三个数字更好（因为用户不太可能均匀分布在各个地区）。
但是下面会讲到，更好的方法 是 用所有的9个数字 得到一个整数，然后 再考虑 整数的散列函数。


==
正整数

对整数散列最常用的方法 是 除留余数法。
我们选择 大小为素数M的数组，对于任意 正整数k，计算k除以M的余数。

这个函数的计算非常容易（在Java中的方式是 k%M）, 并且它能够把键有效地散布在0到M-1的范围之内。
如果M不是素数，我们可能 没办法利用键中所包含的所有信息 - 这可能导致 我们无法均匀地散布 散列值。

比如 如果键是10进制数，而选择的M是10^k, 那么我们就只能利用键的后k位，这样可能会产生一些问题。
具体的例子：键是电话号码的区号，且M=100.
由于历史原因，美国大部分区号的中间位 都是0或者1.
所以这种方式（M=100） 会把大量的键 散列为  小于20的索引；
而如果使用素数97的话，散列值的分布 会更好一些（如果素数离100更远则效果更好）

与此类似，互联网中 所使用的IP地址也不是随机的，所以
如果我们想使用 除留余数法 来 将其散列的话，就会 需要使用素数大小（不是2的幂）的数组；

==
浮点数
如果键是0到1之间的实数，我们可以 将它乘以M并四舍五入 来 得到一个0到M-1之间的索引值。
尽管这个方法很容易理解，但它是有缺陷的。
因为这种情况下 键的高位所起的作用更大，最低位 对散列的结果没有影响。
修正这个问题的办法是 将键表示为二进制数，然后再 使用除留余数法； - 🐖 这就是Java所选择的处理方式

==
字符串

除留余数法 也可以处理较长的键，比如字符串 - 我们只需要把它当作大整数就可以了。
比如，右侧的代码就能够 使用 除留余数法 来 计算String s的散列值：

int hash = 0;
for (int i = 0; i < s.length(); i++)
    hash = (R * hash + s.charAt(i)) % M;

Java的charAt()函数 能够返回一个 char值，也就是 一个非负的16位整数。
如果R比起任何字符的值 都大的话，则：这种计算 相当于 把字符串当作为 一个N位的R进制数，然后把它除以M并取余。
一种叫做 Horner方法的经典算法 使用N次乘方、假发和区域 来 计算一个字符串的散列值。
只要R足够小，不会造成溢出，那么 hash的最终结果就会落在0到M-1之间。
使用一个较小的素数，比如31，就能够保证字符串中的所有字符 都能够发挥作用。
Java中String的默认实现 使用了一个类似的方法。

==
组合键

如果键的类型包含有多个整型变量，则：我们可以像String类型一样 来 把它们混合起来。
例如，假设被查找的键 其类型是Date，其中包含有几个整型的域：day（数字表示的日），month（两个数字所表示的月）
与year（4个数字所表示的年）。我们可以像这样计算它的散列值：
int hash = (((day * R + month) % M) * R + year ) % M

只要R足够小（不会造成溢出），我们就能够得到一个 0到M-1之间的散列值。
在这种情况下 我们可以通过选择一个适当的M值（比如31）， 来 省去括号内的%M计算。
和字符串的散列算法一样，这个方法 也能够 处理任意多 整型变量的类型。


==
Java的约定

每种数据类型 都需要 其所对应的散列函数，于是 Java 令 所有的数据类型 都继承了一个
能够返回一个32比特整数的 hashCode()方法。
每种数据类型的hashCode()方法的返回值 都必须与equals()方法 保持一致；
也就是说，如果 a.equals(b)返回true，那么 a.hashCode()的返回值 必然与 b.hashCode()的返回值相同。
反之，如果两个对象的hashCode() 方法的返回值不同，则：两个对象是不同的；
而如果两个对象的hashCode() 方法的返回值是相同的，则：我们需要进一步使用 equals()方法 来 判断两个对象是否相同。

也就是说 hashCode()方法的返回值相同 是 两个对象相同的 必要不充分条件。

请注意，如果你想要 为自己定义的数据类型 来 定义散列函数，则：你需要同时重写 hashCode() 与 equals()方法。
默认散列函数 会返回 对象的内存地址，但是只有极少的情况你真正会需要它。

Java为许多常用的数据类型 重写了 hashCode()方法 - 比如String, Integer, Double, File 和 URL；

==
将hashCode()的返回值 转化成为 一个数组索引

我们真正需要的是一个数组的索引 而不是一个32位的整数。
因此 我们在实现中会 将默认的hashCode()方法 和 除留余数法 结合起来，得到一个0到M-1之间的整数。
代码如下：
private int hash(Key x)
{
    return (x.hashCode() % 0x7fffffff) % M;
}

这段代码会将符号位屏蔽（也就是 把一个32位整数 变成 一个31位非负整数），然后使用除留余数法 计算 它除以M的余数。
在使用这样的代码时，我们一般会 将数组的大小M取为素数 以便充分利用 原始散列值的所有位上的数字。
注意：为了避免混乱，我们在例子中 不会使用这种计算方法，而是使用简化后的散列值 作为替代。

==
自定义的hashCode()方法

散列表的用例 希望使用hashCode()方法 能够 把键平均地散布为 所有可能的32位整数。
也就是说，对于任意对象x，你可以调用 x.hashCode() 来 预期有均等的机会得到 2^32个不同整数中的任意一个32位整数值。

Java中的String、Integer、Double、File和URL对象的hashCode()方法 都能够实现这一点。

而对于自定义的数据类型，你就需要自己实现这一点。
Date类型的实践是一种可行的方案：使用实例变量的整数值 与 除留余数法 来 得到散列值。

在java中，所有的数据类型 都继承了 hashCode()方法。
因此还有一个更加简单的做法：
把 对象的每个变量的hashCode()返回值 都转化为32位整数， 并 计算得到散列值。
示例： Transaction类；

对于原始数据类型的对象，可以将其转化为 对应的数据类型，然后再调用 hashCode()方法。
和之前一样，系数的具体值（在这里是31）并不是很重要。

==
软缓存

如果散列值的计算很耗时的话，那么 我们或许可以 将每个键的散列值缓存起来。
也就是 在每个键中使用一个hash变量 来 保存 它的hashCode的返回值。

第一次调用hashCode()方法时，我们会需要计算出 对象的散列值；
但是之后对hashCode()方法的调用会直接返回 hash变量的值。

Java的String对象的hashCode()方法 就是用了这种方式 来 减少计算量。

总的来说，为一个数据类型所实现的优秀的散列方法 需要满足以下三个条件：
#1 一致性 - 等价的键 必须要能够产生 相等的散列值；
#2 高效性 - 计算简便；
#3 均匀性 - 均匀地散列所有的键。

设计同时满足这三个条件的散列函数 是专家的事情。
有了各种内置函数，Java程序员 在使用散列时，只需要调用 hashCode()方法即可（我们没有理由不信任它们）

但是，在有性能要求的时候，应该谨慎地使用散列，因为 糟糕的散列函数经常是 性能问题的罪魁祸首：
程序可以工作，但是比起预想的慢得多。

保证均匀性的最好办法 也许就是 保证键的每一位 都在散列值的计算中起到了作用。
实现散列函数最常见的错误也许就是 忽略了高位。

无论散列函数的实现是什么，当性能很重要时，你应该测试 所使用的所有散列函数。
计算散列函数 和 比较两个键，哪个耗时更多？
你的散列函数能够将一组键 均匀地散布到 0到M-1之间吗？
使用简单的实现 来 测试这些问题 能够预防未来的悲剧。

如图所示，对于《双城记》，我们的hash()方法 在使用了 Java的String类型的hashCode()方法后，得到了一个合理的分布。
图
《双城记》中每个单词的散列值的出现频率（10679个键/单词，M=97）

这些讨论的背后是我们在使用散列时 所作出的一个重要假设。
这个假设 是一个 我们实际上无法达到的理想模型，但是 它是我们实现散列函数时的 指导思想。