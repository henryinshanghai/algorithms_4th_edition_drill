练习：在我们的标准索引测试用例中 插入键P，并画出 插入过程中的每次变换（颜色转换或者旋转）后的红黑树；

-- 红黑树的最坏情况 --
构造出一棵 大小为N的最差红黑树 - 树中，从根节点到几乎所有空链接的 路径长度 都是 2lgN;

-- 自顶向下的2-3-4树 --
尝试 使用平衡2-3-4树作为底层数据结构 来 实现符号表的基本API。
手段：在 树的表示 中，使用红黑链接 并 实现正文所描述的插入算法 👇
    #1 在 沿着查找路径向下的过程 中，分解4-结点，并 进行颜色转换；
    #2 在 沿着查找路径向上的过程 中，将4-结点配平。

-- 自顶向下一遍完成 --
要求(特征)：在 沿着查找路径向下的过程 中，分解 并 平衡 4-结点（以及3-结点）。
作用：这样就能够 在树底 直接插入新键 就可以了。

-- 自底向上的2-3-4树 --
尝试 使用平衡2-3-4树 作为 底层数据结构 来 实现 符号表的基本API。
手段：在 树的表示 中，使用红黑链接 并 使用和算法3.4相同的递归方式 来 实现 自底向上的插入。
特征：插入方法 应该只需要 去分解“查找路径底部的4-结点”（如果存在的话）

-- 缓存 --
修改RedBlackBST的实现：把 最近访问的结点Node 保存在一个变量中。
作用：get()或者put()方法，当 再次访问 同一个键的 时候，就只会需要 常数时间了。

因为 默认的contains()的实现 中 调用了get()，所以 CountWordFrequencyViaSymbolTable 的内循环中，会 把同一个键 查找两三遍：
if(!symbolTable.contains(word)) symbolTable.put(word, 1);
else                            symbolTable.put(word, symbolTable.get(word) + 1);

为了能够提高 这样的用例代码 的效率，我们可以使用 一种叫做“缓存”的技术手段 ———— 把“访问最频繁的键”的位置 保存到一个变量中。
修改 SequentialSearchST 与 BinarySearchST 来 实现这个idea。

-- 旋转的基础定理 --
请证明，使用一系列左旋转 或者 右旋转 就可以 将 一棵二叉查找树tree01 转换为 “由同一组键生成的”其他任意一棵二叉查找树tree02.

-- 其他的常见API --
#1 删除 最小键；
#2 删除 最大键；
#3 删除操作；
