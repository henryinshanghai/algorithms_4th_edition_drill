#1 the left-leaning versions of 2-3 trees and top-down 2-3-4 trees
differ in the position of one line of code.

#2 all of the red-black tree algorithms that have been proposed are characterized by
a worst case search time bounded by a small constant multiple of lg N
in a tree of N keys,
and the behavior observed in practice is typically that same multiple
faster than the worst-case bound, close to the optimal lg N nodes
examined that would be observed in a perfectly balanced tree.

#3 The starting point for this paper is the balanced tree data structure that
were developed in the 1960s and 1970s, which provide a guaranteed worst-case running time that
is proportional to(ä¸...æˆæ­£æ¯”) log N for both operations.

#4 These algorithms are based on modifying the elementary binary search tree(BST) data structure
to guarantee that the length of every path to an external nodeï¼ˆå¤–éƒ¨ç»“ç‚¹ aka å¶å­ç»“ç‚¹ï¼‰
is proportional to logN.

#5 Examples of such algorithms are 2-3 trees, 2-3-4 trees, AVL trees, and B trees.

#6 This paper is largely self-containedï¼ˆå®Œå¤‡çš„ï¼‰ for people familiar with balanced-tree algorithms;
other can find basic definitions and examples in a standard textbook such as [6], [9], [13].

#7 In 7, Guibas and Sedgewick showed that all of these algorithms can be implemented with
red-black trees, where each link in a BST is assigned a color(red or black) that
can be used to control the balance, // ä½¿ç”¨é“¾æ¥çš„é¢œè‰² æ¥ æ§åˆ¶æ ‘çš„å¹³è¡¡
and that this framework can simplify the implementation of the various algorithms.
ğŸ– çº¢é»‘æ ‘æ˜¯ä¸€ç§ æ·»åŠ äº†çº¦æŸï¼ˆå¹³è¡¡æ€§çº¦æŸç­‰ï¼‰çš„æ ‡å‡†äºŒå‰æŸ¥æ‰¾æ ‘ğŸ‘†

In particular, the paper describes a way to maintain
a correspondenceï¼ˆå¯¹åº”æ€§ï¼‰ between red-black trees and 2-3-4 trees,
by interpreting red links asï¼ˆæŠŠçº¢é“¾æ¥è§£é‡Šä¸ºï¼‰ internal links in 3-nodes and 4-nodes.

Since red links can leanï¼ˆå€¾å‘åˆ°ï¼‰ either way in 3-nodes
(and, for some implementations in 4-nodes), the correspondence is not necessarily 1-1.

For clarity in our code,
we use a boolean variable (a single bit) to
encode the color of a linkï¼ˆé“¾æ¥çš„é¢œè‰²ï¼‰
in the node it points toï¼ˆåœ¨é“¾æ¥æ‰€æŒ‡å‘çš„ç»“ç‚¹ä¸­ï¼‰,
though Brown [5] has pointed out that we can mark nodes as red by switching their pointers,
so that we can implement red-black trees without any extra spaceï¼ˆé¢å¤–çš„ç©ºé—´ï¼‰.

One of the most important feature of red-black trees is that
they add no overheadï¼ˆå¼€é”€ï¼‰ for search, the most commonly used operation.

Accordingly, red-black trees are the underlying data structureï¼ˆåº•å±‚æ•°æ®ç»“æ„ï¼‰ for symbol-table implementations
within C++, Java, Python, BSD Unix, and many other systems.


Why revisitï¼ˆé‡æ–°å®¡è§†ï¼‰ such a successful data structure?
The actual code found in many implementations is difficult to maintainï¼ˆç»´æŠ¤ï¼‰ and to reuse in new systemsï¼ˆå¤ç”¨ï¼‰
because it is lengthyï¼ˆé•¿åº¦å¾ˆé•¿çš„ï¼‰, running 100-200 lines of code in typical implementations.

Full implementations are rarely found in textbooks,
with numerous â€œsymmetricâ€ cases left for the student to implement.

In this paper, we present an approach that
can dramatically reduce the amount of code required.

To prove the point, we present a full Java implementation,
comprisingï¼ˆåŒ…å«æœ‰ï¼‰ three short utility methods,
#1 adding 3 lines of code to standard BST code for insert,
#2 a 5-line method for delete the maximum,
#3 and 30 additional lines of code for delete.

