--- warmup round2: 在2-3树中删除最小键的算法 ---
最简单的情形：“删除最小键”发生在 树底部的3-结点中 - 在 删除结点 后，我们可以 很容易地恢复 红黑树的平衡。
更复杂的情形：从 一个2-结点 中 删除一个键 - 因为在 删除结点 后，会留下 一个空的链接（这会破坏 树的平衡，并且 很难处理）。
解决手段：通过一些技巧，避免“删除2-结点”的情形发生；
具体做法：在 查询路径往下走 的过程中，我们 沿着左链接（因为 最小的键 必然在2-3树的最左侧）向下变换 来 确保 ”当前结点“ 不是2-结点；
特征：这个过程与 上一节中“2-3-4树中插入新键”的过程 有很大的相似性（确保”当前结点“ 不是4-结点）

分类讨论：
- 对根结点的分类讨论 -
#1 如果 根结点的两个子节点 都是2-结点，则：直接 把 这3个节点 变成 一个4-结点；
#2 如果 根结点的两个子节点 不全是2-结点，则：需要通过一些技巧/约定 来 保证 根结点的左子结点（原因同上）不是 2-结点
    手段：可以从 它右侧的兄弟结点 “借”一个键过来。

- ”沿着左链接向下“的过程中，通过一些手段 来 使树满足 “当前结点不是2-结点”的要求 👇 -
① 如果 当前结点的左子结点 不是2-结点，则：满足要求；
② 如果 当前结点的左子结点 是2-结点，而 它的亲兄弟结点 不是2-结点，则：把 左节点的兄弟节点中的一个键 移动到 左节点中；
③ 如果 当前节点的左子结点 以及 它的兄弟结点 都是2-结点，则：
    左节点、父结点中的最小键、左节点最近的兄弟节点 合并成为一个 4-结点（这会使得 父结点退化成为 2-结点 或者 3-结点）
作用：在完成 上述变换 后，最终就能够得到 一个 “包含有最小键的”3-结点 或 4-结点。然后就能够 便捷地执行 删除操作了

🐖：在 删除完成 后，我们还需要 向上消除查询路径上 所有的（由于避免2-结点而产生）临时4-结点。

