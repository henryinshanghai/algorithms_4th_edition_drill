基于以上分析，想要实现2-3树。我们可以
    为2-结点准备对应的类型；
    为3-结点准备对应的类型；
    写出结点之间变换所需要的代码...

特征：使用这样直白的表示方式 来 实现大多数的操作 并不方便 - 因为需要处理的情况实在太多。
具体来说：
    #1 维护两种不同的结点类型；
    #2 比较传入的键 与 结点中的每一个键；
    #3 把 链接 和 其他信息 从一种结点 复制到 另一种结点；
    #4 把 结点 从一种数据类型 切换到 另一种数据类型...
🐖 这些操作需要大量的代码来实现，而且 这些代码的额外开销（overhead）可能会使得 算法 比起BST还要更慢。

--- 红黑二叉查找树 ---
直观上讲，BST的结构 比起 2-3树的结构 要更简洁易懂。
目标：所以 我们尝试 使用“添加了某些约束”的二叉查找树 来 表示2-3树。
    BST的引入的约束（相对于二叉树）：（数值上的）对称有序性
    2-3树引入的新约束（相对于BST）：（结构上的）平衡性

难点：23树中存在3-结点（两个key三个分叉），而BST中的所有结点都只是2-结点(一个key两个分叉)。怎么办？
思路：使用BST中 相邻层级的上下两个结点(父+子结点) 来 表示 2-3树中的3结点；
原理：因为这样的两个结点，刚好包含有 2个key 与 三个分叉；
图示：略
        a
      /   \
     b     c
    / \

（由此思路所）衍生的问题：
按照“使用父子结点 来 组成一个3-结点”的方式，在BST中，怎么决定 在什么情形下 需要组合成3-结点？什么时候不需要组合呢？
或者 换句话说，BST中的链接 ① 什么时候是 ”3-结点内部的链接“？② 什么时候是 连接2-结点与3-结点的链接呢？

目标：在BST中，标识当前的父子结点 需不需要合并 以 表示2-3树中的3-结点 来 逻辑上区分开以上的两种情形👆；
手段：对 BST中的 连接结点的链接 进行分类 -
    #1 黑链接 - 用于表示 23树中的一般链接，在BST中用于 ① 连接2-结点与3-结点、② 连接2-结点与2-结点；
    #2 红链接 - 用于表示 23树中的3-结点，在BST中用于 连接”用于表示3-结点“的父子结点；

🐖 总体上看，我们使用 ① 标准的BST（完全由2-结点组成） 与 ② 一些额外的信息（用于替换3-结点） 来 表示2-3树。
结果：BST 在添加了 链接相关的约束 后，就得到了一种新的逻辑结构 ”红黑树“。
一棵红黑树 能够等价于 一棵23树（① 数值有序性; ② 结构上的平衡性）