参照 delete_minKey_in_23tree, 我们可以把删除算法分成如下三个阶段：
#1 保证向下查找过程中，不会出现2-结点；
    手段#1：如果MAX查询路径中出现了3-结点，则 把3-结点的红链接移动到右边；
    手段#2：如果查询路径中出现了2-结点，则 为当前查询路径引入红链接；
#2 删除结点；
    手段#1：如果 查询已经到达树的叶子节点处，并且在此找到预期删除的结点，则：直接物理删除结点 返回null
    手段#2：如果 找到预期删除的结点，则：使用“后继结点”的方式 来 删除结点；
    手段#3：如果 当前节点并不是预期删除的结点，则
        递归地从当前子树(左子树)中 删除预期节点， 并把删除结点后的当前子树 重新绑定回到 当前子树上

    “后继结点”的删除方式：
        Ⅰ 使用待删除结点的它的后继结点 来 重置它的key、value（参考二叉查找树的删除算法）。
        Ⅱ 从右子树中删除最小键，并使用删除后的子树作为新的右子树；
        Ⅲ 使用原始节点的左子树，作为新的左子树。
    分析：由于#1中的操作，因此当前结点必然不是一个2-结点。
    所以 原始的删除问题 等价于/被转化为 “在一个根结点不是2-结点的树中删除最小键”（参考BST的删除算法）
#3 删除结点后，向上回溯查找路径，并分解路径上余下的4-结点。

🐖 所有的操作都是从一个红链接开始的。

评论：这是我们所学习的第一种 能够同时实现高效的 #1 查找、#2 插入和 #3 删除操作的符号表实现。
