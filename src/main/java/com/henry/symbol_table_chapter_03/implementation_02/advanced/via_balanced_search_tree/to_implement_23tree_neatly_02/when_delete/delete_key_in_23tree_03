参照 delete_minKey_in_23tree, 我们可以把 删除算法 分成如下三个阶段：
#1 保证 向下查找过程 中，不会出现 2-结点；
    手段#1：如果MAX查询路径中 出现了3-结点，则 把 3-结点的红链接 移动到右边；
    手段#2：如果MIN查询路径中 出现了2-结点，则 为 当前查询路径 引入红链接；
#2 删除结点；
    手段#1：如果 查询 已经到达 树的叶子节点处，并且 在此找到了 ”预期删除的结点“，则：直接物理删除结点 返回null
    手段#2：如果 找到了”预期删除的结点“，则：使用“后继结点”的方式 来 删除结点；
    手段#3：如果 当前节点 并不是 预期删除的结点，则
        递归地 从当前子树(左子树)中 删除 ”预期节点“， 并把 删除结点后的当前子树 重新绑定回到 当前子树上

    “后继结点”的删除方式：
        Ⅰ 使用 ”待删除结点“的”后继结点“ 来 重置它的key、value（参考二叉查找树的删除算法）。
        Ⅱ 从 右子树 中 删除最小键，并 使用”删除后的子树“ 作为 新的右子树；
        Ⅲ 使用 原始节点的左子树，作为 新的左子树。
    分析：由于#1中的操作，因此”当前结点“ 必然不是 一个2-结点。
    所以 原始的删除问题 等价于/被转化为 “在一个 ‘根结点不是2-结点’的树中 删除最小键”（参考BST的删除算法）
#3 删除结点后，向上回溯 查找路径，并分解 路径上余下的4-结点。

🐖 所有的操作 都是 从一个红链接开始的。

评论：这是我们所学习的第一种 能够同时实现高效的 #1 查找、#2 插入和 #3 删除操作的符号表实现。
