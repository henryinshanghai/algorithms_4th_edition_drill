红黑树的put()方法是 算法4中最复杂的实现之一。
但是红黑树的 deleteMin(), deleteMax()与delete()的实现 则 更加复杂。

完整的实现 留作练习，但是我们 仍旧要学习 它们的基本原理。

-- 删除算法 --
目标：在 从红黑树中删除结点 后，保持“合法的红黑树”。
手段：定义 一系列的局部变换 来 保持“合法的红黑树”。
特征：删除结点 并 恢复树的平衡的过程 比起 插入结点 并 恢复树的平衡的过程 更加复杂。
原因：
    #1 删除一个结点 后，我们需要构造出 临时的4-结点，并 沿着查找路径向下(how exactly?) 进行变换（for what?）;
    #2 在 分解遗留的4-结点 时，需要 沿着查找路径向上 进行变换（消除 树中的4-结点）

-- warmup round01: 自顶向下的 2-3-4树 的插入算法 --
🐖： 2-3-4树 的插入算法，既能够向上 也能够向下 进行变换；
特征：2-3-4树中，允许存在 4-结点。

插入算法的特征：
#1 沿着查找路径 向下进行变换 - 原因：保证”当前结点“ 不是4-结点，这样在树底才会有空间 来 插入新的键；
#2 沿着查找路径 向上进行变换 - 原因：将 之前创建的4-结点 配平（how? and why?）

- 沿着 2-3-4树 向下查找的过程 -
与 在2-3树中 分解4-结点时 所进行的变换规则 完全相同👇
① 如果遇到的是 根结点是4-结点 的情形，则：把 根结点 分解成为 3个2-结点（树高会加1）；
② 如果遇到的是 ”父结点为2-结点“的4-结点，则：把4-结点 分解成为 两个2-结点，并且 把 中键 传递给 它的父结点（父结点会变成一个3-结点）；
③ 如果遇到的是 ”父结点为3-结点“的4-结点，则：把4-结点 分解成为 两个2-结点，并且 把 中键 传递给 它的父结点（父结点会变成一个4-结点）；
不会出现 遇到的是 ”父结点为4-结点“的4-结点 - 因为插入算法本身 会保证 不会出现 这种情形。
作用/结果：当 查询路径到达树的底部 时，只会遇到 2-结点/3-结点 - 因此我们 有空间 来 插入新的键。

- 使用红黑树 来 实现2-3-4树的插入算法 -
🐖 在2-3-4树中合法的4-结点 在红黑树中是不合法的。
手段：
    #1 把 4-结点 表示为 由3个2-结点所组成的 一棵平衡的子树 - 在 这棵子树 中，根结点 与 它的两个子节点之间 都是用红链接相连；
    #2 在 向下查找的过程 中，分解掉 所有的4-结点 - 手段：使用“颜色转换”操作 来 消除对红黑树约束的breach；
    #3 在 向上恢复红黑树平衡的过程 中，do what? - 手段：使用“旋转”操作 来 消除对红黑树约束的breach。
具体代码实现：
    参考：xxx
    特征：只要 对 红黑树put()方法实现 做轻微的改动（把colorFlip()语句 移动到递归调用之前）即可；
应用：如果软件中 允许多个进程 同时访问 同一棵树，则：可以使用 上述的2-3-4树的插入算法。
    原因：因为算法只会操作 当前节点的一个或两个链接(2-3树的插入算法 会操作 更多的链接吗？)