一个散列函数能够将键转化成为 数组索引。

散列算法的第二步是 处理碰撞的情况。
也就是处理 两个或者多个键的散列值 相同的情况。

一种直接的办法是 把大小为M的数组 中的每个元素 都指向一条链表。
链表中的每个结点中 都存储了 散列值为该元素的索引 的键值对。

这种方式被称为 拉链法 - 因为发生冲突的元素 都被存储在了链表中。

这种方式的基本思想就是：
选择足够大的M，使得所有链表都能够 尽可能短 - 这样才能保证高效的查找。
查找算法分为两步：
#1 首先根据散列值 找到对应的链表； #2 然后沿着链表 来 顺序查找到相应的键。

拉链法的一种实现方式 是 使用原始的链表数据类型 来 扩展 LinkedNodeSymbolTable。
另一种更简单的方式 是 采用一般性策略：为M个元素 分别 构建符号表 来 保存被散列到这里的键 - 这样我们可以重用先前的代码

算法3.5实现的 SeparateChainingSymbolTable 使用了一个 LinkedNodeSymbolTable对象的数组，
在put()和get()的实现中： #1 先计算散列函数 来 选定被查找的 LinkedNodeSymbolTable对象，
#2 然后使用符号表的put()和get()方法 来 完成相应的任务。

因为我们会使用 M条链表 来 保存N个键，因此
无论键在各个链表中的分布如何，链表的平均长度 肯定是N/M;

比如，如果所有的键 都落在了第一条链表上，则：所有链表的平均长度为 (N+0+0+...)/M = N/M;

拉链法在实际情况中非常有用，因为每天链表确实都 大约含有N/M个键值对。
在一般情况中，我们能够使用它 来 验证假设J，并且 可以依赖它进行高效的get()与put()操作

在标准索引用例 中使用 基于拉链法的散列表 图示如图：
图略

LinkedNodeSymbolTable[]
其中每一个item都是 LinkedNodeSymbolTable 类型的对象。

参考代码：SeparateChainingSymbolTable
