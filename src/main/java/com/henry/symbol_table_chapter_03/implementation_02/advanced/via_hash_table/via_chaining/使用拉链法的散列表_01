一个散列函数 能够 将 键 转化成为 数组索引。

散列算法的第二步是 处理”碰撞“的情况。
也就是处理 两个或者多个键的 散列值相同的情况。

一种直接的办法是 把 ”大小为M的数组“中的每个元素都 指向一条链表。
链表中的 每个结点中都 存储了 ”散列值为‘该元素的索引’“ 的键值对。

这种方式被称为 拉链法 - 因为 发生冲突的元素 都被存储在了链表中。

这种方式的基本思想就是：
选择 足够大的M，使得 所有链表都 能够尽可能短 - 这样才能保证 高效的查找。
查找算法分为两步：
#1 首先根据散列值 找到对应的链表； #2 然后沿着链表 来 顺序查找到相应的键。

拉链法的一种实现方式 是 使用原始的链表数据类型 来 扩展 LinkedNodeSymbolTable。
另一种更简单的方式 是 采用一般性策略：为M个元素 分别 构建符号表 来 保存”被散列到这里的键“ - 这样我们可以重用先前的代码

算法3.5实现的 SeparateChainingSymbolTable 使用了一个 LinkedNodeSymbolTable对象的数组，
在put()和get()的实现中：
#1 先 计算散列函数 来 选定 被查找的LinkedNodeSymbolTable对象，
#2 然后 使用符号表的put()和get()方法 来 完成相应的任务。

因为我们会使用 M条链表 来 保存N个键，因此
无论 键在各个链表中的分布 如何，链表的平均长度 肯定是N/M;

比如，如果 所有的键 都落在了 第一条链表上，则：所有链表的平均长度为 (N+0+0+...)/M = N/M;

拉链法 在实际情况中 非常有用，因为每条链表 确实都 大约含有N/M个键值对。
在一般情况中，我们能够使用它 来 验证假设J，并且 可以依赖它 进行高效的get()与put()操作。

在标准索引用例中 使用”基于拉链法的散列表“ 图示如图：
图略

LinkedNodeSymbolTable[]
其中每一个item都是 LinkedNodeSymbolTable 类型的对象。

参考代码：SeparateChainingSymbolTable
