Efficient implementation of the delete operation is a challenge
in many symbol-table implementations, and red-black trees are no exceptionï¼ˆçº¢é»‘æ ‘ä¹Ÿä¸ä¾‹å¤–ï¼‰.

Industrial-strength implementations run to over 100 lines of code,
and text books generally describe the operation in terms ofï¼ˆä»¥...æ–¹å¼ï¼‰ detailed case studies,
eschewingï¼ˆåˆ»æ„é¿å¼€ï¼‰ full implementations.

Guibas and Sedgewick presented a delete implementation in [7],
but it is not fully specifiedï¼ˆå®Œå…¨æŒ‡å®šï¼‰ and
depends on a call-by-reference approach
not commonly found in modern codeï¼ˆåœ¨ç°ä»£çš„ä»£ç ä¸­å¹¶ä¸å¸¸è§ï¼‰.

The most popular method in common use is based on a parent pointersï¼ˆçˆ¶æŒ‡é’ˆï¼‰ (see [6]),
which adds substantial overheadï¼ˆå¾ˆå¤§çš„å¼€é”€ï¼‰ and
does not reduce the number of cases to be handled.

=== meatè‚‰ğŸ‘‡ ===

The code on the next page is a full implementation of delete() for LLRB 2-3 treesï¼ˆç”¨å·¦å€¾çº¢é»‘æ ‘å®ç°çš„2-3æ ‘ï¼‰.
It is based on the reverse ofï¼ˆé€†è¿‡ç¨‹ï¼‰
the approach used for insert in top-down 2-3-4 treesï¼ˆè‡ªä¸Šè€Œä¸‹çš„2-3-4æ ‘çš„æ’å…¥æ‰€ä½¿ç”¨çš„æ–¹å¼ï¼‰:
we perform rotations and color flips
on the way down the search pathï¼ˆæ²¿ç€æœç´¢è·¯å¾„å¾€ä¸‹ï¼‰ to
ensure that the search does not end on a 2-nodeï¼ˆæœ¬æ¬¡æœç´¢ä¸ä¼šç»ˆæ­¢äºä¸€ä¸ª2-ç»“ç‚¹ï¼‰,
so that we can just delete the node at the bottom.ï¼ˆå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥ä»åº•éƒ¨åˆ é™¤ç»“ç‚¹ï¼‰

We use the method fixUp() to
share the code for the color flip and rotations
followingï¼ˆç´§è·Ÿç€ï¼‰ the recursive calls in the insert() code.

With fixUp(), we can leave right leaning red linksï¼ˆå³å€¾çš„çº¢é“¾æ¥ï¼‰ and unbalanced 4-nodesï¼ˆæœªå¹³è¡¡çš„4-ç»“ç‚¹ï¼‰
along the search pathï¼ˆåœ¨æŸ¥è¯¢è·¯å¾„ä¸­ï¼‰, secure that
these conditionsï¼ˆæœ‰é—®é¢˜çš„çŠ¶å†µï¼‰ will be fixed
on the way up the treeï¼ˆæ²¿ç€æ ‘å‘ä¸Šçš„è¿‡ç¨‹ä¸­ï¼‰.

(The approach is also effective 2-3-4 trees,
but requires an extra rotation
when the right node off the search path
is a 4-node.)

As a warmup, consider the delete-the-minimum operation, where the goal is
to delete the bottom node on the left spineï¼ˆåˆ é™¤å·¦è„Šä¸Šçš„åº•éƒ¨èŠ‚ç‚¹ï¼‰
while maintaining balanceï¼ˆåŒæ—¶ç»´æŠ¤æ ‘çš„å¹³è¡¡æ€§ï¼‰.

To do so, we maintain the invariantï¼ˆä¸å˜æ€§ï¼‰ that
the current node or its left child is redï¼ˆå½“å‰èŠ‚ç‚¹ æˆ–è€… å®ƒçš„å·¦å­ç»“ç‚¹ä¸ºçº¢è‰²ï¼‰.

We can do so by
moving to the leftï¼ˆæŠŠxxxç§»åŠ¨åˆ°å·¦è¾¹ï¼‰
unless the current node is red and its left child and left grandchild are both black.

In that caseï¼ˆå½“å‰ç»“ç‚¹ä¸ºçº¢è‰²&å®ƒçš„å·¦å­ç»“ç‚¹ä¸å·¦å­ç»“ç‚¹çš„å·¦å­ç»“ç‚¹éƒ½æ˜¯é»‘è‰²ï¼‰, we can do a color flip, which restores the invariantï¼ˆline44ï¼‰
but may introduce successive reds on the rightï¼ˆåœ¨å³ä¾§å¼•å…¥è¿ç»­çš„çº¢é“¾æ¥ï¼‰.
In that caseï¼ˆå³ä¾§å‡ºç°è¿ç»­çš„çº¢é“¾æ¥ï¼‰, we can correct the condition with two rotations and a color flip.

These operations are implemented in the moveRedLeft() method on the next page.
With moveRedLeft(), the recursive implementation of deleteMin() above is straightforwardï¼ˆç›´ç™½çš„ï¼‰.

For general deletion, we also need moveRedRight(), which is similar, but simpler,
and we need to
rotate left-leaning red links to the right on the search pathï¼ˆåœ¨æœç´¢è·¯å¾„ä¸ŠæŠŠå·¦å€¾çš„çº¢é“¾æ¥ æ—‹è½¬æˆä¸ºå³å€¾ï¼‰
to maintain the invariant.

If the node
to be deleted is an internal nodeï¼ˆå†…éƒ¨èŠ‚ç‚¹/éå¶å­èŠ‚ç‚¹ï¼‰, we replace its key and value fields
with those in the minimum node in its right subtreeï¼ˆå³å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼‰
and then delete the minimum in the right subtree (or
we could rearrange pointers to
use the node instead of copying fields).

The full implementation of delete() that derives from this discussionï¼ˆç”±æ­¤è®¨è®ºæ‰€è¡ç”Ÿçš„åˆ é™¤æ“ä½œçš„å®ç°ï¼‰
is given on the facing page.
It uses one-third to one-quarter the amount of code
found in typical implementations.

It has been demonstrated before [2, 11, 13] that
maintaining a field in each node containing its height
can lead to code for delete that is similarly concise,
but that extra space is a high price to pay
in a practical implementation.

With LLRB trees, we can arrange for concise code
having a logarithmic performance guarantee
and using no extra space.




