== 构造 标准的BST ==
手段：以”独立结点“的形式, 把 待插入的key 依附到 叶子节点上；
原理：BST中，对新插入的key的查询 会结束于 某个nil结点，然后 “新添加的独立结点”会 被放置在 这个空结点的位置上。
特征：因此，BST会 从上往下地 生长（aka 在叶子结点的位置不断向下延伸）；

== 构造 2-3树 ==
手段：直接把 待插入的key 融合进 叶子节点中，从而得到 键数+1的结点类型；
原理：2-3树中，对 新插入的key 的查询 会结束于 某个叶子结点（为了保持2-3树的平衡性）；
特征：
    #1 如果查询 结束于2-结点，则：融合 待插入的key 之后，会得到一个3-结点；
    #2 如果查询 结束于3-结点，则：融合 待插入的key 之后，会得到一个4-结点(在2-3树中，它是不合法的)；
        目标：① 遵守 2-3树的结点类型约束（仅存在 2-结点 与 3-结点）&& ② 维护2-3树的平衡性；
        手段：我们需要在 保证平衡性 的前提下，分解/转换4-结点 为 合法的结点[参考：invariant_when_transform_temp4node_02]；
        特征：这样的操作会 从叶子节点开始，沿着查找路径 从下往上地 进行。
    #3 （由#2所衍生）因此，2-3树的生长 是 从下往上的。

-- 使用同一组键 来 构造BST VS. 构造2-3树 的对比 --
    使用 标准索引用例（某一特定顺序） 所构造产生的2-3树； - 是一个高度为2的2-3树
    使用 同一组键，按照升序 依次插入2-3树中 所产生的2-3树； - 是一个高度为2的2-3树
    使用 同一组键，按照升序 依次插入BST中 所产生的BST； - 是一个高度为9的最差查找树（一个链表）
评价：从平衡性上来看，2-3树的表现 比起 BST 要优秀很多

-- 对2-3树的性能分析 --
🐖 分析2-3树的性能时，我们 会分析 最差情况下的性能。
原因：因为我们 没办法控制 用例会 按照什么样的顺序 向符号表中插入键，所以只有分析 最坏的情况，才能够 真正地提供性能保证。

结论：在一棵 大小为N的2-3树 中，查找操作 & 插入操作 所访问的结点数量 不会超过 lgN个。
推论：2-3树 在最坏的情况下，其search 与 insert操作 仍然会有 较好的性能（对数级别）。

-- 2-3树的直观成就 --
相比较于BST，用 同一组键 所构造出的2-3树 要 矮胖地多(flat).
具体来说，一个 ”含有10亿个结点“的一棵2-3树的高度 只会在19-30之间。
也就是说，我们只需要 最多访问30个结点 就能够 在10亿个键中 进行任意的 查找操作 & 插入操作。