目标：一种 拥有如下特性 的二叉树 - 不管怎样构造它，它的运行时间 都是对数级别的。
分析：通过上一节 对二叉树的分析 可知，这需要我们 保持二叉查找树的平衡性 aka 对于一个 包含有N个结点的二叉树，我们希望 它的树高 是~lgN.
原理：一个 树高为lgN 的二叉树，它的所有查找操作 都能够 在 ~lgN次比较内 完成。

规约/等价目标：维护 树的平衡性。
手段1：在 动态插入的过程 中，保持 树的完美平衡（所有 “空链接” 到 “根结点”的距离 都相同）；
    特征：这种做法 代价太高了。
手段2：引入一种 ”能够保证平衡性“ 的新数据结构 ———— 2-3树；
    特征：使用 2-3查找树 所实现的符号表中，它的所有操作（范围查找除外）都能够 在对数时间内完成。

目标：扩展 二叉查找树，从而得到一个 相对更容易维护其平衡性 的数据结构；
手段：扩展 树中的结点类型（原本的BST中 就只有 一种节点类型：2-结点），来 允许一个节点中 包含有 多个键；
概念：
    #1 如果 结点中只有一个键，并且 结点只有两个分叉。则：把 这样的结点 叫做 2-结点（BST中的一般结点）；
    #2 如果 结点中包含有两个键，并且 结点有3个分叉。则：把 这样的结点 称为 3-结点。
从逻辑上讲，每条链接 都对应着 一个由键所产生的区间。
    [a b]
   /  |  \
 <a [a,b] >b

== 2-3查找树的定义 ==
#1 要么 是一棵空树；
#2 要么 由 以下类别的结点 所组成：
    ① 2-结点：特征：#1 这样的结点 含有 一个键&两条链接（结构约束)； #2 键的大小关系：左子树 < 当前结点 < 右子树(数值约束)；
    ② 3-结点：特征：#1 这样的结点 含有 两个键&三条链接（结构约束）； #2 键的大小关系：左子树 < 当前结点的左键 < 中子树 < 当前节点的右键 < 右子树；

概念：
    #1 空链接：我们把 一条指向空树的链接 称为 “空链接”；
    #2 完美平衡：当2-3树满足 所有的空链接 “到根结点的距离”都相同时，我们称之为 “完美平衡”。
🐖 为了表达的简洁性，我们会使用 “2-3树” 来 指代 “完美平衡的2-3树”。

next: 假设我们 已经实现了 2-3树，先学习下 怎么使用2-3树 来 实现符号表