目标：一种拥有如下特性的二叉树 - 不管怎样构造它，它的运行时间都是对数级别的。
分析：通过上一节对二叉树的分析可知，这需要我们保持二叉查找树的平衡性 aka 对于一个包含有N个结点的二叉树，我们希望它的树高是~lgN.
原理：一个树高为lgN的二叉树，它的所有查找操作都能够在 ~lgN次比较内完成。

规约/等价目标：维护树的平衡性。
手段1：在动态插入的过程中，保持 树的完美平衡（“空链接” 到 “根结点”的距离相同）；
    特征：这种做法代价太高了。
手段2：引入一种 ”能够保证平衡性“的新数据结构 ———— 2-3树；
    特征：使用2-3查找树所实现的符号表中，它的所有操作（范围查找除外）都能够在对数时间内完成。

目标：扩展二叉查找树，从而得到一个 相对更容易维护其平衡性的数据结构；
手段：扩展 树中的结点类型（原本的BST中就只有2-结点），允许一个节点中包含有多个键；
概念：
    #1 如果结点中只有一个键，并且结点只有两个分叉。则：把这样的结点叫做2-结点（BST中的一般结点）；
    #2 如果结点中包含有两个键，并且结点有3个分叉。则：把这样的结点 称为3-结点。
从逻辑上讲，每条链接 都对应着 一个由键所产生的区间。
    [a b]
   /  |  \
 <a [a,b] >b

== 2-3查找树的定义 ==
#1 要么是一棵空树；
#2 要么由以下类别的结点组成：
    ① 2-结点：特征：#1 这样的结点含有一个键&两条链接（结构约束)； #2 键的大小关系：左子树 < 当前结点 < 右子树(数值约束)；
    ② 3-结点：特征：#1 这样的结点含有两个键&三条链接（结构约束）； #2 键的大小关系：左子树 < 当前结点的左键 < 中子树 < 当前节点的右键 < 右子树；

概念：
    #1 空链接：我们把 一条指向空树的链接 称为 “空链接”；
    #2 完美平衡：当2-3树满足 所有的空链接 “到根结点的距离”都相同时，我们称之为 “完美平衡”。
🐖 为了表达的简洁性，我们会使用 “2-3树” 来 指代 “完美平衡的2-3树”。

next: 假设我们已经实现了2-3树，先学习下怎么使用2-3树 来 实现符号表