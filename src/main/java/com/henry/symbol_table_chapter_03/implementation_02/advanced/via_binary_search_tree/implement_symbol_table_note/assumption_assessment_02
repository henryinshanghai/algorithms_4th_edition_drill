在01的结论中，我们 所使用到的基本假设（basic assumption）是：随机键模型；
但是对于 这样一种假设，我们 需要考察 其合理性(rationality)

也就是说 随机键模型（applied model） 与 典型的/常用的符号表使用情况(typical use case) 是不是 相符合(match)的呢？
结论：对于 大多数用例，随机键模型 都能很好地适应 (fit)它们的实验结果。

目标：对 通过分析所得出的结论 进行实验层面的验证；
手段：研究 在 使用CountWordFrequencyViaSymbolTable 来 处理 “命令行参数文件”中存在的“长度大于等于8的单词” 时，put()操作 所需要的成本。

目标：比较 不同符号表的实现 的工作性能；
手段：使用一个符号表的具体用例，然后从 符号表的实现01 切换到 实现02，从而对比 实现01与实现02 在某一操作上 具体的性能表现。
过程：略（稍后补上）
结论：
    #1 当使用 BinarySearchTreeSymbolTable符号表实现 时，put()操作的平均成本 是 13次数组访问；
    #2 当使用 OrderedArraySymbolTable符号表实现 时，put()操作的平均成本 是 484次数组访问；
推论：BinarySearchTreeSymbolTable符号表实现 为 put()操作 提供了 更好的性能；
作用：实验结果 验证了 理论模型所预测的 对数级别的性能。

-- 分析理论预测(prediction) 与 实验数据(experiment)之间 存在有差异的原因 --
按照理论预测，put()操作的平均成本 = 符号表大小的自然对数 * 2；
原理：对于一个 几乎充满的符号表，针对它的大多数操作 都是 查找操作。

导致预测不准确的可能原因👇
#1 很多操作 其实是在 比较小的符号表中进行的；
#2 真实输入模型中，键可能 并不是随机的；
#3 如果 符号表本身太小的话，近似值2lnN 可能是不准确的。

疑问：怎么通过实验 来 获取到put()操作 实际所需要的比较次数呢？？？