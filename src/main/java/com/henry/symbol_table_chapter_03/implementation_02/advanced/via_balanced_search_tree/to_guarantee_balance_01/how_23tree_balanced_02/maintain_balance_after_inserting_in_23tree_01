== 向2-3树中插入新键的4种case ==
思路：我们不再把 插入的key 以“独立的结点”依附到“当前的叶子节点”上，而是把key合并到(merge)当前的叶子节点中 来 扩展其为新的节点类型。

-- #1 向2-结点中插入新键；--
对于一个新键来说，对它的查找操作会结束于一个空结点/链接。
目标：我们希望 在插入新节点后，2-3树 仍旧能够 保持平衡（这就是使用2-3树的原因）；
手段：
    #1 如果 未命中的查找 结束于一个2-结点（空结点的上一个结点），则：向2-结点中 直接插入 新的键，使之 成为一个3-结点 即可。
    #2 如果 未命中的查找 结束于一个3-结点，则：👇

-- #2 向一个 ”只含有一个结点（且此结点为3-结点）“ 的树中，插入新的键：--
🐖 这是一般情况（向3-结点中 插入一个新键）的特殊情况
由于 3-结点中 只允许存在 两个键, 因此 已经没有空间 再容纳 新的键了。怎么办？
手段：
    #1 先临时地 把新键插入到3-结点中，这样它其中 就包含有 3个键了 - 也就是一个 临时的4-结点。
    #2 对于 #1中得到的4-结点，把 它 转换成为 3个2-结点（共有3个键）；
        转换规则：左键 成为 左子结点 & 中键 成为 中子节点 & 右键 成为 右子节点；
特征：插入新键之前，树的高度为0； 插入之后，树的高度为1.
应用：由 4-结点 得到 3个2-结点 的操作，可以用于 2-3树的生长。

-- #3 向一个 ”父节点是2-结点“的3-结点中，插入新键：--
如果 未命中的查找 结束于 这样的结点，则：👇
目标：在维持 树的完美平衡 的前提下，为新键 提供空间；
手段：
    #1 先 向3-结点中 插入新键，得到一个 临时的4-结点；
    #2 把 #1中的4-结点 分解成为 3个2-结点，并随即 将中键添加到 4-结点原始的父节点 中。
    转换规则：把 中键 直接添加到 ”作为父节点的2-结点“中，使之成为一个3-结点。
特征：
    1 从 链接的角度 来看，相当于把 原本指向原始3-结点的一条链接 替换成为 依附于”4-结点中键“的两条链接。
    2 原本作为父节点的2-结点 变化成了 3-结点；
    3 转换完成后，2-3树的主要性质仍旧成立（① 有序性（左 < 根 < 右） & 完美平衡性（② 空链接到根结点的距离相等））

-- #4 向一个 ”父节点是3-结点“的3-结点中，插入新键：--
如果 未命中的查找 结束于 这样的结点，则：👇
手段：
    #1 向 作为叶子节点的3-结点 中插入新键，得到一个 临时的4-结点；
    #2 分解 #1中得到的4-结点，并随即 将中键添加到 作为父节点的3-结点中，再次得到 一个临时的4-结点；
    #3 按照相同的规则 继续分解 #2中的4-结点：把4-结点 分解成为 3个2-结点，并随即 把中键添加到 原4-结点的父节点中去。
特征：
    1 把 中键 添加到父节点中之后，父节点 仍然可能成为 一个4-结点，这时候我们继续 以同样的方式 分解4-结点；
    2 #1中的过程可能 重复多次，直到 遇到了一个2-结点（添加中键后 会成为3-结点） 或者 作为根结点的3-结点（添加中键后 会成为4-结点，随后 分解成为 3个2-结点）
应用：这种 ① 由 4-结点 分解得到 3个2-结点 && ② 把中键结点 添加到 4-结点的父节点 中的操作，能够用于 一般性地处理 由于插入操作而引起的 2-3树的生长。

-- #5 对根结点 进行分解 --
    如果从 合并结点 到 根结点 的路径上 全都是3-结点，则：按照👆的变化规则，根结点 最终会成为 一个临时的4-结点。
    手段：按照 向一棵 只有一个结点（且此结点是3-结点）的树中，插入新键的方式 来 处理 最终的根结点。
    具体来说，把 临时的4-结点 分解成为 3个2-结点，使得 树高加1.
    特征：保持了 树的完美平衡性 - 因为变化的是根结点，不会影响 空链接到根结点的距离。
