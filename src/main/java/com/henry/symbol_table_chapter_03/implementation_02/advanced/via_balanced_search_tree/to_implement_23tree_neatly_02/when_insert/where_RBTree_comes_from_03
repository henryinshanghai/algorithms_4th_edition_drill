结论：只要谨慎地使用 左旋转、右旋转以及颜色转换这三个操作，我们就能够 保证插入结点后的树仍旧是一棵红黑树（2-3树）。

红黑树中插入算法的实现概要（overview）：
    #1 对于从插入结点到根结点的路径，我们从插入结点开始，沿着路径上的每个结点向上移动；
    #2 在路过每个结点时，完成如下👇操作（来消除breach，维持红黑树）：
        ① 如果右子结点为红色，而左子结点为黑色（说明出现了红色的右链接），则：对红色链接的父节点进行左旋转；
        ② 如果左子结点为红色，而左子结点本身的左子结点也是红色的（说明出现了连续的红链接），则：对上层红色链接的父节点 进行右旋转；
        ③ 如果左右子结点都是红色，则：执行颜色转换。

向3-结点中插入新结点后的所有3种情形 & 情形转化图：
略

再回顾一下到底发生了什么？
== 我们的起点是：BST数据结构；==
特征：
    #1 它兼具了数组的二分查找特性 & 链表的快速插入特性。
    #2 但是它没办法保证最坏情况下的性能（因为用例构造出的BST可能是不平衡的）

== 平衡的23树 ==
为了引入平衡性的约束，我们扩展了BST，引入了2-3树：
原理：普遍来说，2-3树相比于BST外观上会更加地矮胖（因为单个节点中能够容纳更多的key），也因此更容易维护它的平衡性；

-- 23树的平衡性 --
为了维护2-3树的平衡性，我们引入了
    #1 “临时4-结点”（3个key，4个分叉） &&
    #2 breakdown 临时4-结点的规则 - 分解4-结点时，它的中键会被移动到它的父结点中；

== 与23树等价的红黑树 ==
使用临时4-结点，理论上能够在插入结点后，维护2-3树的平衡性。
但是相关的代码实现会非常繁琐（因为scenario太多）。
为了能够更简单地实现23树，我们引入了红黑树：
    原理：红黑树使用 “2-结点 + 结点链接颜色 [黑结点 + 红色的左子结点]” 来 等价表示 2-3树中的3-结点。

-- 红黑树的平衡性 --
平衡的红黑树 与 平衡的2-3树完全等价。
为了保持这种等价性，我们为红黑树引入了新的约束：
    关于红链接的约束：#1 不存在红色的右链接； #2 不存在连续的红链接。
为了能够在插入新结点后，使 “插入结点后的树” 变回 “一棵平衡的红黑树”，我们引入了如下的局部操作👇
    #1 左旋转; #2 右旋转; #3 颜色转换；
为了遵守 红黑树 与 2-3树的转换(transformation)规则，我们添加了一个补充约束：
    红黑树的根结点总是黑色（否则：红色的根结点 在2-3树中不存在对应的模型）

以上 2023/06/21 0:33 AM
