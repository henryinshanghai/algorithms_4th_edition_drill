#1 使用递归方式实现的二叉搜索树 与 使用迭代方式实现的二叉搜索树 各自有哪些优缺点？

一般来说，递归方式的实现 会更容易验证 实现的正确性（why?）；
而 迭代方式的实现 效率更高 —— 所以 可以使用迭代方式 来 实现get(), 这样会有一些 性能上的改进。
另外，如果树是不平衡的，则：对于 递归方式的实现 来说，函数栈的深度 可能会成为一个问题。

之所以 在示例中 使用递归方式来实现BST，是因为：
    #1 从 这种方式 能够轻松地过渡到 平衡二叉树。
    #2 递归方式的实现 更加容易，也方便调试（怎么就便于调试了?）。

#2 为什么需要 维护一个 itsNodeAmount（结点计数器）的实例变量呢？或者 为什么想到 要维护它呢？
    因为在 rankOf(passedKey) 与 selectOut(passedRanking)方法的实现 中，需要知道 “每个结点所代表的子树”中的 结点总数量。
    而要 维护所有结点的“结点计数器”的正确性 是 比较容易出错，但是 这样的一个实例变量 在调试的时候 会非常有用。

    如果没有 这样一个实例变量，某些 看似简单的操作（比如递归方式实现的size()）的运行时间 可能会是 线性的。
