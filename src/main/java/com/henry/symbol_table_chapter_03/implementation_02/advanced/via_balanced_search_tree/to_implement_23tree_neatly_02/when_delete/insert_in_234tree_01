红黑树的put()方法是 算法4中最复杂的实现之一。
但是红黑树的 deleteMin(), deleteMax()与delete()的实现则更加复杂。

完整的实现留作练习，但是我们仍旧要学习它们的基本原理。

-- 删除算法 --
目标：在从红黑树中删除结点后，保持“合法的红黑树”。
手段：定义一系列的局部变换 来 保持“合法的红黑树”。
特征：删除结点并恢复树的平衡的过程 比起 插入结点并恢复树的平衡的过程 更加复杂。
原因：
    #1 删除一个结点后，我们需要构造出临时的4-结点。并沿着查找路径向下(how exactly?)进行变换（for what?）;
    #2 在分解遗留的4-结点时，沿着查找路径向上进行变换（消除树中的4-结点）

-- warmup round01: 自顶向下的2-3-4树的插入算法 --
🐖： 2-3-4树的插入算法，既能够向上也能够向下进行变换；
特征：2-3-4树中，允许存在4-结点。

插入算法的特征：
#1 沿着查找路径向下进行变换 - 原因：保证当前结点不是4-结点，这样在树底才会有空间 来 插入新的键；
#2 沿着查找路径向上进行变换 - 原因：将之前创建的4-结点配平（how? and why?）

- 沿着2-3-4树向下查找的过程 -
与 在2-3树中分解4-结点所进行的变换规则 完全相同👇
① 如果遇到的是 根结点是4-结点，则：把根结点分解成为3个2-结点（树高会加1）；
② 如果遇到的是 父结点为2-结点的4-结点，则：把4-结点分解成为两个2-结点，并且把中键传递给它的父结点（父结点会变成一个3-结点）；
③ 如果遇到的是 父结点为3-结点的4-结点，则：把4-结点分解成为两个2-结点，并把中键传递给它的父结点（父结点会变成一个4-结点）；
不会出现 遇到的是 父结点为4-结点的4-结点 - 因为插入算法本身会保证不会出现这种情形。
作用/结果：查询路径到达树的底部时，只会遇到2-结点/3-结点 - 因此我们有空间来插入新的键。

- 使用红黑树 来 实现2-3-4树的插入算法 -
🐖 2-3-4树中合法的4-结点 在红黑树中是不合法的。
手段：
    #1 把4-结点 表示为 由3个2-结点所组成的一棵平衡的子树 - 在这棵子树中，根结点与它的两个子节点之间都是用红链接相连；
    #2 在向下查找的过程中，分解掉所有的4-结点 - 手段：使用“颜色转换”操作来消除对红黑树约束的breach；
    #3 在向上恢复红黑树平衡的过程中 - 手段：使用“旋转”操作 来 消除对红黑树约束的breach。
具体代码实现：
    参考：xxx
    特征：只要对红黑树put()方法实现做轻微的改动（把colorFlip()语句 移动到递归调用之前）即可；
应用：如果软件中允许多个进程同时访问同一棵树，则：可以使用上述的2-3-4树的插入算法。
    原因：因为算法只会操作 当前节点的一个或两个链接(2-3树的插入算法会操作更多的链接吗？)

