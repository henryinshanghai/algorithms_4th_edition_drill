基于以上分析，想要实现2-3树。我们可以
    为2-结点准备对应的类型；
    为3-结点准备对应的类型；
    写出结点之间变换所需要的代码...

特征：使用这样直白的表示方式 来 实现大多数的操作 并不方便 - 因为需要处理的情况实在太多。
具体来说：
    #1 维护两种不同的结点类型；
    #2 比较传入的键 与 结点中的每一个键；
    #3 把链接和其他信息 从一种结点 复制到 另一种结点；
    #4 把结点从一种数据类型 切换到另一种数据类型...
🐖 这些操作需要大量的代码来实现，而且这些代码的额外开销（overhead）可能会是算法比起BST还要更慢。

--- 红黑二叉查找树 ---
直观上讲，二叉搜索树的结构 比起 2-3树的结构 要更简洁易懂。
目标：所以 我们尝试 使用“添加了某些约束”的二叉查找树 来 表示2-3树。
    BST的引入的约束（相对于二叉树）：对称有序性
    2-3树引入的新约束：（结构上的）平衡性

难点：23树中存在3-结点（两个key三个分叉），而BST中的所有结点都只是一个key两个分叉。怎么办？
思路：使用BST中相邻层级的上下两个结点(父子结点) 来 表示2-3树中的3结点；
原理：因为这样的两个结点，共包含有2个key与三个分叉；
图示：略

（由此思路产生）的衍生问题：
按照“父子结点组成一个3-结点”的方式，在BST中，怎么决定什么情形下需要组合成3-结点？什么时候不需要组合呢？
或者换句话说，BST中的链接什么时候是 3-结点内部的链接？什么时候是连接2-结点与3-结点的链接呢？

目标：在BST中，标识当前的父子结点需不需要合并 来 逻辑上表示2-3树中的一个3-结点；
手段：对BST中的连接结点的链接 进行分类 -
    #1 黑链接 - 用于表示23树中的一般链接，在BST中用于连接2-结点与3-结点、连接2-结点与2-结点；
    #2 红链接 - 用于表示23树中的3-结点，在BST中用于连接表示3-结点的内部节点；

🐖 总体上看，我们使用标准的二叉查找树（完全由2-结点组成） 与 一些额外的信息（用于替换3-结点） 来 表示2-3树。
结果：BST再添加了链接相关的约束后，就得到了一种新的逻辑结构 红黑树。一棵红黑树能够等价于一棵23树（平衡性）