#1 数组大小的选择 并不是 关键性的选择

在实现 ”基于拉链法“的散列表 时，我们的目标是 选择适当的数组大小M。
这样既不会 因为空链表 而 浪费大量的内存，也不会 因为链表太长 而 在查找上浪费太多时间。
拉链法的一个好处在于 - 数组大小的选择 并不是 关键性的选择。

如果 存入的键 多于预期，查找所需的时间 只会比 选择更大的数组 稍微长一些；
如果 少于预期，则：虽然存在 空间浪费，但是 查找会非常快。

当 内存不是很紧张 的时候，可以选择一个 足够大的M，使得 查找所需要的时间 变成常数；
当 内存紧张 的时候，选择 尽量大的M 仍旧能够 把性能提升M倍。

比如对于 FrequencyCounter来说，考察 ”每次操作所需要的比较次数“ 这一指标：
在使用 LinkedNodeSymbolTable符号表实现 时，这个指标的值 是上千次，
而使用 SeparateChainingSymbolTable的符号表实现 时，这个指标的值是 若干次（如理论模型所料）。

另一种方式 是 动态调整数组的大小 以 保持短小的链表。

===
#2 删除操作 可以重用 LinkedNodeSymbolTable实现中的代码

如果 想要 删除一个键值对，
① 先 使用键的散列值 来 找到含有该键的 LinkedNodeSymbolTable对象，
② 然后再 调用这个对象的delete()方法；

这种重用 已有代码的实现 比起 重新实现链表的删除操作 要更好。

===
#3 对于 有序性相关的操作，散列表的方式 会很慢

散列操作 最主要的作用在于 均匀地 把键散布开来；
特征：在 经过散列 后，键的顺序信息 就丢失了。
推论：
    如果你想要 ① 快速找到最大或者最小的键，或者 ② 查找某个范围内的键，或者 ③ 实现 有序符号表API中的任何一个方法，
    则：散列表 都不是合适的选择 - 因为 使用散列表 时，所有这些操作的运行时间 都会是线性的。

”基于拉链法“的散列表的实现 相对简单。
在 键的顺序 并不重要的应用中，它可能是 最快的（也是使用最为广泛的）符号表实现。
当 ① 使用Java的内置数据类型 作为键，或者 ② 在使用 含有经过完善测试的hashCode()方法的自定义类型 作为键时，
SeparateChainingSymbolTable实现 能够提供 方便而快捷的 查找和插入操作。

