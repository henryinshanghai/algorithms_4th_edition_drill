#1 数组大小的选择 并不是 关键性的选择

在实现  基于拉链法的散列表时，我们的目标是 选择适当的数组大小M。
这样既不会因为空链表浪费大量的内存，也不会因为链表太长而在查找上浪费太多时间。
拉链法的一个好处在于 - 数组大小的选择 并不是 关键性的选择。

如果存入的键 多于预期，查找所需的时间 只会比 选择更大的数组 稍微长一些；
如果少于预期，则：虽然存在空间浪费，但是查找会非常快。

当内存不是很紧张的时候，可以选择一个 足够大的M，使得 查找所需要的时间 变成常数；
当内存紧张的时候，选择尽量大的M 仍旧能够把性能提升M倍。

比如对于 FrequencyCounter来说，考察 每次操作所需要的比较次数 这一指标：
在使用 LinkedNodeSymbolTable符号表实现 时，这个指标的值是上千次，
而使用 SeparateChainingSymbolTable的符号表实现 时，这个指标的值是若干次（如理论模型所料）。

另一种方式 是 动态调整数组的大小 以 保持短小的链表。

===
#2 删除操作可以重用 LinkedNodeSymbolTable实现中的代码

如果想要删除一个键值对，先使用键的散列值 来 找到含有该键的 LinkedNodeSymbolTable对象，
然后再调用这个对象的delete()方法；

这种重用 已有代码的实现 比起 重新实现链表的删除操作 要更好。

===
#3 对于有序性相关的操作，散列表的方式会很慢

散列操作 最主要的作用在于 均匀地把键散布开来；
特征：在经过散列后，键的顺序信息就丢失了。
推论：
    如果你想要 快速找到最大或者最小的键，或者查找某个范围内的键，或者实现 有序符号表API中的任何一个方法，
    则：散列表都不是合适的选择 - 因为使用散列表时，所有这些操作的运行时间都会是线性的。

基于拉链法的散列表的实现相对简单。
在键的顺序并不重要的应用中，它可能是最快的（也是使用最为广泛的）符号表实现。
当使用 Java的内置数据类型作为键，或者在使用 含有经过完善测试的hashCode()方法的自定义类型 作为键时，
SeparateChainingSymbolTable实现 能够提供 方便而快捷的查找和插入操作。

