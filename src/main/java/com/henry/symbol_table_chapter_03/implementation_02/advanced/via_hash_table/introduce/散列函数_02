散列函数

我们面对的第一个问题就是 散列函数的计算，这个过程会 将键 转化为 数组的索引。
如果我们有一个 能够保存M个键值对的数组，那么 我们就需要一个 能够将任意键 转化成为 该数组范围内的索引([0, M-1]范围内的整数)的散列函数。

我们要找的散列函数 应该是易于计算 并且 能够均匀分布 所有的键。
即 对于任意键， 0 到 M-1之间的每个整数 都会有 相等的可能性 与之对应（与键无关）。

这个要求似乎有些难以理解。那么要理解散列， 就要 首先 仔细思考 如何去实现 这样一个函数。

散列函数 和 键的类型有关。
严格来说，对于 每一种类型的键，我们都需要一个 与之对应的散列函数。

如果键是 一个数，比如 社会保险号，我们就可以 直接使用这个数；
如果键是 一个字符串，比如 一个人的名字，我们就需要 把这个字符串 转化成为 一个数；
如果键 包含有 多个部分，比如 邮件地址，我们需要 使用某种方法 把这些部分 结合起来。

对于许多 常见类型的键，我们可以利用 Java提供的默认实现。

我们会 简要讨论 多种数据类型的 散列函数。
你应该看看它们 是如何实现的， 因为你也需要 为自定义的类型 实现散列函数。

==
典型的例子

假设在我们的应用中，键是 美国的社会保险号。
一个社会保险号 包含有 9位数字 并且 被分为3个部分，比如 123-456-789.
第一组数字 表示 该号码的签发地区（比如035表示 罗德岛州， 214表示马里兰州）
另外两组数字 表示个人身份。

社会保险号 共有10亿个，但假设 我们的应用程序只需要处理几百个，这样 我们可以使用一个 大小M=1000的散列表。

散列表的一种实现方式是 使用 键中的三个数字：用第三组中的3个数字 看起来 比起 使用第一组中的三个数字更好（因为用户不太可能均匀分布在各个地区）。
但是下面会讲到，更好的方法 是 用所有的9个数字 得到一个整数，然后 再考虑 整数的散列函数。


==
正整数

对整数散列最常用的方法 是 除留余数法。
我们选择 大小为素数M的数组，对于任意 正整数k，计算 k除以M 所得到的余数。

这个函数的计算 非常容易（在Java中的方式是 k%M）, 并且它能够 把键 有效地散布 在0到M-1的范围之内。
如果M不是素数，我们可能 没办法利用键中所包含的所有信息 - 这可能导致 我们无法均匀地散布 散列值。

比如 如果键是10进制数，而选择的M是10^k, 那么我们就只能利用键的后k位，这样可能会产生一些问题。
具体的例子：键 是 电话号码的区号，且 M=100.
由于历史原因，美国大部分区号的中间位 都是0或者1.
所以这种方式（M=100） 会 把 大量的键 散列为 小于20的索引；
而如果使用 素数97 的话，散列值的分布 会更好一些（如果素数离100更远则效果更好）

与此类似，互联网中 所使用的IP地址 也不是随机的，所以
如果我们想使用 ”除留余数法“ 来 将其散列的话，就会 需要使用素数大小（不是2的幂）的数组；

==
浮点数
如果键是 0到1之间的实数，我们可以 ① 将它乘以M 并 ② 四舍五入 来 得到一个0到M-1之间的索引值。
尽管这个方法很容易理解，但它是有缺陷的。
因为这种情况下 键的高位 所起的作用 更大，最低位 对散列的结果没有影响。
修正这个问题的办法是 将键 表示为 二进制数，然后再 使用除留余数法； - 🐖 这就是Java所选择的处理方式

==
字符串

除留余数法 也可以处理 较长的键，比如字符串 - 我们只需要 把它当作大整数 就可以了。
比如，下面的代码 就能够 使用 除留余数法 来 计算String s的散列值：

int hash = 0;
for (int i = 0; i < s.length(); i++)
    hash = (R * hash + s.charAt(i)) % M;

Java的charAt()函数 能够返回一个 char值，也就是 一个非负的16位整数。
如果R 比起 任何字符的值 都大的话，则：这种计算 相当于 把字符串当作为 一个N位的R进制数，然后 把它除以M 并 取余。
一种叫做 Horner方法的经典算法 使用N次乘方、加法和取余 来 计算一个字符串的散列值。
只要R足够小，不会造成 溢出，那么 hash的最终结果 就会落在 0到M-1之间。
使用一个 较小的素数，比如31，就能够保证 字符串中的所有字符 都能够发挥作用。

🐖 Java中 String的默认实现 使用了一个 类似的方法。

==
组合键

如果 键的类型 包含有多个整型变量，则：我们可以 像String类型一样 来 把它们混合起来。
例如，假设 被查找的键 其类型是Date，其中包含有 多个整型的域：
    day（数字表示的日），month（两个数字所表示的月）与year（4个数字所表示的年）。
那我们可以像这样计算它的散列值：
    int hash = (((day * R + month) % M) * R + year ) % M

只要R足够小（不会造成溢出），我们就能够得到 一个 0到M-1之间的散列值。
在这种情况下 我们可以 通过选择一个适当的M值（比如31） 来 省去 括号内的%M计算。
和 字符串的散列算法 一样，这个方法 也能够 处理 任意多整型变量的类型。

==
Java的约定

每种数据类型 都需要 其所对应的散列函数，于是
Java 令 所有的数据类型 都继承了一个 ”能够返回一个32比特整数的“ hashCode()方法。

每种数据类型的 hashCode()方法的返回值 都必须 与equals()方法 保持一致；
也就是说，如果 a.equals(b) 返回true，那么 a.hashCode()的返回值 必然 与 b.hashCode()的返回值 相同。
反之，如果 两个对象的hashCode() 方法的返回值 不同，则：两个对象 是不同的；
而如果两个对象的hashCode() 方法的返回值 是相同的，则：我们需要 使用 equals()方法 来 进一步判断 两个对象是否相同。

也就是说 hashCode()方法的返回值相同 是 ”两个对象相同“的 必要不充分条件。

请注意，如果你想要 为自己定义的数据类型 来 定义散列函数，则：你需要 同时重写 hashCode() 与 equals()方法。
默认散列函数 会返回 对象的内存地址，但是只有 极少的情况 你真正会需要它。

Java为许多常用的数据类型 重写了 hashCode()方法 - 比如String, Integer, Double, File 和 URL；

==
将hashCode()的返回值 转化成为 一个数组索引

我们真正需要的是 一个数组的索引，而不是 一个32位的整数。
因此 我们在实现中会 将默认的hashCode()方法 和 ”除留余数法“ 结合起来，得到一个 0到M-1之间的整数。
代码如下：
private int hash(Key x)
{
    return (x.hashCode() % 0x7fffffff) % M;
}

这段代码会 将符号位屏蔽（也就是 把一个32位整数 变成 一个31位非负整数），然后 使用除留余数法 计算 它除以M的余数。
在 使用这样的代码 时，我们一般会 将 数组的大小M 取为素数，以便能够充分利用 原始散列值的 所有位上的数字。
🐖：为了避免混乱，我们在例子中 不会使用这种计算方法，而是使用 简化后的散列值 作为替代。

==
自定义的hashCode()方法

散列表的用例 希望使用hashCode()方法 能够 把 键 平均地散布为 所有可能的32位整数。
也就是说，对于任意对象x，你可以调用 x.hashCode() 来 预期 有均等的机会得到 2^32个不同整数中 的任意一个32位整数值。

Java中的String、Integer、Double、File和URL对象的hashCode()方法 都能够实现这一点。

而对于自定义的数据类型，你就需要自己实现这一点。
Date类型的实践 是一种 可行的方案：使用 实例变量的整数值 与 除留余数法 来 得到散列值。

在java中，所有的数据类型 都继承了 hashCode()方法。
因此还有一个更加简单的做法：把 对象的每个变量的hashCode()返回值 都转化为32位整数， 并 计算得到散列值。

示例： Transaction类；

对于 原始数据类型的对象，可以将其转化为 对应的数据类型，然后 再调用 hashCode()方法。
和之前一样，系数的具体值（在这里是31）并不是很重要。

==
软缓存

如果 散列值的计算 很耗时的话，那么 我们或许可以 将 每个键的散列值 缓存起来。
也就是 在每个键中使用一个hash变量 来 保存 它的hashCode的返回值。

第一次调用hashCode()方法时，我们 会需要计算出 对象的散列值；
但是之后 对hashCode()方法的调用 会直接返回 hash变量的值。

Java的String对象的hashCode()方法 就是用了这种方式 来 减少计算量。

总的来说，为一个数据类型所实现的 优秀的散列方法 需要满足 以下三个条件：
#1 一致性 - 等价的键 必须要能够产生 相等的散列值；
#2 高效性 - 计算简便；
#3 均匀性 - 均匀地散列所有的键。

设计 同时满足这三个条件 的散列函数 是专家的事情。
有了各种内置函数，Java程序员 在使用散列时，只需要调用 hashCode()方法即可（我们没有理由不信任它们）

但是，在 有性能要求 的时候，应该谨慎地使用散列，因为 糟糕的散列函数 经常是 性能问题的罪魁祸首：
程序可以工作，但是比起预想的慢得多。

保证”均匀性“的最好办法 也许就是 保证 键的每一位 都在 散列值的计算 中起到了作用。
实现散列函数 最常见的错误也许就是 忽略了高位。

无论 散列函数的实现 是什么，当 性能很重要 时，你应该测试 所使用的所有散列函数。
计算 散列函数 和 比较两个键，哪个耗时更多？
你的散列函数 能够将一组键 均匀地散布到 0到M-1之间吗？
使用 简单的实现 来 测试这些问题 能够预防 未来的悲剧。

如图所示，对于《双城记》，我们的hash()方法 在使用了 Java的String类型的hashCode()方法后，得到了一个 合理的分布。
图
《双城记》中每个单词的散列值的出现频率（10679个键/单词，M=97）

这些讨论的背后 是我们在使用散列时 所作出的一个 重要假设。
这个假设 是一个 我们实际上无法达到的理想模型，但是 它是我们实现散列函数时的 指导思想。