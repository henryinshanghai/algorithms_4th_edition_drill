我们说过，如果希望 把 散列表的性能 调整到最优，理解 它的内存使用情况 是非常重要的。

虽然 这种调整 是专家的事情，但是 通过估计 引用的使用数量 来 粗略计算 所需要的内存量
仍旧是 很好的练习。
具体方法：
除了 存储 键和值 所需要的空间之外，我们所实现的 SeparateChainingHashST 保存了
M个 LinkedNodeSymbolTable对象 和 它们的引用。

每个 LinkedNodeSymbolTable对象 需要16字节，
它的每个引用 都需要8个字节。
另外还有 N个node对象，每个都需要 24字节 以及 3个引用（key、value、next）- 比 二叉查找树的每个结点 都需要多一个引用。

在 使用 动态调整数组大小 来 保证 表的使用率 在1/8到1/2之间的情况下，
线性探测法 使用 4N到16N个引用。

可以看出来，使用内存用量 来 选择散列表的实现 并不容易。

对于原始数据类型，这些计算 又有所不同。

===
符号表的内存使用情况

”基于拉链法“的散列表   ~48N+32N
”基于线性探测“的散列表 在32N和~128N之间
各种二叉查找树 ~56N

从 计算机发明 伊始，研究人员 就研究了（并且现在仍在继续研究）散列表 并 找到了
很多方法 来 改进 我们所讨论过的 几种基本算法。

你能找到大量 关于这个主题的文献。
大多数改进 都能够降低 时间-空间曲线：
在 查找耗时相同 的情况下 使用更少的空间，
或者在 使用相同空间 的情况下 进行更快的查找。

其他方法包括：
#1 提供 更好的性能保证；- 比如 最坏情况下 的查找成本
#2 改进 散列函数的设计 等

拉链法 和 线性探测法的详细比较 取决于 实现的细节 和 用例对空间和时间的要求。
即使 基于性能考虑，选择拉链法 而非 线性探测法 也不一定是合理的。

在实践中，两种方法的性能差别 主要是因为 拉链法 为 每个键值对 都分配了 一小块内存，
而 线性探测法 则 为 整张表 使用了 两个很大的数组。

对于 非常大的散列表，这些做法 对内存管理系统的要求 也不相同。
在 现代的系统 中，在 性能优先的场景 下，最好 由专家 去 把握这种平衡。

