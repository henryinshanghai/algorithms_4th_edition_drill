我们说过，如果希望 把散列表的性能调整到最优，理解它的内存使用情况 是非常重要的。

虽然这种调整是专家的事情，但是 通过估计 引用的使用数量 来 粗略计算所需要的内存量
仍旧是 很好的练习。
具体方法：
除了存储 键和值 所需要的空间之外，我们所实现的 SeparateChainingHashST 保存了
M个 LinkedNodeSymbolTable对象 和 它们的引用。

每个 LinkedNodeSymbolTable对象 需要16字节，
它的每个引用 都需要8个字节。
另外还有N个node对象，每个都需要24字节以及3个引用（key、value、next）
比二叉查找树的每个结点 都需要多一个引用。

在使用动态调整 数组大小 来 保证表的使用率在1/8到1/2之间的情况下，
线性探测法 使用4N到16N个引用。

可以看出来，使用内存用量 来 选择散列表的实现 并不容易。

对于原始数据类型，这些计算又有所不同。

符号表的内存使用情况

基于拉链法的散列表   ~48N+32N
基于线性探测的散列表 在32N和~128N之间
各种二叉查找树 ~56N

从计算机发明伊始，研究人员就研究了（并且现在仍在继续研究）散列表 并找到了
很多方法 来 改进我们所讨论过的几种基本算法。

你能找到大量关于这个主题的文献。
大多数改进都能够降低 时间-空间曲线：
在查找耗时相同的情况下使用更新好的空间，
或者在使用相同空间的情况下 进行更快的查找。

其他方法包括：
#1 提供更好的性能保证；- 比如最坏情况下的查找成本
#2 改进散列函数的设计等

拉链法 和 线性探测法的详细比较 取决于 实现的细节 和 用例对空间和时间的要求。
即使 基于性能考虑，选择拉链法 而非 现象探测法 也不一定是合理的。

在实践中，两种方法的性能差别主要是因为 拉链法为每个键值对 都分配了 一小块内存，
而线性探测法 则为整张表 使用了 两个很大的数组。

对于非常大的散列表，这些做法 对内存管理系统的要求也不相同。
在现代的系统中，在性能优先的场景下，最好由专家 去 把握这种平衡。

