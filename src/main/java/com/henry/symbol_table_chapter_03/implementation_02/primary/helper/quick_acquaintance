术语统一：
在符号表中， “命中” 表示一次成功的查找；
“未命中” 表示一次失败的查找；

===
对符号表这种逻辑结构的初级实现方式

--- 使用链表 来 实现符号表 ---
原理：使用一个单向链表，链表中的每个节点中都封装着 键值对；
特征：
    #1 链表中的节点没有按照键的大小排序；
    #2 在执行查找操作时，需要沿着链表的节点 向后顺序查找；

对 基于链表实现的符号表实现的 分析：👇
    get()方法所需的平均比较次数： ~N/2
    put()方法所需的比较次数：N
    未命中的查找 所需要的比较次数：N
    命中的查找 在最坏情况下所需要的比较次数：N

向空表中插入N个不同的键 所需要的比较次数为 ~N2/2.
结论：简单来说，使用链表实现的符号表的各种操作 都是非常低效的。

--- 使用数组 来 实现符号表 ---
原理：维护一个Key数组、一个Value数组 并 建立key -> value的关系；
特征：
    #1 实现中，会维护Key数组中元素的有序性 - 从而实现 rank(key)的操作。
    #2 因为数组的有序性，因此能够快捷地实现 get操作（以及其他的便捷操作），
    #3 put()方法仍旧很慢（增长数量级为N）;
        比如在随机键条件下，构造一个 基于有序数组的符号表 所需要访问数组的次数 是 数组长度N的平方级别。

结论：对于大型应用，这种实现方式是不能被接受的。

===
Recap：
符号表初级实现的两种方式：
#1 （单向）链表：能够高效插入；
#2 有序数组：能够快速查找（二分查找）；

next: combine 链表的插入效率 & 有序数组的查找效率 -> 二叉查找树（Binary Search Tree）