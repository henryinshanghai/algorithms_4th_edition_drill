某些符号表的用例 没有处理value的需求，它们只需要 ① 把键插入到表中; ② 并检查一个键在表中是否存在。
加上 我们不允许符号表中出现 重复的键。
因此 上述操作 对应着 如下的API👇（🐖 它们只处理 表中所有键的集合，而与对应的值无关）

===
SET<Key>
SET()           构造方法，用于 创建一个空集合对象
add(key)        用于 向集合中 添加一个key
delete(key)     用于 从集合中 删除一个key
contains(key)   用于 判断 指定的key 是否存在于 集合之中
isEmpty()       用于 判断 集合是否为空
size()          用于 获取到 集合中所有键的总数量
toString()      用于 获取到 对象的字符串表示

只要① 忽略键所关联的值 或者 ② 使用一个简单的类进行封装，我们就能够
将 任何的符号表实现 变成一个 SET类的实现。

===
使用 并(union)、交（intersection）、补（complement）以及一些其他的数学几何操作
来 扩展 SET所需要的API，这样的工作 更加复杂，使用的算法 也更加有趣。
比如 complement操作 会需要 先定义出 所有可能的键的集合。

===
基于 符号表ST，SET类 可以分为 有序和无序的两个版本。
如果 键都是Comparable的，我们可以为 有序的键 来定义
min()、max()、floor()、ceiling()、deleteMin()、
deleteMax()、rankOf(key)、selectOut(ranking) 以及 需要两个参数的 size() 和 get()方法，
从而构成一组完整的API。

===
为了遵守 我们关于符号表ST的约定，我们会 在用例中：
#1 使用SET 来 表示有序的集合；
#2 使用HashSET 来 表示无序的集合；

===
为了 演示SET的使用方法，我们来 看一组 过滤器(filter)程序。
它会 从标准输入中 读取一组字符串，并将 其中的一些 给写入到“标准输入”中。
这种程序 源自于 早期”内存很小 而无法容纳所有数据“的计算机系统。
但它在今天 仍旧有用武之地 - 比如 你的程序 需要 从网络中 获取输入的时候。

在例子中，我们使用 tinyTale.txt 来 作为程序的输入。
为了 保证可读性，我们 把输入中的换行符 保留到了输出中，但 代码中 没有这么做（节省版面?）