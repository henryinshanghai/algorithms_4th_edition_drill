过滤器例子的一个原型
是一个 通过调用SET或者HashST 来 去掉输入流中的重复项的程序。
这种程序一般叫做 dedup = delete duplicates;

步骤：
#1 我们会保存一个已知字符串的集合。
#2 如果下一个键 已经存在于集合中，则：忽略这个键；
#3 如果下一个键 不在#1中的集合中，则：把它添加到集合中，并打印它。

特征：在标准输出中，键的顺序 和 它在标准输入中的顺序 相同，
只是去掉了重复的项。

这个过程需要的空间 和 输入中存在的不同键的数量（一般比起键的总量要小很多） 成正比。
代码实现：DeDup

===
白名单 和 黑名单

过滤器的另一个经典应用是
使用一个文件中所存储的键 来判定 输入流中的哪些键 可以被传递到输出流中。

这种通用的程序有很多天然的应用，最简单的例子就是 白名单。
在白名单的案例中，“文件中所存储的键” 叫做 “好键”；
用例用法#1 把所有 不在白名单上的键 传递到 标准输出中，并忽略 所有白名单上的键；
用例用法#2 把 在白名单上的键 传递到 标准输出中，并忽略 所有不在白名单上的键。

代码实现：WhiteFilter

更具体的应用案例：
电子邮件程序 能够支持 用户使用这样一个过滤器 来 指定朋友的邮件地址，
并 把所有来自其他人的邮件 当成垃圾邮件。
手段：我们可以根据指定的列表 来 构造一个HashSET，
然后 从标准输入中 读取所有的键。
如果当前键存在于集合中，则 打印它。如果不存在于集合中，则 忽略它。

黑名单案例中，“文件中所存储的键” 叫做 “坏键”。
在电子邮件的实例中，可以使用“黑名单” 来 指定垃圾邮件发送者的地址。

实际应用中，信用卡公司 使用黑名单 来 过滤 被盗信用卡号，
因特网路由器 使用白名单 来 实现防火墙。
🐖 它们所使用的名单可能非常巨大，输入无限 并且 响应时间要求非常严格。
而我们已经学习过的符号表实现 就能够满足所有这些性能要求

