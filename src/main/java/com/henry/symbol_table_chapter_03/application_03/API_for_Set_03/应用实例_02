过滤器例子的一个原型
是一个 通过 调用SET或者HashST 来 去掉 输入流中的重复项 的程序。
这种程序一般叫做 dedup = delete duplicates;

步骤：
#1 我们 会保存 一个已知字符串的集合。
#2 如果 下一个键 已经存在于集合中，则：忽略 这个键；
#3 如果 下一个键 不在#1中的集合中，则：把它 添加到 集合中，并 打印它。

特征：在标准输出中，键的顺序 和 它在标准输入中的顺序 相同，
只是去掉了重复的项。

这个过程所需要的空间 和 输入中所存在的不同键的数量（一般比起键的总量要小很多） 成正比。
代码实现：DeDup

===
白名单 和 黑名单

过滤器的 另一个经典应用 是
使用 某个文件中所存储的键 来 判断 输入流中的哪些键 可以 被传递到 输出流中。

这种通用的程序 有很多 天然的应用，最简单的例子 就是 白名单。
在 白名单的案例 中，“文件中所存储的键” 叫做 “好键”；
用例用法#1 把 所有不在白名单上的键 传递到 标准输出中，并忽略 所有白名单上的键；
用例用法#2 把 在白名单上的键 传递到 标准输出中，并忽略 所有不在白名单上的键。

代码实现：WhiteFilter

更具体的应用案例：
电子邮件程序 能够支持用户做如下操作：
① 使用这样一个过滤器 来 指定朋友的邮件地址，
② 并 把所有”来自其他人的邮件“ 当成 垃圾邮件。

实现手段：
我们可以
① 根据指定的列表 来 构造一个HashSET；
② 然后 从标准输入中 读取所有的键。
③ 如果 当前键 存在于集合中，则 打印它。如果 不存在于 集合中，则 忽略它。

在 黑名单的案例 中，“文件中所存储的键” 叫做 “坏键”。
在 电子邮件的案例 中，可以使用“黑名单” 来 指定 垃圾邮件发送者的地址。

实际应用中，信用卡公司 使用”黑名单“ 来 过滤 已经被盗用的信用卡号，
因特网路由器 使用”白名单“ 来 实现防火墙。

🐖 它们所使用的名单 可能非常巨大，输入无限 并且 响应时间 要求非常严格。
而我们 已经学习过的符号表实现 就能够满足 所有的这些性能要求

