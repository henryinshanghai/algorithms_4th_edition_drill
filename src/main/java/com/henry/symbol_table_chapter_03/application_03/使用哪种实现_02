表中总结了 由本章中多个命题和性质 所得到的 各种符号表算法的性能特点
🐖 散列表的最坏性能 除外，它的结果 来自于研究文献，并且 不太可能 在现实生活中用到。

从表中 显然可以知道，对于 典型的应用程序，应该 在 散列表 和 二叉查找树 之间进行选择。

相对于 二叉查找树，散列表的优点 在于 代码更加简单，且 查找时间最优👇
（常数级别 - 只要① 键的数据类型是标准的 或者 ② 简单到 我们可以 为它写出近似满足均匀性假设 的高级散列函数即可）

二叉查找树 相对于散列表的优点 在于 抽象结构更简单（不需要设计 散列函数），
红黑树 可以保证 最坏情况下的性能 而且 能够支持 更多的操作（排名、选择、排序和范围查找）

根据 经验法则，大多数程序员的第一选择 都是 散列表，
在 其他因素更加重要 时，才会选择 红黑树。

在第5章中，我们会遇到 这个经验法则的例外：
当 键都是长字符串 时，我们可以构造出 比起红黑树更加灵活 而 比起散列表更加高效的 数据结构。

算法/数据结构
#1 顺序查询（无序链表）；
#2 二分查找（有序数组）；
#3 二叉树查找（二叉查找树）；
#4 2-3树查找（红黑树）；
#5 拉链法（链表数组）； // 需要散列函数
#6 线性探测法（并行数组）；// 需要散列函数

我们的符号表实现 已经可以广泛应用于 各种应用程序，但是 经过简单的修改后，
这些算法还可以 适应并支持 其他一些 更广泛的应用场景，在这里有必要提一下。

===
原始数据类型

假设有一张符号表，其中 整型的键 -> 浮点型的值。
如果 使用我们的标准实现，键和值会 分别被存储在 Integer 和 Double类型中，
这样我们就会需要 两个额外的引用 来 访问每一个键值对。

如果应用程序 只会使用 几千个键 进行查找，这些引用 可能不会有什么问题。
但是如果是 对几十亿个键 进行几十亿次查找，那么 这些引用 就会造成 很大的开销。

使用 原始数据类型 来 代替Key类型 能够 为每个键值对 节省一个引用。

拉链法的内存使用情况 对比：
标准实现 VS. 原始数据类型的实现

对于 性能优先的应用程序，这种改进 并不困难 且 值得一试。

===
重复键

符号表的实现 有时候 需要专门考虑 存在重复键的可能性。
许多应用 希望能够 为同一个键 来 绑定多个值。

比如，在一个交易处理系统中，多笔交易的客户属性 都是相同的。

符号表 不允许存在 重复的键，因此用例只能 自己去管理 重复的键。
稍后会学习到一个 这样的示例程序。

我们可以考虑 在我们的实现中，允许 数据结构 能够保存 重复的键值对，
并 在查找时返回 给定的键所对应的 任意值之一。
我们也可以 加入一个方法 来 返回给定的键 所对应的所有值。

修改 我们所实现的二叉查找树 与 散列表 来 在数据结构中保存重复的键 并不困难。
修改红黑树 可能会稍有挑战。
这种实现 可以 在许多文献中找到。

===
Java标准库

Java的 TreeMap 和 HashMap 是 Java对“符号表”这种逻辑结构的实现。
它们的原理分别是：基于红黑树 和 拉链法的散列表；

TreeMap 没有直接支持 rankOf(), selectOut() 以及 有序符号表API中的一些其他方法，
但是它 支持一些个 能够高效实现这些方法的操作。
HashMap 与 LinearProbingHashST基本相同 - 它也会动态调整数组的大小 来 保持使用率不超过75%。

为了保持前后一致，我们在本书中一般使用 基于红黑树的符号表 或者 基于线性探测法的符号表。
为了节省篇幅 并 保证符号表的用例 与 具体实现的独立性（???）,
在用例代码中，将
#1 使用 ST 来代替 有序符号表RedBlackBST；
#2 使用HashST 来代替 有序性操作无关紧要&拥有散列函数的LinearProbingHashST。

尽管我们直到某些应用可能会改变或者扩展 这些算法和数据结构，我们仍旧会这样约定。

你应该要使用哪种符号表呢？
随便，只要选用的实现 能够提供所需要的性能就好。
