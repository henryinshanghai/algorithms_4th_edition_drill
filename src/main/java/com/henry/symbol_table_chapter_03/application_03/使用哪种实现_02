表中总结了 由本章中多个命题和性质 所得到的各种符号表算法的性能特点
🐖 散列表的最坏性能除外，它的结果 来自于研究文献，并且不太可能在现实生活中用到。

从表中显然可以知道，对于典型的应用程序，应该在散列表 和 二叉查找树 之间进行选择。

相对于二叉查找树，散列表的优点 在于 代码更加简单，且查找时间最优（常数级别 -
只要键的数据类型是标准的 或者 简单到 我们可以 为它写出近似满足均匀性假设 的高级散列函数即可）

二叉查找树 相对于散列表的优点在于 抽象结构更简单（不需要设计 散列函数），
红黑树 可以保证最坏情况下的性能 而且 能够支持更多的操作（排名、选择、排序和范围查找）

根据经验法则，大多数程序员的第一选择 都是散列表，
在其他因素更加重要时，才会选择红黑树。

在第5章中，我们会遇到这个经验法则的例外：
当键都是长字符串时，我们可以构造出 比起红黑树更加灵活 而 比起散列表更加高效的 数据结构。

算法/数据结构
#1 顺序查询（无序链表）；
#2 二分查找（有序数组）；
#3 二叉树查找（二叉查找树）；
#4 2-3树查找（红黑树）；
#5 拉链法（链表数组）； // 需要散列函数
#6 线性探测法（并行数组）；// 需要散列函数

我们的符号表实现 已经可以广泛引用与各种应用程序，但是经过简单的修改后，
这些算法还可以适应并支持 其他一些 更广泛的应用场景，在这里有必要提一下。

===
原始数据类型

假设有一张符号表，其中 整型的键 -> 浮点型的值。
如果使用我们的标准实现， 键和值会分别被存储在 Integer 和 Double类型中，
这样我们就会需要两个额外的引用 来 访问每一个键值对。

如果应用程序 只会使用 几千个键 进行查找，这些引用可能不会有什么问题。
但是如果是  对几十亿个键 进行几十亿次查找，那么 这些引用就会造成很大的开销。

使用原始数据类型 来 代替Key类型 可以为每个键值对 节省一个引用。

拉链法的内存使用情况对比：
标准实现 VS. 原始数据类型的实现

对于性能优先的应用程序，这种改进并不困难 且 值得一试。

===
重复键

符号表的实现 有时候 需要专门考虑 存在重复键的可能性。
许多应用 希望能够 为同一个键 来 绑定多个值。

比如，在一个交易处理系统中，多笔交易的客户属性都是相同的。

符号表不允许存在重复的键，因此用例只能自己去管理重复的键。
稍后会学习到一个这样的示例程序。

我们可以考虑在我们的实现中，允许数据结构 能够保存重复的键值对，
并在查找时返回 给定的键所对应的 任意值之一。
我们也可以加入一个方法 来 返回给定的键所对应的所有值。

修改 我们所实现的二叉查找树与散列表 来 在数据结构中保存重复的键 并不困难。
修改红黑树 可能会稍有挑战。
这种实现可以在许多文献中找到。

===
Java标准库

Java的 TreeMap 和 HashMap 是 Java对“符号表”这种逻辑结构的实现。
它们的原理分别是：基于红黑树和拉链法的散列表；

TreeMap没有直接支持 rankOf(), selectOut() 以及 有序符号表API中的一些其他方法，
但是它支持一些个 能够高效实现这些方法的操作。
HashMap 与 LinearProbingHashST基本相同 - 它也会动态调整数组的大小 来 保持使用率不超过75%。

为了保持前后一致，我们在本书中一般使用 基于红黑树的符号表 或者 基于线性探测法的符号表。
为了节省篇幅 并 保证符号表的用例 与 具体实现的独立性（???）,
在用例代码中，将
#1 使用 ST 来代替 有序符号表RedBlackBST；
#2 使用HashST 来代替 有序性操作无关紧要&拥有散列函数的LinearProbingHashST。

尽管我们直到某些应用可能会改变或者扩展 这些算法和数据结构，我们仍旧会这样约定。

你应该要使用哪种符号表呢？
随便，只要选用的实现 能够提供所需要的性能就好。
