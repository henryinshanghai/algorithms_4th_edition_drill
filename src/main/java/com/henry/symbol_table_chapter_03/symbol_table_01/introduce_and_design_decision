符号表
是：一种逻辑上(抽象)的数据结构；
作用：把一个键 与 一个值 关联起来；
用法：#1 用例把一个键值对 插入到复符号表中； #2 用例使用指定的键，从符号表中找到其关联的值；
常见应用：
    #1 字典；
    #2 图书索引（？）；
    #3 文件共享；
    #4 账户管理；
    #5 网络搜索；
    #6 编译器；


API：符号表作为数据结构，所提供的行为；
#1 构造函数 - 用于创建一个符号表对象；
#2 put(key, value) - 用于把键值对 添加到符号表中
#3 get(key) - 用于从符号表中，使用指定的key找到 它所关联的值；
#3 delete(key) - 用于从符号表中，删除指定的键对应的键值对；
#4 contains(key) - 用于指示 符号表中是否存在指定的key；
#5 isEmpty() - 用于指示 符号表是否为空；
#6 size（） - 用于获取 符号表中的键值对数量；
#7 keys() - 用于获取 符号表中所有键值对的 键的集合；


--- 设计决策 ---
#1 泛型；- 处理任意类型的键&值；
#2 是否允许符号表中存在重复的键？ - 不允许存在。 因此如果put(key, new_value)，则：会更新key对应的值；
#3 是否允许 null键？ - 不允许；
#4 是否允许 null值？ - 因为null值 被用来判断指定的key 在符号表中是否存在了，因此不能将它作为有效的值
#5 删除操作的两种实现方式：
    put(key, null) - 这是一种延迟删除的方式；
    delete(key) - 这是一种实时删除的方式；
#6 便捷方法；- 作用：使得用例的代码能够更清晰、易读； 特征：其实是冗余方法 aka 没有这些方法，仍旧能够用更复杂的代码来实现用例
    contains(key)
    isEmpty()
#7 对迭代的支持；
    手段1：符号表本身实现 Iterable接口 - 作用：强制要求类型本身返回迭代器；
    手段2：定义keys()方法 - 作用：返回表示符号表中所有键的 Iterable<Key> 对象；
#8 键的等价性；
    Ⅰ 自定义的键 需要重写equals()方法；
    Ⅱ 最好使用不可变的数据类型作为键。

有序符号表：
键值对中的键 是可比较的键，因此 可以在符号表中维护键的有序性。
作用：有序性能够带来很多遍历 - 比如用来更好地实现put()与get()方法、用于扩展符号表的API等
手段： <Key extends Comparable<Key>, Value>

-- 由于键的有序性而新增的API --
#1 最大键&最小键；
#2 向下取整（小于等于指定键的最大键）&向上取整（大于等于指定键的最小键） - 用于支持一些其他更复杂的操作；
#3 获取指定键的排名 rank(key)（指定键在键集合中的排定 aka 小于指定键的键的数量）& 选择指定排名的键 select(rank)（N-th kay）;
    推论：ranking-th = rank(select(ranking-th))
#4 获取指定范围内的键集合；
    手段：#1 size(key01, key02); #2 keys(key01, key02);

约定：如果某个方法需要返回一个键，但是符号表中没有合适的键可以返回时，符号表的实现会抛出一个异常。

便捷方法👇
    deleteMin() - 用于从符号表中删除最小键
    deleteMax() - 用于从符号表中删除最大键
    size(key01, key02) - 用于返回[key01, key02]范围内的键的数量
    keys() - 用于返回符号表中，键的集合
    特征：所有的快捷方法 都会委托到其他方法来作为自己的默认实现。

-- 键的等价性：如何定义 key01 等于 key02? --
Java提供的最佳实践：对于所有Comparable的类型，它的compareTo()方法 与 equals()方法要保持一致。
aka key01.compareTo(key02) 的返回值 与 key01.equals(key02)的返回值 必须相同。

约定：为了避免二义性，在我们的符号表的实现中，只会使用 compareTo()来比较两个键。

-- 成本模型（cost model） --
对于大多数的符号表实现来说，它的内循环（执行最频繁的Java指令）中的主要操作是 比较操作。
少数符号表的实现，其内循环的主要操作是 访问数组；

因此，在分析符号表的实现时，我们会主要统计比较发生的次数。

-- 实现符号表的重点：所使用的数据结构 & get()&put()方法的实现 --
符号表： symbol table;
使用某种方式实现的符号表：<xxx>SymbolTable;

符号表的应用（用例）：
#1 用于 跟踪某个算法在小规模输入下的行为 - 行为测试；
#2 用于 对某种算法的实现做性能测试 - 从而帮助找到更加高效的实现。