当可以在文本字符串中回退时，
如果可以 从右向左扫描 模式字符串，并把它和文本相匹配，就 得到了一种 非常快的 字符串查找算法。

比如，在查找子字符串 B A A B B A A时，
如果 匹配了第7个和第6个字符，但是在第5个字符处匹配失败，
则 马上就可以把模式向右移动7个位置，并 继续检查 文本中的第14个字符。
这是因为 部分匹配 找到了 X A A，而X不是B，并且这三个连续的字符 在模式中是唯一的。

一般来说，模式的结尾部分 也可能出现在 文本的其他位置，
所以 和KMP算法一样，也会需要 一个用于记录重启位置的数组。

这里不会再次 详细介绍 它的构造方法，因为 它和KMP算法中的实现很相似。
这里会讨论 Boyer 和 Moore给出的 另一种 从右向左 扫描模式字符串的更有效的方法。

和 KMP子字符串查找算法的实现一样，我们会
根据匹配失败时，文本和模式的字符 来 决定下一步的行动。
而 预处理步骤的作用在于
判断对于“文本中可能出现的每一个字符”，在匹配失败时，算法该怎么办？

把这个想法变成现实 就可以得到 一种高效实用的子字符串查找算法。






