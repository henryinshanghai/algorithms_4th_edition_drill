当 可以 在 文本字符串 中回退 时，
如果可以 从右向左地 扫描 模式字符串，并 把 它 和 文本 相匹配，就 得到了一种 非常快的 字符串查找算法。

比如，在 查找子字符串 B A A B [B] A A时，
如果 匹配了 第7个和第6个字符，但是 在第5个字符处 匹配失败，
则 马上就可以 把模式 向右移动 7个位置，并 继续检查 文本中的第14个字符。
这是因为 部分匹配 找到了 X A A，而X不是B，并且 这三个连续的字符 在模式中 是唯一的。

一般来说，模式的结尾部分 也可能出现在 文本的其他位置，
所以 和KMP算法一样，也会需要 一个用于 记录“重启位置”的数组。

这里不会再次 详细介绍 它的构造方法，因为 它和KMP算法中的实现很相似。
这里会讨论 由Boyer 和 Moore所给出的 另一种 从右向左（backwards） 扫描 模式字符串 的更有效的方法。

和 KMP子字符串查找算法的实现 一样，我们会
根据 匹配失败 时，文本和模式的字符 来 决定 下一步的行动。
而 预处理步骤 的作用 在于
判断 对于“文本中可能出现的每一个字符”，在 匹配失败 时，算法 该怎么办？

把 这个想法 变成现实 就可以得到 一种高效实用的 子字符串查找算法。
