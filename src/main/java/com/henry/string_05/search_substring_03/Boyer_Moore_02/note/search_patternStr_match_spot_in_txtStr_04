===
子字符串的查找

在计算完 right[]数组之后，算法5.7的实现 就简单了。
我们用一个索引i 在文本中从左向右移动，
用另一个索引j 在模式中从右向左移动。

内循环会检查 正文和模式字符串 在位置i是否一致。
如果从M-1到0的所有j，txt.charAt(i+j) 都和 pat.charAt(j)相等，
那么就找到了 一个匹配。
否则匹配失败，就会遇到以下三种情况👇
#1 如果造成匹配失败的文本字符 不包含在模式字符串中，说明在此之间的字符不会产生任何的匹配，则：将模式字符串 向右移动j+1个位置（也就是把i增加j+1）。
    小于这个偏移量 只可能使该字符 与模式中的某个字符 重叠。
    实际上，这次移动也会将 模式字符串前面 一部分已知的字符 和 模式结尾的一部分 已知字符对齐。

    通过预先计算一张类似于 KMP算法的表格，还可以 将i值变得更大。

#2 如果 造成匹配失败的文本字符 包含在模式字符串中，说明它可能与模式字符串产生新的匹配，则：可以使用right[]数组 来 把“模式字符串的失配字符” 与“文本字符串中的失配字符”对齐，
    使得 该字符 和 它在模式字符串中出现的最右位置 相匹配。
    和刚才一样，小于这个偏移量 只可能使 该字符 和 模式中的与它无法匹配的字符（比起 它出现的最右位置 更加靠右的字符）重叠。
    我们可以使用一张类似于 KMP算法的表格 来 把i的值变得更大。

#3 如果这种方式无法增大i，那么 就直接把i+1 来 保证模式字符串 至少向右移动一个位置。

===
算法5.7简明地实现了这个过程。
请注意，使用-1 表示 right[]数组中的字符 没有被包含在模式字符串中，
这个约定 能够把 前两种情况合并 - 把i增大 j-right[txt.charAt(i+j)]

== 算法5.7 VS. 完整的BM算法 ==
完整的Boyer-Moore算法 预计算了 模式字符串与自身的 不匹配情况（这一点 与KMP算法的方式类似），
并且 为最坏的情况提供了 线性级别的运行时间保证（而算法5.7 在最坏情况下 的运行时间 与NM成正比）

我们在这里省略了 算法的计算，因为 在一般的应用程序中，对“不匹配字符”的启发式处理 就已经可以控制 算法的性能了。