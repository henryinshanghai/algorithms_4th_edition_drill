===
子字符串的查找

在 计算完 right[]数组 之后，算法5.7的实现 就简单了。
我们 用一个索引i 在文本中 从左向右移动，
用 另一个索引j 在模式中 从右向左移动。

内循环 会检查 正文 和 模式字符串 在位置i处 是否一致。
如果 从M-1到0的 所有j，txt.charAt(i+j) 都 和 pat.charAt(j) 相等，
那么 就找到了 一个匹配。
否则 匹配失败，就会遇到 以下三种情况👇
#1 如果 造成匹配失败的文本字符 不包含在 模式字符串中，说明 在此之间的字符 不会产生 任何的匹配，则：
    将 模式字符串 向右移动 j+1个位置（也就是 把i增加j+1）。

    说明：小于 这个偏移量 的话，只可能 使该字符 与 模式中的某个字符 重叠。
        实际上，这次移动也会将 模式字符串前面 一部分已知的字符 和 模式结尾的 一部分已知字符 对齐。

    通过 预先计算 一张 类似于KMP算法的表格，还可以 将i值 变得更大。

#2 如果 造成匹配失败的文本字符 被包含在 模式字符串中，说明它 可能 与模式字符串 产生新的匹配，则：
    可以 使用 right[]数组 来 把“模式字符串的失配字符” 与 “文本字符串中的失配字符” 相对齐，
    使得 该字符 和 它在模式字符串中出现的最右位置 相匹配。

    说明：和刚才一样，小于这个偏移量 只可能使 该字符 和 模式中的与它无法匹配的字符（比起 它出现的最右位置 更加靠右的字符）重叠。
    我们 可以使用 一张 类似于 KMP算法的表格 来 把i的值 变得更大。

#3 如果 这种方式 无法增大i，那么 就直接 把i+1 来 保证模式字符串 至少 向右移动 一个位置。

===
算法5.7 简明地实现了 这个过程。
请注意，使用-1 来 表示 right[]数组中的字符 没有被包含 在模式字符串中，
这个约定 能够把 前两种情况合并 - 把i增大 j-right[txt.charAt(i+j)]

== 算法5.7 VS. 完整的BM算法 ==
完整的Boyer-Moore算法 预计算了 模式字符串与自身的 不匹配情况（这一点 与KMP算法的方式类似），
并且 为最坏的情况 提供了 线性级别的运行时间保证（而算法5.7 在最坏情况下 的运行时间 与NM成正比）

我们在这里省略了 算法的计算，因为 在 一般的应用程序 中，对“不匹配字符”的启发式处理 就已经可以 控制 算法的性能了。