===
启发式地 处理 不匹配的字符

如图，显示了 F I N D I N' A H A Y S T A C K N E E D L E 中 查找 模式 N E E D L E 的过程。

因为是 从右向左 与模式 进行匹配，所以
#1 首先 会比较 模式字符串中的E 和 文本中的N（位置5的字符）。
因为N 也出现在了 模式字符串 中，所以 把 模式字符串 向右移动5个位置 来 把文本中的字符N 和 模式字符串最左侧的N 对齐。
 txt_cursor  txt_cursor'
    |          |
    F I N D I [N] A H A Y S T A C K N E E D L E
    [N] E E D L E
    |           |
last_occur pat_cursor
               N E E D L E
                         |
                       pat_cursor'
#2 然后比较 模式字符串最右侧的E 和 文本中的S（位置10的字符）。
匹配失败，但因为S 不被包含在 模式字符串 中，所以 可以 把 模式字符串 向右移动6个位置。
这时 模式字符串最右侧的E 和 文本中位置为16的E 相匹配。
但是 文本的下一个位置上的字符N(向左) 与 模式字符L（向左）不相同，所以匹配 再次失败。
          txt_cursor    txt_cursor'
              |             |
    F I N D I N A H A Y [S] T A C K N' E E D L E
    N E E D L E
              N E E D L [E]
                         |
          <no_occur>  pat_cursor
                            N E E D L' E
                                       |
                                    pat_cursor'
#3 把 模式字符串 再次向右移动 4个位置。
    最后 从位置20处 开始 从右向左扫描，发现 文本中含有 与模式字符串相匹配的 子字符串。
                      txt_cursor txt_cursor'
                          |        |
    F I N D I N A H A Y S T A C K [N] E E D L E
    N E E D L E
              N E E D L E
                          [N] E E D L E
                           |        |
                     last_occur  pat_cursor
                                  N E E D L E
                                            |
                                          pat_cursor'

总结 以上过程 可得：
当 发生字符不匹配的情况 时，通过 找到'文本字符' 在’模式字符串‘中 第一次出现的位置，
就能够 进一步地 把 txt_cursor 移动 (pat_cursor - last_occur)个位置 来 实现 对此 ‘失配字符’ 的重新匹配。

在此基础上，匹配过程 会再度 从后往前地 进行。
compare (txt_cursor + pat_cursor) of txt_str with (pat_cursor) of pattern_str;

这种方法 最终找到了 发生匹配的位置，并且 仅仅使用了4次字符比较（以及 6次比较 来 验证 是否匹配）！