引用：https://www.bilibili.com/read/cv7840014/?spm_id_from=333.999.0.0

朴素算法：当 在某一个位置，文本字符 与 模式字符 匹配失败 时，
指向文本字符的指针i 与 指向模式字符的指针j 都需要 回到 状态0.

KMP算法：
我们可以 不回退 文本指针，并 把 模式字符指针 回退到 一个正确的位置 上。
我们 把 这个正确的位置 叫做 “重启状态”。

基础算法中，每次 匹配失败 时，我们都会 把 模式字符串 右移一位 来 继续进行 字符串之间的匹配。

== 重启状态X ==
如果：文本字符串 与 模式字符串的 [0, i-1]这些位置都 匹配成功了，但是 在第i个位置上 字符 匹配失败。
这时候，我们：
#1 把 模式字符串 右移一位 来 使用 模式字符串 继续匹配 文本字符串的[1, i-1]上的子字符串；
#2 并且 已知 txt[1..i-1] <=> pat[1..i-1]；
则：由 状态0 从 pat[1] 一直匹配到 pat[i-1] 所得到的“状态转移结果” 就会是 位置i的重启状态。

用法：
#1 i+1的重启状态，可以使用 i的重启状态 匹配 位置i上的字符 来 得到；
#2 位置1的重启状态（由于去掉了位置0）的值 和 位置0的重启状态 相同；

== X的推论 ==
设 X 为 重启状态，
spot_j 表示 模式字符串的位置j，
current_character 表示 当前位置上 可能出现的 当前字符
dfa[current_character][spot_j] 表示 模式字符串 在位置j上的字符 匹配 current_character字符 后，模式字符的指针 所应该转移到的 状态/跳转到位置；

则：
#1 对于 模式字符串的位置j，它总是会 与 位置j上的字符 匹配成功，则：
dfa[pat[j]][j] = j+1 // 匹配成功后，跳转到 模式字符串的下一个位置

#2 递推公式 X(i) = dfa[pat[i-1]][X(i-1)]
位置i的重启状态 = 位置（i-1）的重启状态 所对应的位置上的字符，匹配 模式字符串的(i-1)的字符 后，所跳转到的 位置；

