引用：https://www.bilibili.com/read/cv7840014/?spm_id_from=333.999.0.0

朴素算法：当在某一个位置，文本字符与模式字符匹配失败时，
指向文本字符的指针i 与 指向模式字符的指针j 都需要回到状态0.

KMP算法：
我们可以不回退文本指针，并把 模式字符指针回退到一个正确的位置上。
我们把这个正确的位置 叫做 “重启状态”。

基础算法中，每次匹配失败，我们都会把模式字符串右移一位 来 继续进行 字符串之间的匹配。

== 重启状态X ==
如果：文本字符串 与 模式字符串的0~i-1位置都匹配成功了，但是 在第i个位置上 字符匹配失败。
这时候，我们：
#1 把模式字符串右移一位 来 使用模式字符串 继续匹配 文本字符串的[1, i-1]上的子字符串；
#2 并且已知 txt[1..i-1] <=> pat[1..i-1]；
则：由状态0 从pat[1]一直匹配到pat[i-1]所得到的“状态转移结果” 就是 位置i的重启状态。

用法：
#1 i+1的重启状态，可以使用 i的重启状态 匹配位置i上的字符来得到；
#2 位置1的重启状态（由于去掉了位置0）的值 和位置0的重启状态相同；

== X的推论 ==
设X为重启状态，
spot_j 表示模式字符串的位置j，
current_character 表示 当前位置上可能出现的当前字符
dfa[current_character][spot_j] 表示 模式字符串在位置j上的字符 匹配 current_character字符后，模式字符的指针 所应该转移到的状态/跳转到位置；

则：
#1 对于模式字符串的位置j，它总是会与位置j上的字符匹配成功，则：
dfa[pat[j]][j] = j+1 // 匹配成功后，跳转到 模式字符串的下一个位置

#2 递推公式 X(i) = dfa[pat[i-1]][X(i-1)]
位置i的重启状态 = 位置（i-1）的重启状态对应的位置上的字符，匹配 模式字符串的(i-1)的字符后，所跳转到的 位置；

