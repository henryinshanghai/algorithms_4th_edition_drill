DFA 应该 如何处理 下一个字符?
和 回退时的处理方式 相同，除非 在 pat.charAt(j)处 匹配成功，这时 DFA 应该 前进到 状态j+1；

比如，对于 A B A B A C，
如果 想要判断 j=5时 匹配失败 后，DFA 应该怎么做。
通过DFA 就可以知道 在 完全回退 之后，算法 会扫描 B A B A，并 到达 状态3.
所以我们 可以：
#1 把 dfa[][3] 复制到 dfa[][5]；
#2 把 C对应的dfa[][]元素值 设置为6 = 5+1；因为 C 是 “模式字符串” 在当前位置上的字符

关键判断：字符 是不是 模式字符串 在当前位置上的字符？

因为 在 计算DFA的 第j个状态 时，只需要知道 DFA是 如何处理 前j-1个字符的，
所以 总能够从 “尚不完整的”DFA中 得到所需的信息。

观察到的 最后一个关键细节 是，你可以 观察到 在 处理dfa[][]的第j列 时，维护 “重启位置X” 会 很容易。
因为 X<j, 所以 可以使用 已经构造出的DFA部分 来 完成这个任务 —— X的下一个值 是 dfa[pat.charAt(j)][X].
继续 上一段的例子，把 X的值 更新为 dfa[C][3]=0（但是我们 不会使用 这个值，因为DFA的构造 已经完成了）

代码重现：
想象在 模式字符串 上，存在有 一个指针 - 它 根据 匹配的情况 在模式字符串上 跳来跳去👇
next_spot = dfa[character_option][current_spot] // 模式指针 会跳转到的位置
current_spot // 模式指针 当前指向的位置
its_restart_spot // ???

character_option MATCH character of current_spot in pattern string.

dfa[pat.charAt(0)][0] = 1;

for(int restart_spot = 0, current_spot = 1; current_spot < M; current_spot++) {
    for(int current_character = 0; current_character < R; current_character++) {
        dfa[current_character][current_spot] = dfa[current_character][restart_spot];
    }

    // 如果 字符 是“模式字符串的当前字符”，说明 指针 应该移动到 下一个位置，则：dfa[][]=j+1
    dfa[pat.charAt(current_spot)][current_spot] = current_spot+1;

    restart_spot = dfa[pat.charAt(current_spot)][restart_spot];
}
