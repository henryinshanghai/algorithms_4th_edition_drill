===
数学原理

Rabin-Karp算法的基础是👇
对于所有位置i，使用一种手段 来 高效计算 文本中(i+1)位置上的子字符串的散列值。
这可以由一个简单的数学公式得到。

我们使用(ti)来表示 txt.charAt(i)，则：
文本txt中起始于位置i的、含有M个字符的子字符串 所对应的数字 即为👇
xi = (ti)(R^(M-1))+(ti+1)(R^(M-2))+...+(ti+(M-1))(R^0) // xi表示字符串的hash值

假设已知 h(xi)=xi mod Q。 // Q是一个很大的素数
把模式字符串右移一位 就等价于 把xi替换为：
x(i+1) = (xi - (ti)(R^(M-1))*R + (ti+M)

也就是#1 把它减去第一个数字(startCharacter)的值，#2 乘以R，#3 再加上 最后一个数字(endCharacter)的值。

现在，关键的一点在于 我们并不需要保存这些数的值，而只需要 保存 它们除以Q之后的余数。

===
取余操作的一个基本性质是👇
如果在每次算术操作之后，都 将结果除以Q之后的余数[这不是个结论，一定遗漏了一些内容???]
曾经在用Horner方法（3.4.1.4节）实现 除留余数法时，就利用过这个性质。👆

好处/特征：这么做的结果就是 无论M是5、100还是1000，都可以在常数时间内、高效地不断地向右一格一格地移动。
