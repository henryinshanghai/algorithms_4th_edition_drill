Rabin和Karp 发明了一种 完全不同的 基于散列的 字符串查找算法。
我们需要：
#1 计算 模式字符串的散列函数，
#2 使用相同的散列函数 来 计算文本中所有可能的M个字符 所组成的子字符串 的散列值 并 寻找匹配；

如果找到了一个 散列值与模式字符串相同 的子字符串，则：再进一步验证 两者是否匹配。
这个过程 等价于：
#1 把 模式 保存在了 一张散列表中；
#2 然后 在文本的所有子字符串中 进行查找。

但不需要为符号表预留任何空间，因为它只会含有一个元素。

根据这段描述 来 直接实现的算法 将会 比暴力子字符串查找算法 慢得多
（因为计算散列值 将会涉及 字符串中的每个字符，成本比起 直接比较这些字符 要高得多）。

Rabin 和 Karp发明了一种 能够在常数时间内，算出 M个字符的子字符串散列值 的方法
（需要预处理），这样就得到了 在实际应用中的运行时间为 线性级别的 字符串查找算法。

===
基本思想

长度为M的字符串 对应着 一个R进制的M位数。
为了用一张 大小为Q的散列表 来 保存这种类型的键，需要一个
能够将 R进制的M位数 转化为 一个[0, Q-1]的int值 的散列函数。

除留余数法（请见3.4节）是一个很好的选择：将该数 除以Q并取余。
在实际应用中，会使用一个 随机的素数Q，在不溢出的情况下，选择一个尽可能大的值。
（因为我们并不会真的需要 一张散列表。）

理解这个方法的 最简单的办法 就是: 取一个较小的Q 和 R=10的情况，如下所示。

如果想要 在文本 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 中，找到模式 2 6 5 3 5,
首先：#1 要选择 散列表的大小Q（在这个例子中是997），则：26535 % 997 = 613，
然后#2 计算文本中 所有“长度为5个数字的子字符串” 的散列值，并 #3 寻找匹配。

在这个例子中，在找到613的匹配之前，得到的散列值 分别为508、201、715、971、442和929，如图。
图略
