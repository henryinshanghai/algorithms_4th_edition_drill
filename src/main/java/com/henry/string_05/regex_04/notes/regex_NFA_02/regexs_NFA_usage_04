图5.4.3的例子说明👇
即使对于 类似于 A A A A B D 这种 NFA本应该能够识别的 输入文本，
也能够找到一个 使NFA停滞的 状态转换序列。

比如，如果 NFA 选择 在 扫描完所有A 之前，就转换到了 状态4，那么 它就无法再 继续前进了👇
因为 离开状态4的 唯一办法 只有匹配B。

这两个例子 说明了 这种自动机的不稳定性。
在 扫描了一个A，并 到达状态3 之后，NFA 面临了 两个选择👇
#1 它可以 转换到 状态4；
#2 或者 回到 状态2.

这次选择
#1 或者会 使它最终达到 接收状态（第一个例子）；
#2 或者 进入到 停滞状态（第二个例子）。

NFA在 状态1 时，也需要 进行选择（是否 经由∈-转换 到达状态2 或者 状态6）

这个例子 说明了 NFA 和 DFA之间的关键区别：
因为 在NFA中 离开一个状态 所需的转换 可能有多种，因此
从 当前状态 可能进行的转换 是不确定的👇
即使 不扫描 任何字符，它在不同的时间 所进行的状态转换 也可能是 不同的。

为了使 这种自动机的运行 有意义，所设想的NFA 必须要 能够猜测
对于 给定的文本，需要进行 哪种转换（如果有的话）才能够 最终到达 接收状态。

换句话说，
#1 当且仅当 一个NFA👉 ① 从 状态0 开始，从头读取了 一段文本中的所有字符，② 进行了 一系列的 状态转换 ③ 并 最终到达了 接收状态 时，
才称：该NFA 识别了一个 文本字符串。

#2 相反，当且仅当 对于一个NFA，不存在有 任何 由 匹配转换 和 epsilon转换 所组成的转换序列 能够 ① 扫描 所有文本字符，② 并 到达接受状态 时，
才称：该NFA 无法识别 这段文本字符串。

和DFA一样，这里 只要列出 所有状态的转换，就能够 跟踪 NFA处理文本字符串的轨迹。
任何类似的 结束于最终状态的 转换序列 都能够证明 某个自动机 识别了 某个字符串（也可能存在有其他的证明）。

但是对于 一段给定的文本，应该如何找到 这样一个序列呢？
对于 另一段给定的文本，我们 应该如何证明 不存在 这样一个序列呢？
这些问题的答案 比你想象的要简单 - 系统地尝试 所有的可能性！