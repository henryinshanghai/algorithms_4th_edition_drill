根据 正则表达式 与 大家所熟悉的算术表达式 的相似性，你肯定不会惊讶于
把 正则表达式 转换为 NFA的过程，在某种程度上 类似于1.3节中，使用 Dijkstra的双栈算法 对表达式求值 的过程。

两个过程的不同之处 在于👇
#1 正则表达式中的 连接操作，不存在有 其所对应的运算符；
#2 正则表达式中的 闭包（*）操作，对应的是一个 一元运算符；
#3 正则表达式 只有一个二元运算符，也就是 或操作 所对应的运算符 |

我们不会 在 两者的不同和相似之处 深究，而是会 学习一种 为正则表达式量身定做的 实现。
该实现 只需要 一个栈，而不是 两个。

根据 上一小节开头讨论的 NFA表示，我们只需要构造出一个 由所有∈-转换所组成的 有向图G。
正则表达式本身 和 在本节开头学习过的形式定义，就足以提供 所需要的全部信息。

根据Dijkstra算法，我们 会使用一个栈 来 记录所有 ① 左括号 与 ② 或运算符 的位置。