===
#1 连接操作

对于NFA，连接操作 是最容易实现的。
状态的匹配转换 和 字母表中的字符 之间的对应关系，就是 连接操作的实现；

===
#2 括号
我们需要 把 正则表达式字符串中的 所有左括号的索引 都压入栈中。
当 我们遇到 一个右括号 时，我们都会用到 后文所述的方式 把 左括号 从栈中弹出。

和Dijkstra算法一样，栈这种数据结构 可以 很自然地处理 嵌套的括号。

===
#3 闭包操作
闭包运算符* 只可能出现在
① 单个字符 之后 - 对于这种情况，我们会 在 此字符 与 * 之间 添加上 相互指向的两条∈-转换；
② 右括号 之后 - 对于这种情况，我们会 在 对应的左括号（栈顶元素） 和 * 之间 添加上两条 相互指向的∈-转换；

===
#4 或表达式
在 像是(A|B)的正则表达式 中，A与B 也都是 正则表达式。
我们的处理方式 是 添加上 两条∈-转换：
① 从 左括号所对应的状态 指向 B中第一个字符 所对应的状态 的 一条∈-转换；
② 从 |字符所对应的状态 指向 右括号 所对应的状态 的 一条∈-转换；

把 正则表达式字符串 中 |运算符的索引（以及 左括号的索引） 压入到 栈中，
这样 到达右括号的时候，所有需要的信息 都会出现在 栈的顶部。

这些∈-转换 使得 NFA能够 在这两者之间 进行选择。
此时并没有 像平常一样 添加一条 从 |运算符所对应的状态 指向 下一个字符所对应状态 的∈-转换👇
NFA离开 或运算符的唯一方式 就是 通过某种状态转换 到达 右括号所对应的状态。