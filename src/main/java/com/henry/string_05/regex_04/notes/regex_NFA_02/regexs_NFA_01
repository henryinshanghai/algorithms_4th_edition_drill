我们可以将 KMP算法 看作一台  由模式字符串所构造的 能够扫描文本字符串的 有限状态自动机。
对于 正则表达式，我们要将 这个思想 推而广之。

KMP的有限状态自动机 会根据 文本中的字符 来 改变 自身的状态。
当且仅当 自动机 到达 停止状态时 ，它才 找到了一个匹配。

算法本身就是 模拟这种自动机，
这种自动机的运行 容易模拟的原因 是因为 它是“确定性”的👇
每种状态的转换 都完全 由 文本中的字符 所决定。

要处理 正则表达式，就需要一种 更加强大的抽象自动机。
因为 或操作的存在，自动机 无法仅仅根据一个字符 就判断出 模式是否出现；
由于 闭包的存在，自动机甚至 无法知道 需要检查多少个字符 才会出现 匹配失败。

为了 克服这些困难，我们需要使用 “非确定性”的自动机👇
当 面对 匹配模式的多种可能 时，自动机能够 猜出 正确的转换！

你可能觉得 这种能力 是 不可能的，但是你会看到，
编写一个程序 来
#1 构造 非确定有限状态自动机（NFA），
#2 并 有效模拟 它的运行
是非常简单的。

正则表达式模式匹配程序 的总体结构 与 KMP算法的总体结构 几乎相同：
#1 构造 和 给定正则表达式 相对应的 非确定有限状态自动机；
#2 模拟NFA 在 给定文本 上的运行轨迹。

Kleene定理 是 理论计算科学中的一个重要结论，它 证明了
对于 任意正则表达式，都存在有一个 与之对应的 非确定有限状态自动机（反之亦然）。

我们会👇
#1 学习 该定理的证明，并
#2 演示如何 将 任意正则表达式 转换成为 一台非确定有限状态自动机；
#3 然后 模拟NFA的运行轨迹 来 完成模式匹配的任务；