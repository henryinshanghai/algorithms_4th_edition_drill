===
NFA的模拟 与 可达性

为了模拟 NFA的运行轨迹，我们会记录 自动机在检查“当前输入字符”时，“所能够转移到的 所有状态”的集合。
这里，关键的计算 是  我们 已经 在算法4.4中解决了的 多点可达性问题。

#1 我们会 查找所有 从 状态0 “通过∈-转换可以到达”的所有状态 来 “初始化”这个集合👆

#2 对于 集合中的每个状态，检查 它是否能够 与 “第一个输入字符” 相匹配。
检查并匹配 之后，就得到了
① NFA在 匹配第一个字符 之后，所能到达的 所有状态的集合 - 匹配转换。
② 这里还需要 向集合中加入  所有 从 该集合中的任意状态，“通过∈-转换 可以到达”的其他状态 - ε转换。

#3 有了这个 匹配了第一个字符之后 所可能到达的 所有状态的集合 后，
∈转换有向图中 的多点可达性问题的答案 就是 可能匹配“第二个输入字符”的集合状态。

例如，在示例NFA中 初始状态集合 为 {0, 1, 2, 3, 4, 6}，
如果 第一个输入字符是A，那么 NFA 就能够使用 匹配转换，匹配转换 所可能达到的所有状态 是{3, 7},
然后 NFA可能进行 3到2 或者 3到4的 ∈转换，
因此 与第二个字符匹配的状态集合 为{2, 3, 4, 7}。

#4 重复这个过程，直到文本结束。最终可能得到 两种结果：
① 所有 能够到达的所有状态 中，包含有 接受状态；
② 所有 能够到达的所有状态 中，不含有 接受状态。

第一种结果 说明：存在有 某种转换序列，使得NFA 能够到达 接受状态；
第二种结果 说明：对于此输入，NFA 总是会 停滞，从而导致 匹配失败。

使用 ① SET数据类型 与 ② 用于 在有向图中 解决多点可达性问题的 DirectedDFA类，
我们可以 用如下的代码 来 表示如上的描述。

可以使用下图 来 检查 你对这段代码的理解，它显示了 样例输入的完整轨迹。
(图略)

使用 ((A*B|AC)D)正则表达式字符串的NFA 来 处理 对于输入 A A B D的模拟👆
