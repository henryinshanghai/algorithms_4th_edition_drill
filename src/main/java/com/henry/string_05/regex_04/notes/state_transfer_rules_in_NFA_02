我们可以将KMP算法 看作一台  由模式字符串构造的 能够扫描文本的 有限状态自动机。
对于正则表达式，我们要将这个思想 推而广之。

KMP的有限状态自动机 会根据 文本中的字符 改变自身的状态。
当且仅当 自动机到达停止状态时，它才找到了一个匹配。

算法本身就是模拟这种自动机，
这种自动机的运行 容易模拟的原因是因为 它是“确定性”的👇
每种状态的转换 都完全 由文本中的字符所决定。

要处理正则表达式，就需要一种 更加强大的抽象自动机。
因为 或操作的存在，自动机 无法仅仅根据一个字符 就判断出 模式是否出现；
由于 闭包的存在，自动机甚至 无法知道 需要检查多少个字符 才会出现 匹配失败。

为了克服这些困难，我们需要使用 “非确定性”的自动机👇
当面对 匹配模式的多种可能时，自动机能够 猜出 正确的转换！

你可能觉得 这种能力是不可能的，但是你会看到，
编写一个程序 来
#1 构造 非确定有限状态自动机（NFA），
#2 并有效模拟它的运行
是非常简单的。

正则表达式模式匹配程序 的总体结构 与 KMP算法的总体结构 几乎相同：
#1 构造 和给定正则表达式相对应的 非确定有限状态自动机；
#2 模拟NFA 在给定文本上的运行轨迹。

Kleene定理 是理论计算科学中的一个重要结论，它证明了
对于任意正则表达式，都存在有一个 与之对应的 非确定有限状态自动机（反之亦然）。

我们会👇
#1 学习该定理的证明，并
#2 演示如何 将任意正则表达式 转换成为 一台非确定有限状态自动机；
#3 然后模拟NFA的运行轨迹 来 完成模式匹配的任务；

在学习 如何构造 模式匹配的NFA 之前，先看一个示例，
它说明了 NFA的性质与操作。如图
它所显示的NFA 是用来 判断一段文本 是否包含在 正则表达式((A*B|AC)D)所描述的语言之中。
正如这个示例所示，我们所定义的NFA有着以下特点👇
#1 长度为M的正则表达式中的每一个字符 在所对应的NFA中 都 有且只有一个 对应的状态。
NFA的起始状态为0，并且 含有一个（虚拟的）接受状态M。

#2 字母表中的字符 所对应的状态 都有一条 从它指出的边，这条边 指向
模式中的下一个字符 所对应的状态（图中黑色的边）。

#3 元字符( ) | * 所对应的状态 至少含有一条 指出的边（图中红色的边），
这些边 可能指向 其他的任意状态；

#4 有些状态 有多条 指出的边，但是 一个状态 只能有一条 指出的黑色边。

图略
模式((A*B|AC)D) 所对应的NFA👆

我们约定 将所有的模式 都包含在括号中，因此
NFA中第一个状态对应的是 左括号，而最后一个状态 对应的是 右括号（并且 能够转换为 接收状态）。

和5.3节的DFA一样，在NFA中，也是从状态0开始读取 文本中的第一个字符。
NFA在状态的转换中，有时候会从文本中读取字符，从左往右 一次一个。
但是它和DFA有着一些基本的不同👇
#1 在图中，字符对应的是结点，而不是边；
#2 NFA 只有在读取了 文本中的所有字符 之后才能识别它，而 DFA并不一定需要 读取文本中的全部内容
就能够是被一个模式；

但这些不同点并不是NFA的关键———— 我们选择的是 最适合研究的 算法的自动机版本。
现在的重点在于 检查文本和模式是否匹配👇
为了达到这个目标，自动机需要 读取所有文本 并 到达它的“接收状态”。

在NFA中，从一个状态 转移到 另一个状态的规则 也与DFA中不同。
在NFA中 状态的转换 有以下两种方式👇
#1 如果 当前状态上的字符 是一个 字母字符，且 文本中的当前字符 与 该字符 相匹配，
则：自动机 可以扫过 文本中的该字符 并（经由黑色的边）转换到 下一个状态。
🐖 我们把这种转换 成为 “匹配转换”。

#2 如果 当前状态上的字符 是一个 字母字符，
则：自动机可以 不用扫描 文本中的任何字符，而是 经由红色的边 转换到 另一个状态。
🐖 我们 将这种转换 成为 “∈转换” - 也就是说 它所对应的“匹配” 是一个空字符串∈。

图略
找到 与 ((A*B|AC)D)正则表达式的NFA 相匹配的模式👆

例如，假设输入为 A A A A B D 并 启动正则表达式 ((A*B|AC)D)所对应的自动机（起始状态为0）.
上图显示的是 经过一系列状态转换 最终到达了 接收状态。

这一系列的转换 说明 输入文本 是属于 正则表达式所描述的字符串集合 之中的，
也就是说 文本和模式 是相互匹配的。

按照NFA的视角/方式，我们称 该NFA识别了 这段文本。

图5.4.3的例子说明👇
即使对于 类似于A A A A B D这种 NFA本应该能够识别的输入文本，
也能够找到一个 使NFA停滞的状态转换序列。

比如，如果NFA选择 在扫描完所有A之前，就转换到了 状态4，它就无法再继续前进了👇
因为离开状态4的唯一办法 只有匹配B。

这两个例子 说明了 这种自动机的不稳定性。
在扫描了一个A，并到达状态3之后，NFA面临了两个选择👇
#1 它可以 转换到状态4；
#2 或者 回到状态2.

这次选择
#1 或者会使它最终达到 接收状态（第一个例子）；
#2 或者进入到停滞状态（第二个例子）。

NFA在状态1时，也需要 进行选择（是否 经由∈-转换 到达状态2 或者 状态6）

这个例子说明了 NFA 和 DFA之间的关键区别：
因为 在NFA中 离开一个状态的转换 可能有多种，因此
从这种状态 可能进行的转换 是不确定的👇
即使不扫描 任何字符，它在不同的时间 所进行的状态转换 也可能是不同的。

为了使这种自动机的运行有意义，所设想的NFA 必须要能够猜测
对于给定的文本，需要进行哪种转换（如果有的话）才能够 最终到达 接收状态。

换句话说，当且仅当 一个NFA👇
#1 从状态0开始，从头读取了 一段文本中的所有字符，
#2 进行了一系列状态转换
#3 并 最终到达了 接收状态 时，
才称: 该NFA 识别了一个 文本字符串。

相反，当且仅当 对于一个NFA，不存在有任何 匹配转换 和 epsilon转换的序列能够
#1 扫描所有文本字符，
#2 并到达接受状态时，
才称：该NFA 无法识别 这段文本字符串。

和DFA一样，这里只要列出 所有状态的转换，就能够 跟踪NFA处理文本字符串的轨迹。
任何类似的 结束于最终状态的转换序列 都能够证明 某个自动机识别了某个字符串（也可能存在有其他的证明）。

但是对于 一段给定的文本，应该如何找到这样一个序列呢？
对于另一段给定的文本，我们应该如何证明 不存在这样一个序列呢？
这些问题的答案 比你想象的要简单 - 系统地尝试所有的可能性！