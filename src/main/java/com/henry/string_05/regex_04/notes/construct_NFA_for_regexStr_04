根据 正则表达式 与 大家所熟悉的算术表达式的相似性，你肯定不会惊讶于
把正则表达式 转换为 NFA的过程，在某种程度上 类似于1.3节中，使用 Dijkstra的双栈算法 对表达式求值的过程。

两个过程的不同之处在于👇
#1 正则表达式中的连接操作，不存在有其对应的运算符；
#2 正则表达式中的闭包（*）操作，对应的是一个 一元运算符；
#3 正则表达式 只有一个二元运算符，也就是 或操作对应的运算符 |

我们不会在两者的 不同和相似之处 深究，而是会 学习一种 为正则表达式量身定做的实现。
该实现只需要一个栈，而不是两个。

根据上一小节开头讨论的NFA表示，我们只需要构造出一个 由所有∈-转换所组成的有向图G。
正则表达式本身 和 在本节开头学习过的形式定义，就足以提供 所需要的全部信息。

根据Dijkstra算法，我们会使用一个栈 来 记录所有 #1左括号 与 #2 或运算符 的位置。

===
#1 连接操作

对于NFA，连接操作 是最容易实现的。
状态的匹配转换 和 字母表中的字符 之间的对应关系，就是 连接操作的实现；

===
#2 括号
我们需要 把正则表达式字符串中的所有左括号的索引 都压入栈中。
当我们遇到 一个右括号时，我们都会用到 后文所述的方式 把左括号从栈中弹出。

和Dijkstra算法一样，栈这种数据结构 可以很自然地处理 嵌套的括号。

===
#3 闭包操作
闭包运算符* 只可能出现在
① 单个字符之后 - 对于这种情况，我们会在 此字符 与 * 之间添加上 相互指向的两条∈-转换；
② 右括号之后 - 对于这种情况，我们会 在对应的左括号（栈顶元素） 和 * 之间添加上两条 相互指向的∈-转换；

===
#4 或表达式
在 像是(A|B)的正则表达式中，A与B也都是正则表达式。
我们的处理方式 是添加上 两条∈-转换：
① 从 左括号所对应的状态 指向 B中第一个字符所对应的状态 的 一条∈-转换；
② 从 |字符所对应的状态 指向 右括号所对应的状态 的 一条∈-转换；

把正则表达式字符串中 |运算符的索引（以及左括号的索引） 压入到 栈中，
这样 到达右括号的时候，所有需要的信息 都会出现在栈的顶部。

这些∈-转换 使得 NFA能够 在这两者之间进行选择。
此时并没有像平常一样 添加一条 从 |运算符所对应的状态 指向 下一个字符所对应状态 的∈-转换👇
NFA离开 或运算符的唯一方式 就是 通过某种状态转换 到达 右括号所对应的状态。

===
这些个简单的规则 就已经可以拿来构造出 任意复杂的正则表达式 所对应的NFA了。
算法5.9实现了 这些规则。

它的构造函数 创建了 给定正则表达式 所对应的∈-转换有向图。

算法处理样例的轨迹如图👇
图略

为了实现的简洁和清晰，我们把一些实现细节（比如 处理元字符、字符集描述符、闭包的简略写法、多项或运算符等）留作练习。
当不需要上述的扩展👆时，NFA构造过程 所需要的代码非常少。

评论：NFA构造代码 是我们见过的 最巧妙的算法之一。