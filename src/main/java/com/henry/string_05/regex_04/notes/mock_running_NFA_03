”存在 能够猜测 到达接受状态 所需要的状态转换序列 的自动机“ 这样的设想，就好像
能够写出 解决任何问题的程序一样 - 这看起来很荒谬。

经过仔细思考，你会发现这个任务从概念上来说 并不困难：我们可以检查 所有可能的 状态转换序列。
只要其中存在 能够到达接受状态的序列，我们就会找到它。

===
自动机的表示

首先，我们需要 能够表示NFA。
选择很简单：正则表达式本身 已经给出了 所有的状态名（状态名就是0到M之间的整数，M表示的是 正则表达式字符串的长度）

使用char数组 re[] 来 保存正则表达式本身，
这个数组 同时也表示了 匹配的转换 - 如果re[i]存在于 字母表中，那么就存在一个 从i到i+1的匹配转换。

∈转换 最自然的表示方法 当然是 有向图 ——
它们都是 连接0到M之间的各个顶点 的有向边（图中的红色边）。

因此，我们用 有向图G 来 表示所有的∈-转换。
在讨论模拟的过程之后，我们 会讨论由给定的正则表达式 来 构建有向图的任务。

对于上面的例子，它的有向图 包含有以下9条边👇
0->1 1->2 1->6 2->3 3->2 3->4 5->8 8->9 10->11

===
NFA的模拟 与 可达性

为了模拟 NFA的运行轨迹，我们会记录 自动机在检查当前输入字符时，可能遇到的所有状态的集合。
这里，关键的计算是  我们已经在算法4.4中解决的 多点可达性问题。

我们会 查找所有 从状态0 “通过∈-转换 可以到达”的所有状态 来 初始化这个集合👆

对于集合中的每个状态，检查 它是否可能 与“第一个输入字符”相匹配。
检查并匹配之后，就得到了
#1 NFA在匹配第一个字符之后，可能到达的所有状态的集合。
#2 这里还需要 向集合中加入  所有 从该集合中的任意状态，“通过∈-转换 可以到达”的其他状态。

有了这个 匹配了第一个字符之后所可能到达的所有状态的集合后，
∈转换有向图中 的多点可达性问题的答案 就是 可能匹配“第二个输入字符”的集合状态。

例如，在示例NFA中 初始状态集合为 {0, 1, 2, 3, 4, 6}，
如果 第一个输入字符是A，那么 NFA 就能够使用匹配转换，匹配转换所可能达到的所有状态 是{3, 7},
然后 NFA可能进行 3到2 或者 3到4的 ∈转换，
因此 与第二个字符匹配的状态集合 为{2, 3, 4, 7}。

重复这个过程，知道文本结束。最终可能得到两种结果：
#1 所可能到达的所有状态 中，包含有 接受状态；
#2 所可能到达的所有状态 中，不含有 接受状态。

第一种结果 说明：存在有某种转换序列，能够使得NFA到达接受状态；
第二种结果 说明：对于此输入，NFA总是会停滞，从而导致匹配失败。

使用：
① SET数据类型 与
② 用于在有向图中 解决多点可达性问题的 DirectedDFA类，
我们可以 用如下的代码 来 表示如上的描述。

可以使用下图 来 检查 你对这段代码的理解，
它显示了 样例输入的完整轨迹。

图略
使用 ((A*B|AC)D)正则表达式字符串的NFA 来 处理 对于输入 A A B D的模拟👆

===
命题Q 用于判定 一个长度为M的正则表达式 其所对应的NFA 能否识别 一段长度为N的文本，
所需的时间 在最坏情况下 和MN成正比。

证明：
长度为N的文本，对于其中的每一个字符，我们都会 为其遍历一个 大小不超过M的状态集合，
并且 在∈-转换的有向图中，进行深度优先搜索。
下面即将学习的 自动机的构造 可以证明 该有向图中的边数 不会超过 2M条，
因此 每次深度优先搜索 在最坏情况下的运行时间 与M成正比。

===
评论
请仔细思考下 这个不同寻常的结果。
它在最坏情况下的成本为 文本和模式的长度之积👇
这个成本 和 5.3节开始时所学习的 最坏情况下寻找固定字符串的初级算法的成本 竟然是 相同的！

代码：recognizes()
使用NFA来模拟的模式匹配👆

