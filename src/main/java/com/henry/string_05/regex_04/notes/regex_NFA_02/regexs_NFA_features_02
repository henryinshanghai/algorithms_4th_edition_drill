在学习 如何构造 模式匹配的NFA 之前，先看一个示例，
它说明了 NFA的性质与操作。如图
它所显示的NFA 用来 判断一段文本 是否包含在 正则表达式((A*B|AC)D)所描述的语言 之中。

正如这个示例 所示，我们所定义的NFA 有着以下特点👇
#1 长度为M的 正则表达式中的 每一个字符 在所对应的NFA中 都 有且只有一个 对应的状态。
NFA的起始状态 为 0，并且 含有一个（虚拟的）接受状态M。

#2 字母表中的字符 所对应的状态 都有一条 从它指出的边，这条边 指向
模式中的下一个字符 所对应的状态（图中黑色的边）。

#3 元字符( ) | * 所对应的状态 至少含有一条 指出的边（图中红色的边），
这些边 可能指向 其他的任意状态；

#4 有些状态 有多条 指出的边，但是 一个状态 只能有一条 指出的黑色边。

图略
模式((A*B|AC)D) 所对应的NFA👆

我们约定 将 所有的模式都 包含在括号中，因此
NFA中第一个状态对应的是 左括号，而最后一个状态 对应的是 右括号（并且 能够转换为 接收状态）。

和 5.3节的DFA 一样，在NFA中，也是 从状态0 开始读取 文本中的第一个字符。
NFA在 状态的转换 中，有时候会 从文本中读取字符，从左往右 一次一个。
但是它 和DFA 有着一些 基本的不同👇
#1 在 图 中，字符 对应的是 结点，而不是边（DFA中的字符 对应的 是一条边）；
#2 NFA 只有在 读取了 文本中的所有字符 之后 才能识别它，而 DFA 并不一定需要 读取 文本中的全部内容
就能够 识别一个模式；

但这些不同点 并不是 NFA的关键———— 我们选择的是 最适合研究的 算法的自动机版本。
现在的重点在于 检查文本和模式 是否匹配👇
为了 达到这个目标，自动机需要 读取所有文本 并 到达 它的“接收状态”。