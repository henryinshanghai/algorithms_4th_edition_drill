在许多应用程序中，我们在查找子字符串时，可能没有 被查找模式 的完整信息。

文本编辑器的用户 可能希望：
#1 只是指定模式的一部分；
#2 或者 指定 某种能够匹配到若干个不同单词的模式；
#3 或者 指定 几种 可以任意匹配的不同模式。

比如，生物学家 可能想要 在基因组序列中，找到满足特定条件的基因。
本节中，我们将会学习 如何高效地 完整此种类型的 模式匹配。

5.3节的算法 完全依赖 “完整的”模式字符串，因此 我们需要寻找新的方法。

本节将会学习的一些基本工具 能够构造出 一个非常强大的 字符串查找程序。
它能够 在长度为N的文本中，匹配长度为M的复杂模式。
在最坏的情况下，它所需要的时间 和MN成正比，而在一般的应用程序中 还会快得多。

首先，我们需要一种 描述模式的方法，即一种严谨的 用于说明上述“部分子字符串的查找问题”的方式。
这份说明 必须含有 一些
比起 5.3节中所使用的 “检查文本字符串的第i个字符 和 模式字符串中的第j个字符是否匹配”
更为强大的 原始操作。
为此，我们使用 正则表达式。
它能够 用自然、简单而强大的3种操作组合 来 描述模式。

程序员使用正则表达式的历史 已经有数十年了。
随着网络搜索的爆炸性增长，它们的使用 变得更加广泛。

本节开始 会讨论几个应用程序。
这不仅是为了 让你感受到它的用途和功能，也是为了让你对它的基本性质 更加熟悉。

和5.3节中的KMP算法一样，本节也会使用
一种 能够在文本中查找模式的抽象自动机 来 描述这3种基本的操作。

模式匹配算法 同样会构造出 一个这样的自动机，并模拟它的运行。
当然，这种 模式匹配自动机 比 KMP算法的DFA 更加复杂，但是不会超出你的想象。

你会看到，我们 为模式匹配问题给出的解答 和 计算机科学中最基础的问题 有着紧密的联系。
比如，我们 用于完成 给定模式下的字符串查找任务的算法 和
Java系统中 用来将Java程序转化为计算机上的机器语言的算法 很相似。

我们还会遇到 “非确定性”这个概念。
它在人们对高效算法的追求中，起到了关键的作用。

===
使用正则表达式 来 描述模式

我们的重点在于 对模式的描述：它由3种基本操作 和 作为操作数的字符 组成。
我们使用 语言 来表示 一个字符串的集合（可能是无限的）；
使用 模式 来表示 一种语言的详细说明。

我们将要学习的规则 和 我们都已经很熟悉的算术表达式的规则 十分类似。

#1 连接操作
第一种基本操作 就是5.3节中使用过的 连接操作。
当我们写出AB的时候，就指定了一个语言{AB}。
它含有一个 由两个字符所组成的字符串，由A与B连接而成。

#2 或操作
第二种基本操作 用于在模式中指定多种可能的匹配。
如果我们在“两种选择”之间，指定了一个“或运算符”，则：它们 就会属于 同一种语言。

我们使用 竖线符号 | 来 表示这个操作。
比如，A|B指定的语言是 {A, B}
A|E|I|O|U 指定的语言是 {A, E, I, O, U}

特征：连接操作的优先级 高于 或操作。
所以 AB | BCD 所指定的语言是 {AB, BCD}

#3 闭包操作
第三种基本操作可以 将模式的一部分 重复任意的次数。
模式的闭包 由 “把模式和自身连接任意多次（包括零次）而得到的所有字符串” 所组成的语言。

我们使用 * 来 表示闭包操作。
用法：把*标记在 “需要被重复的模式”的后面。

特征：闭包操作的优先级 高于 连接操作。
所以 AB* 所指定的语言，由 一个A 和 0个或多个B字符构成的字符串 来组成，
而 A*B 所指定的语言，由 0个或多个A 和 一个B字符构成的字符串 来组成。

空字符串的记号是 ∈，它存在于 所有的文本字符串之中（包括A*）。

#4 括号
作用：用于 改变默认的优先级顺序。
比如 C(AC|B)D 所指定的语言是 {CACD, CBD},
(A|C)((B|C)D) 所指定的语言是 {ABD, ACD, CBD, CCD},
(AB)* 所指定的语言是 由AB连接任意多次所得到的所有字符串 与 空字符串所组成的集合
{∈, AB, ABAB, ...}

这些简单的例子 已经可以写出 虽然复杂，但却清晰而完整的 用于描述某种语言的正则表达式了。

有些语言 使用其他的方式（非正则的方式） 也能够表示，但是 找到这些方式可能会很困难。

正则表达式 都是非常简单的形式语言对象，甚至 比起你在小学里学到的 算术表达式 更加简单。
我们会使用它的简洁性  来 开发出 小巧而高效的算法 来 处理它们。

首先，给出如下 正则表达式的正式定义。

一个正则表达式可以是：
#1 一个空字符串∈；
#2 单个字符；
#3 包含在括号中的 另一个正则表达式；
#4 两个或多个 连接起来的正则表达式；
#5 由或运算符分隔的 两个或多个 正则表达式；
#6 由闭包运算符所标记的 一个正则表达式。

这段定义 描述了 正则表达式的语法，说明了 什么样的字符串才是一个合法的正则表达式。

在本节中 对给定正则表达式的非形式化描述 是它的语义。
作为复习，我们要继续 在形式定义中，对它们进行总结。

定义（续）
每个正则表达式 所表示的 都是一个 字符串的集合。它们的定义如下所述👇
#1 空正则表达式 所表示的字符串的集合 是空的，含有0个元素；
#2 由一个字符 所表示的字符串的集合 只包含有一个元素，也就是 该字符本身；
#3 由括号 与 在其中的正则表达式 所组成的正则表达式 所表示的字符串的集合，与 括号内的正则表达式所表示的字符串集合 相同。
#4 由两个正则表达式连接起来的正则表达式 所表示的字符串的集合 是 这两个正则表达式所分别表示的字符串集合 的叉乘结果。
#5 由或运算符所连接的两个正则表达式 所表示的字符串的集合 是 这两个正则表达式所分别表示的字符串集合 的并集；
#6 由一个正则表达式的闭包 所表示的字符串的集合 是 由空字符串∈ 或 把 “被修饰的正则表达式所表示的字符串集合”重复任意次 所得到的所有字符串 所组成的集合。

一般来说，给定正则表达式 所描述的语言 可能会非常庞大，甚至可能是无限的。

描述一种语言 可以有许多种不同的方法，我们 必须要 尝试给出 最简洁的模式，
就像在 不断地尝试写出 简洁的程序 和 实现高效的算法一样。

===
缩略写法

一般的应用程序 都会 在基本规则的基础上 增加各种额外的规则，来 更为简洁地描述 实际应用种所需要的语言。

从理论的角度来看，它们都只是涉及 多个操作数的 一系列操作的简略写法；
从实际的角度来看，它们是 对基本操作的实用扩展，以便能够写出 更为小巧的模式。

#1 字符集的描述符
实际应用时，只使用 一个或者几个字符 来 直接表示一个字符集的做法 通常能够带来方便。
点(.)字符 用于表示 能够表示任意字符的通配符。
包含在方括号中的一系列字符 用于表示 这些个字符中的任意一个。
    🐖 这里的一系列字符 可以使用一个范围 来 进行表示；
    🐖 如果方括号中的开头字符为^，则：表示 任意一个 非方括号中的字符。
这些记法 其实都是 一系列或操作的简写。

通配符、指定的集合、范围集合、补集

#2 闭包的简写
闭包运算符 用于表示 把它的操作数 复制/重复 任意多次。
在实际使用时，我们会希望能够 灵活地指定 重复的次数，或者重复次数的范围。

手段：
#1 使用+ 来表示 至少复制/重复一次；
#2 使用? 来表示 重复0次或者1次；
#3 使用写在{}中的数字或范围 来 指定重复的次数。

同样地，这些记法也是 一系列基本操作（连接、或、闭包）的简写。

#3 转义序列
有一些字符，是用于构造正则表达式字符串的元字符（字符本身在regex中有特殊的含义）。
比如 \ . | * ( )这些字符。

区分 元字符 与 字母表中的字面字符；
手段：使用 以反斜杠开头的转义序列。

用法：
#1 转义字符\ + 单个元字符 用于表示 元字符的字面字符本身；\\ 用于表示 \
#2 与其他字符构成的转移序列；\t 表示一个制表符、\n表示也给换行符、\s表示 任意空白字符。

===
正则表达式的实际应用

实际应用 已经证明了 正则表达式 善于描述 与语言有关的内容。
因此，正则表达式 使用广泛，相关的研究也 比较深入。

为了让你在熟悉正则表达式的同时，也向你 展示一些它的用途，
在讨论 正则表达式的 模式匹配算法 之前 先给出一些 实际应用的例子。

正则表达式 在计算机科学理论中 也起到了重要的作用。
在本书中 完整地说明 它的应用范围 不切实际，但是 会在适当的地方 提到相关的理论成果。

#1 子字符串的查找

我们的总体目标 是 开发一种算法。
它能够用于判定 给定的子字符串 是否包含在 给定的正则表达式 所描述的字符串集合之中。
如果 文本 包含在 模式所描述的语言之中，则称 文本 和 模式匹配。

正则表达式的模式匹配 一般化了 5.3节中的 子字符串查找问题。
准确地说，在 一段文本txt中来查找一个子字符串pat，等价于 检查txt是否存在于 模式“.*pat.*”所描述的语言之中。

#2 合法性检查

在使用互联网时，你经常会遇到 正则表达式。
当你在某个商业网站上输入一个日期 或者是 账号时，
输入处理程序 会检查 输入的格式是否正确。

进行这类检查的一种方式 是使用代码检查所有可能出现的情况：
如果你应该输入一个金额（美元），代码 就会检查第一个字符是不是$，
$字符之后是不是一个数字...

更好的办法是 定义一个正则表达式 来 描述所有合法的输入。
之后，检查用户的输入是不是合法 就被转换成 模式匹配问题了👇
输入 是否被包含在 正则表达式所描述的语言之中？

随着这种检查的广泛应用，使用正则表达式 进行常见检查的库 在互联网上已经随处可见。
一般来说，相比于  一个能够检查所有情况的程序，正则表达式 是 对所有有效字符串集合的 更加准确和精炼的表达方式。

正则表达式的典型应用（简化版本）
#1 字符串查找
#2 电话号码
#3 Java标识符
#4 基因组
#5 电子邮件地址

==
程序员的工具箱

正则表达式模式匹配的起源是 Unix的命令grep，
它会打印出 与给定正则表达式相匹配的所有输入行。

这个工具是 束带程序员的无价之宝，而正则表达式 也已经 被内置于 许多现在编程系统之中👇
从awk和emacs，到Perl、Python和JavaScript。

比如，某个目录中含有许多的.java文件，而你希望知道 哪些文件使用了StdIn。
这条命令可以很快给出答案👇
grep StdIn *.java
它会打印出 每个文件中 与 ".StdIn.*"相匹配的每一行代码。

===
基因组

生物学家也会使用 正则表达式 来 研究重要的科学问题。
例如，人类的基因序列的某个区域 可以使用 正则表达式 gcg(cgg)*ctg描述，
其中模式cgg的重复次数 在不同的个体之间 有很大的区别。

人们已知某种 能够造成智力障碍 和 其他一些症状的基因疾病 和 该模式的高重复次数有关。

===
搜索

互联网搜索引擎 都支持 正则表达式，但可能不是非常完整的。
一般来说，如果你希望通过 | 来 指定其他的匹配模式，
或者 通过*来产生重复 - 搜索引擎都支持这些操作。

===
正则表达式的可能性

理论计算机科学的第一堂入门课程就是
找出正则表达式 所能够指定的语言集合。
比如，你可能会感到意外的是，正则表达式 能够实现 取余操作：
例如 (0 | 1(01*0)*1)* 描述的 所有由0和1组成的字符串 都是3的倍数的二进制表示！
也就是说，11、110、1001和1100 都在这个语言之中，
而10、1011和10000都不在。

===
局限

并不是所有的语言 都可以使用 正则表达式 来定义的。
一个令人深思的示例就是 不存在 能够描述 所有合法正则表达式字符串的集合 的 正则表达式。

这个示例的简单版本 包括：
#1 无法使用正则表达式 检查括号是否匹配完整；
#2 以及 检查字符串中的A和B的数量是不是一样多；

这些例子都只是冰山一角。
正则表达式 是计算性基础设施中非常使用的一部分，
对于帮助我们 理解计算的本质 起到了 重要的作用。

和KMP算法一样，下面将要描述的算法 也是 在探索这个理论过程中的副产品。