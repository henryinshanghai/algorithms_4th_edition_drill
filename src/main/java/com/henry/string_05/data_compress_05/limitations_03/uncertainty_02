==
不可判定性

如图，它是一条上百万位的字符串。
这个字符串看起来很随机，所以你不太可能 为它找到一个”无损压缩算法“。

但有一种方法只用几千个比特 就可以 表示这个字符串，
因为 它是通过如下框注的程序生成的。
（这个程序是”伪随机数生成器“的一个示例，和Java.Math.random()方法一样）

#1 通过使用”ASCII文本“编写”生成程序“ 来 进行压缩；
#2 通过读取并运行”该程序“👆 来 展开”被压缩字符串“
的压缩算法 能够取得0.3%的压缩率，这是非常难以超越的。
🐖 我们还能够降低这个比例，只要该程序再输出更多比特即可。

压缩这个文件最好的方法就是找出 ”创造这些数据的程序“。
这个例子并不像它看上去地那么深奥👇
当你在压缩”一段视频“ 或者 一本”通过扫描而数字化的旧书“
或者是 互联网上的无数”其他类型的文件“时，你都在: 寻找 ”创造这个文件的程序“。

在意识到 我们处理的大部分数据 都是”由某种程序产生的“之后，
我们才能发现 计算理论中的一些深刻的问题，并理解 数据压缩所面临的挑战。
比如，可以证明 最优数据压缩（也就是 找到”能够产生给定字符串“的最短程序）是一个 “不可判定问题”：
我们不但 #1 不可能找到 能够压缩”任意比特流“的算法；#2 也不可能找到 ”最佳的压缩算法“！

这些局限性所带来的实际影响 要求 无损压缩算法 必须尽量利用 ”被压缩的数据流“中的“已知结构”。
我们会依次讨论4种方法 来 处理 ”具备所有以下结构特征“的数据 👇
#1 小规模的字母表；
#2 较长的”连续相同的位/字符“；
#3 频繁使用的字符；
#4 较长的”连续重复的位/字符“。

如果你已知 给定的比特流中，具有以上一种或者多种特点，也可以使用它们碰碰运气，
因为你的数据结构 也许并不是那么明显，而这些方法的适用性很广。

你将会看到，每种方法 都有多个参数和变种，并且
可以为 特定的比特流调优 来 达到最佳的压缩率。

第一个和最后一个示例 是为了 帮助你了解数据的结构，
接下来我们会学习一个方法 来 压缩示例数据。