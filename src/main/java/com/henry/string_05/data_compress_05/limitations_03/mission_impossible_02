==
不可判定性

如图，它是一条 上百万位的字符串。
这个字符串 看起来 很随机，所以你 不太可能 为它找到一个 ”无损压缩算法“。

但 有一种方法 只用几千个比特 就可以 表示这个字符串，
因为 它是 通过 如下框注的程序 生成的。
（这个程序是”伪随机数生成器“的一个示例，和 Java.Math.random()方法 一样）

#1 通过 使用”ASCII文本“ 编写”生成程序“ 来 进行压缩；
#2 通过 读取并运行 ”该程序“👆 来 展开 ”被压缩字符串“
的压缩算法 能够取得0.3%的压缩率，这是 非常难以超越的。
🐖 我们 还能够降低 这个比例，只要 该程序 再输出 更多比特 即可。

压缩这个文件 最好的方法 就是 找出 ”创造这些数据的程序“。
这个例子 并不像 它看上去地 那么深奥👇
当 你在压缩”一段视频“ 或者 一本”通过扫描而数字化的旧书“
或者是 互联网上的无数”其他类型的文件“ 时，你都在: 寻找 ”创造这个文件的程序“。

在 意识到 我们处理的大部分数据 都是 ”由某种程序产生的“ 之后，
我们 才能发现 计算理论中的 一些深刻的问题，并 理解 数据压缩 所面临的挑战。
比如，可以证明 最优数据压缩（也就是 找到”能够产生 指定字符串“的 最短程序）是一个 “不可判定问题”：
我们不但 ① 不可能找到 能够压缩”任意比特流“的算法；② 也不可能找到 ”最佳的压缩算法“！

这些局限性 所带来的实际影响 要求 无损压缩算法 必须尽量利用 ”被压缩的数据流“中的“已知结构”。
我们会 依次讨论 4种方法 来 处理 ”具备 所有 以下结构特征“的数据 👇
#1 小规模的 字母表；
#2 较长的 ”连续相同的位/字符“；
#3 频繁使用的 字符；
#4 较长的 ”连续重复的位/字符“。

如果你 已知 给定的比特流 中，具有 以上一种或者多种特点，也可以 使用它们 碰碰运气，
因为 你的数据结构 也许 并不是 那么明显，而 这些方法的适用性 很广。

你 将会看到，每种方法 都有 多个参数 和 变种，并且
可以 为 特定的比特流 调优 来 达到 最佳的压缩率。

第一个 和 最后一个示例 是为了 帮助你了解 数据的结构，
接下来 我们会学习 一个方法 来 压缩示例数据。