===
示例👇

Ⅰ 对于 前7个编码，只需要 在 符号表 中 查找并输出 相应的字符，
Ⅱ 然后 多读取一个字符，并 在 符号表 中添加 一个“包含有两个字符的 字符串条目”。
这 与 之前 是 相同的👆

然后 读到81（输出 AB，并 向符号表中 添加ABR），
然后是83（输出 RA 并 添加RAB），
82（输出 BR，并 添加BRA），
88（输出 ABR，并 添加RAB），
82（输出 BR，并 添加BRA），
88（输出 ABR，并 添加ABRA），
然后 只剩下41.

最终 会遇到 文件结束的标记80（因此 输出A）。

这个过程结束 后，就已经：
Ⅰ 如期 写出了 原始的输入，并且
Ⅱ 构造了一张 和压缩时相同的 符号表（只是 键和值的位置 对调了）。

注意，我们 也可以使用 一个简单的 字符串数组(index/key -> item/value) 来 表示符号表（数组的索引 就是 编码）。

输入 41 42 52 41 43 41 44 81  83  82  88  41 80

反编译表 // 得到 反编译表 的过程 比较繁琐
键       值
81      AB
...
8B      ABRA

输出 A B R A C A D AB RA  BR  ABR A