===
LZW的单词查找树

LZW压缩算法 含有 两种 符号表操作👇
#1 找到(search) 输入 和 符号表中所存在的、所有键的、最长前缀 匹配结果；
#2 把 匹配的键 和 前瞻字符 相连接 得到 一个新的键，
   并 把 新的键 和 下一个编码 相关联，并 作为 新的条目 添加到(insert)符号表 中。

5.2节中 所介绍的“单词查找树结构” 完全就是为了 以上操作 量身定做的。

对于 上一个示例，它的 单词查找树表示 如图（图略）。
#1 查找 “最长前缀匹配” 时，我们需要 从 根结点 开始 遍历树，使用“结点的标签” 来 和 “输入字符” 进行匹配；
#2 添加 一个新编码 时，我们需要 先创建一个 由 新编码 和 前瞻字符 所标记的结点，并 把 它 和 “查找结束于的结点” 相关联。

在 实践 中，为了 节省空间，我们 使用的是 5.2节中 所介绍的 “三向单词查找树”。

值得一提的是，这里 对单词查找树的使用 与 霍夫曼编码 对单词查找树的使用 并不相同👇
#1 霍夫曼编码 使用 单词查找树，是因为 需要满足 “前缀码”的约束 - 任何编码 都不会成为 其他编码 的前缀；
#2 对于 LZW算法，它使用 单词查找树，是因为 对于 每个 “由 输入字符串 所得到的键”，其前缀 也一定会是 “符号表中的一个键”
（因为 当前键 = 前一个键 + 前瞻字符c组成）。