为了说明这种算法的基本思想，先来看一个数据压缩的示例。
假设需要读取一列 有7位ASCII编码的字符 所组成的输入流，并 把它们写为 一条8为字节的输出流。

（在实际应用中，使用的参数值 一般都会更大。但在具体实现中，我们使用的是 8位的输入和12位的输出。）
我们把输入字节称为“字符”，输入的字节序列称为“字符串”，而输出字节称为“编码”。
尽管这些属于 在其他的情况下的意义 会有所不同。

LZW压缩算法的基础是：维护一张 字符串键 和 （定长）编码的编译表。
字符串键的分类：#1 单字符键； #2 多字符键；

对不同类型的“字符串键”的具体做法👇
#1 在符号表中，把128个“单字符键”的值 初始化为 8位编码，也就是 在每个字符的7位值（128位）的前面 添加一个0.
    🐖 为了简单明了，我们使用十六进制数字 来 表示编码的值👇
    在ASCII表的16进制表示中：A的编码为 41，R的编码为 52，等等。

#2 我们会把 80 保留为 文件结束的标识；并
#3 把其余的编码值（81~FF）分配给 我们“在输入中遇到的”各种子字符串👇
    从81开始，不断为新的字符串键（多字符键） 赋予 更大的编码值。