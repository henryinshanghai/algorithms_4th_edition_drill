为了说明 这种算法的基本思想，先来 看一个 数据压缩的示例。
假设需要 读取一列 由 7位ASCII编码的字符 所组成的输入流，并 把 它们 写为 一条8位字节的输出流。

（在实际应用中，使用的参数值 一般都会 更大。但 在 具体实现 中，我们 使用的是 8位的输入 和 12位的输出。）
我们 把 输入字节 称为 “字符”，输入的字节序列 称为 “字符串”，而 输出字节 称为“编码”。
尽管 这些 术语 在其他的情况下的意义 会 有所不同。

LZW压缩算法的基础 是：维护一张 字符串键 和 （定长）编码的编译表。
字符串键的分类：#1 单字符键； #2 多字符键；

对 不同类型的“字符串键” 的具体做法👇
#1 在 符号表 中，把 128个“单字符键”的值 初始化为 8位编码，也就是 在每个字符的7位值（128位）的前面 添加一个0.
    🐖 为了 简单明了，我们 使用 十六进制数字 来 表示 编码的值👇
    在 ASCII表的16进制表示 中：A的编码 为 41，R的编码 为 52，等等。

#2 我们会 把 80 保留为 文件结束的标识；并
#3 把 其余的编码值（81~FF）分配给 我们“在输入中 所遇到的” 各种 子字符串👇
    从 81 开始，不断 为 新的字符串键（多字符键） 赋予 更大的编码值。