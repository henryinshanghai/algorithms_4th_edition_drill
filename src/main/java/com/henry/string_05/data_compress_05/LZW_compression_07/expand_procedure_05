===
LZW算法的 展开

如示例所示，LZW压缩的展开 所需要的输入 是一系列 8位的编码，
而 输出 则是 一个 由 “7位的ASCII字符” 所组成的 字符串。

在 展开 时，我们 会维护一张 关联“字符串键” 和 “编码值”的 符号表（这张表的 逆向表 就是 压缩时所使用的 符号表）。

① 在 这张表 中，加入 00 到 7F 和 所有 单个ASCII字符的字符串 的关联条目；
② 把 第一个 未关联的编码值 设置为 81（把 80 保留为 文件结尾的标记）；
③ 把 保存了当前字符串的 变量val?? 设置为 包含有 第一个字符的 字符串；

在 遇到 编码80（文件结束）之前，不断进行 以下操作👇
#1 输出 “当前字符串”val；
#2 从 输入 中 读取一个编码x；
#3 在 符号表 中，把 “最长匹配前缀s” 对应的编码 设置为 和x相关联的值；
#4 在 符号表 中，把 “下一个未分配的编码值” 分配给 val+c(val 连接上 c),其中 c 是 “s的首字母”；
#5 把 “当前字符串val” 设置为s。

这个过程 比起 压缩 要 更加复杂，其原因 来自于 “前瞻字符”👇
需要 读取下一个编码 来 得到 “与其相关联的字符串”的首字母 - 这 使得 整个过程 不同步。