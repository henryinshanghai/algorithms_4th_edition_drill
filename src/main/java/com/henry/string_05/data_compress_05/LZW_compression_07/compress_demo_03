===
LZW压缩示例

下表所示的是 LZW算法压缩样例输入 A B R A C A D' A B R A B R A B R A的详细过程。
对于前7个字符，“输入 在符号表中所能匹配的最长前缀”仅为1个字符。因此：
#1 输出 这些字符所对应的编码，并
#2 把编码81到87 逐一绑定到 由彼此相邻的两个字符 所产生的7个 “由两个字符构成的字符串”
（AB BR RA AC CA AD DA）上；

然后我们发现 AB匹配了 当前输入的前缀，所以 我们输出81，并 把ABR(连接下一个输入字符的结果)作为key 给添加到符号表中（value是自然数序列的下一个value）；
接着是RA，所以 我们输出83（因为RA是编译表中已经存在的key），并添加RAB；
接着是BR，所以 我们输出82，并添加BRA；
接着是ABR，所以 我们输出88，并添加ABRA；
最后只剩下一个A（A也是编译表中已经存在的key），所以我们输出41.

🐖 这个过程为什么是这样进行的，参考“compress_procedure_02”👆

输入为17个7位的ASCII字符(为什么是7位而不是8位??)，总共是119位比特；
输出为13个8位的编码(为什么81, 82... 是8位??)，总共是104位比特；
104/119=87%, 只使用了87%的空间。

对输入 A B R A C A D A B R A B R A B R A  这个字符序列，使用LZW算法进行压缩得到的结果是：
41 42 52 41 43 41 44  81 83 82 88 41 80(额外添加的结束标识)

编译表
[单字符条目省略]
AB  81
BR  82
RA  83
AC 84
CA 85
AD 86
DA 87
ABR 88
RAB 89 ??
BRA 8A ??
ABRA 8B 为什么还会有这些条目??