===
LZW压缩示例

下表所示的是 LZW算法压缩样例输入 A B R A C A D' A B R A B R A B R A的详细过程。
对于 前7个字符，“输入 在符号表中 所能匹配的 最长前缀” 仅为 1个字符。因此：
#1 输出 这些字符 所对应的编码，并
#2 把 编码81到87 逐一绑定到 由 彼此相邻的两个字符 所产生的 7个 “由两个字符构成的字符串”
（AB BR RA AC CA AD DA）上；

然后我们 发现 AB 匹配了 当前输入的前缀，所以 我们 输出 81，并 把ABR(连接下一个输入字符的结果)作为key 给 添加到符号表 中（value 是 自然数序列的下一个value）；
接着 是 RA，所以 我们 输出83（因为RA是编译表中已经存在的key），并 添加RAB；
接着 是 BR，所以 我们 输出82，并 添加BRA；
接着 是 ABR，所以 我们 输出88，并 添加ABRA；
最后 只剩下一个A（A也是编译表中已经存在的key），所以我们 输出 41.

🐖 这个过程 为什么是 这样进行的，参考“compress_procedure_02”👆

输入 为 17个 7位的ASCII字符(为什么是7位而不是8位??)，总共 是 119位比特；
输出 为 13个 8位的编码(为什么81, 82... 是8位??)，总共 是 104位比特；
104/119=87%, 只 使用了 87%的空间。

对 输入 A B R A C A D A B R A B R A B R A  这个字符序列，使用 LZW算法 进行压缩 得到的结果 是：
41 42 52 41 43 41 44  81 83 82 88 41 80(80是 额外添加的 结束标识)

编译表
[单字符条目省略]
AB  81
BR  82
RA  83
AC 84
CA 85
AD 86
DA 87
ABR 88
RAB 89 ??
BRA 8A ??
ABRA 8B 为什么 还会有 这些条目??