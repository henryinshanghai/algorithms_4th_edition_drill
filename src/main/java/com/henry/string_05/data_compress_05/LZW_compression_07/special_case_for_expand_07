在 刚刚的描述 中，存在有 一个小问题。
常常 只有 “基于 以上描述 实现了 这个过程”的同学（以及 有经验的程序员）才能够 发现它。

这个问题 就是 “前瞻过程”中 所得到的字符
可能 和 当前子字符串的开头字符 相同，如图所示。

在 这个例子 中，输入字符串：
ABABABA
对 这个字符串 进行压缩 所得到的 输出编码 为：
41 42 81 83 80

== 使用 当前字符串 与 下一个编码 在反编译表中所对应的字符串 的首字符 来 向 反编译表 中 添加条目 ==
目标：向 反编译表 中 添加条目；
手段：
    条目的key - 从 输入 中 读取到的 下一个编码值；
    条目的value - 当前字符串 + 前瞻字符

具体步骤👇
在 展开 时，首先 会读取得到 编码41，对照 现有的反编译表 可知：解码结果 为 A，把 解码结果 输出；
当前字符串 为 A：
    下一个读取到的是 编码42，对照 现有的反编译表 可知：解码结果 为 B，把 解码结果 输出；
        同时，我们 把 B 作为 前瞻字符(下一个编码对应的字符串的首字符)，并 把 AB(当前字符串A + 前瞻字符) 与 81(从哪儿来?? 答：下一个未分配的编码值)的关联 添加到 符号表中；
当前字符串 为 B：
    下一个读取到的是 编码81，对照 现有的反编译表 可知：解码结果 为 AB，把 解码结果 输出；
        同时，我们 把 A 作为 前瞻字符(因为它是81在反编译表中对应的字符串的第一个字符)，并 把 BA(当前字符串B + 前瞻字符) 与 82(下一个value)的关联 添加到符号表中；
当前字符串 为 AB：
    下一个读取到的是 编码83，对照 现有的反编译表 时，发现83 还没有出现 在 反编译表 中...
        因此，无法 解码，也无法 获取到 前瞻字符，也无法 向 反编译表 中 添加新条目...

幸运的是，检查（只有在 读取到的编码 与 反编译表中 需要完成的条目 中的编码 相同时 才需要）并
修正（因为 这种情况下，前瞻字符 必然是 当前字符串的首字符 - 因为 它 就是 下一个 将要被输出的字符）
并不困难。

在这个例子中，前瞻字符 必然是 A（它 是 ABA的首字符）。
所以，下一个被输出的字符串 和 符号表中83的值 都会是 ABA（当前字符串AB + 前瞻字符A）。
