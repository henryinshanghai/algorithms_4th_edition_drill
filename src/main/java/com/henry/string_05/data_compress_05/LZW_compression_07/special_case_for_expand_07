在刚刚的描述中，存在有一个小问题。
常常 只有基于以上描述 实现了这个过程的同学（以及有经验的程序员）才能够发现它。

这个问题就是 “前瞻过程”中 所得到的字符
可能 和当前子字符串的开头字符 相同，如图所示。

在这个例子中，输入字符串：
ABABABA
对这个字符串进行压缩 所得到的输出编码为：
41 42 81 83 80

== 使用 当前字符串 与 下一个编码在反编译表中对应的字符串的首字符 来 向反编译表中添加条目 ==
目标：向反编译表中添加条目；
手段：条目的key - 从输入中读取到的下一个编码值； 条目的value - 当前字符串 + 前瞻字符

具体步骤👇
在展开时，首先会读取得到 编码41，对照 现有的反编译表可知：解码结果为A，把解码结果输出；
当前字符串为A：
    下一个读取到的是 编码42，对照 现有的反编译表可知：解码结果为B，把解码结果输出；
        同时，我们把B作为前瞻字符(下一个编码对应的字符串的首字符)，并把AB(当前字符串A + 前瞻字符) 与 81(从哪儿来?? 答：下一个未分配的编码值)的关联 添加到符号表中；
当前字符串为B：
    下一个读取到的是 编码81，对照 现有的反编译表可知：解码结果为 AB，把解码结果输出；
        同时，我们把A作为前瞻字符(因为它是81在反编译表中对应的字符串的第一个字符)，并把BA(当前字符串B + 前瞻字符) 与 82(下一个value)的关联添加到符号表中；
当前字符串为AB：
    下一个读取到的是 编码83，对照 现有的反编译表时，发现83还没有出现在反编译表中...
        因此，无法解码，也无法获取到前瞻字符，也无法向反编译表中添加新条目...

幸运的是，检查（只有在 读取到的编码 与 反编译表中需要完成的条目中的编码 相同时才需要）并
修正（因为这种情况下，前瞻字符必然是 当前字符串的首字符 - 因为它就是下一个 将要被输出的字符）
并不困难。

    在这个例子中，前瞻字符必然是A（它是ABA的首字符）。
    所以，下一个被输出的字符串 和 符号表中83的值 都会是 ABA（当前字符串AB + 前瞻字符A）。
