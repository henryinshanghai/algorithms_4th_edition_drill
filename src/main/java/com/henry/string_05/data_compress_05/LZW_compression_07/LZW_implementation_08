经过 这些描述 之后，实现 LZW编码 就简单了。
如算法5.11所示（expand()方法的实现 见算法5.11续）。

这段实现 接受 8位字节流 作为输入（因此 能够压缩 任意文件，而 不仅仅是 字符串），
并 产生 12位编码的输出流（因为 字典 会非常大，压缩率 也会更好）。

这些值 被指定在 由final修饰的 实例变量R、L 和 W中。

在 compress()方法 中，使用了一棵 三向单词查找树(5.2节)
来 表示 编译表(利用 单词查找树 来 支持 高效的longestPrefixOf()的操作)；

在 expand()方法 中，使用了一个 字符串数组 来 表示 逆向编译表。
这样，compress()和expand()方法 就不完全 与 正文中的描述 一一对应了。

这些方法 非常高效。
对于 某些文件，我们 还可以通过
在 编译表 满 时，将 其 清空 并 重用 全部编码 的手段 来 改进它们。

这些改进 以及 评估它们的性能 所需要的实验，都留作 本节最后的练习。

代码：见 execution。

这段代码 实现了 Lempel-Ziv-Welch算法的展开。
展开的实现 比起 压缩 要 更加复杂，
因为① 它 需要 从 下一个编码 中 获取到 前瞻字符，
② 并且 存在有 前瞻字符不可用的复杂情况。

和 以前 一样，请 花一点时间 仔细研究 程序 和 图5.5.21给出的 LZW算法压缩的示例。
十几年来，它 已经被证明为 是一个多用途高效率的 压缩算法。