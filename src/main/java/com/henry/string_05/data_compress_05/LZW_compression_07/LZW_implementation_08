经过这些描述之后，实现LZW编码就简单了。
如算法5.11所示（expand()方法的实现见算法5.11续）。

这段实现 接受8为字节流 作为输入（因此 能够压缩任意文件，而不仅仅是 字符串），
并产生 12位编码的输出流（因为字典会非常大，压缩率也会更好）。

这些值 被指定在 由final修饰的实例变量R、L和W中。

在compress()方法中，使用了一棵 三向单词查找树(5.2节)
来 表示编译表(利用单词查找树 来 支持高效的longestPrefixOf()的操作)；

在expand()方法中，使用了一个字符串数组 来 表示逆向编译表。
这样，compress()和expand()方法 就不完全 与正文中的描述一一对应了。

这些方法非常高效。
对于某些文件，我们还可以通过
在编译表满时，将其清空 并 重用全部编码 的手段 来 改进它们。

这些改进 以及 评估它们的性能 所需要的实验，都留作
本节最后的练习。

代码：见 execution。

这段代码实现了 Lempel-Ziv-Welch算法的展开。
展开的实现 比起压缩 要更加复杂，
因为它 需要 从下一个编码中 获取到 前瞻字符，
并且 存在有 前瞻字符不可用的复杂情况。

和以前一样，晴花一点时间 仔细研究程序 和 图5.5.21给出的 LZW算法压缩的示例。
十几年来，它已经被证明为 是一个多用途高效率的 压缩算法。