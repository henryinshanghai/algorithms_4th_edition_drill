==
单词查找树的构造

作为描述过程的参考，如图 展示了 为以下输入，构造一棵霍夫曼单词查找树的过程：
it was the best of times it was the worst of times

我们 把“需要被编码的字符” 放在“叶子节点”中，并
在每个结点中维护一个 “名为freq的实例变量” - 用于表示 “以它为根结点的子树”中的所有字符(??)出现的频率

==
#1 构造的第一步是：
创建一片 由许多个“只有一个结点（叶子结点）的树” 所组成的森林。
其中每棵树（结点），都表示 输入流中的一个字符。
而“结点中的freq变量”的值 都表示了 它在输入字符序列中的出现频率；

在我们的例子中，输入中含有8个t，5个e，11个空格等
（🐖 为了得到这些频率，我们需要读取整个输入流。
因此“霍夫曼算法”是一个两轮算法 - 因为只有先读取输入流之后，才能压缩它）。

==
#2 接下来自底向上地 根据频率来构造 这棵编码的“前缀码单词查找树”。

在构造时，把它看作 一棵“结点中含有频率信息”的二叉树；
在构造完成后，我们才 把它看作一棵 “用于编码的单词查找树”。

构造过程如下：
首先 找到两个频率最小的结点，
然后 创建一个“以两者作为子结点的新结点”（新节点的“频率值” 是 它的两个子结点的频率值之和）。
    🐖 这个操作 会把森林中的树的数量减一。
再不断重复这个过程：找到森林中两棵 频率最小的树，并使用相同的方式创建一个新的结点。

使用优先级队列 能够轻易地实现这个过程，如框注的buildTrie()方法所示。
🐖 为了说明这个过程，图中的所有单词查找树都是有序的。

随着这个过程的继续，我们构造的单词查找树 会越来越大，相对地，
森林中的树会越来越少（因为每一步中，都会删除两棵树，添加一棵新的树）。

==
#3 最终，所有的结点都会 被合并为 一棵单独的单词查找树。
这棵树的“叶子节点” 为： #1 所有“待编码的字符” 和 #2 它们在输入中出现的频率。

特征：
#1 每个 非叶子节点中的频率值 为 它的两个子结点的频率值 之和。
#2 “频率较低的结点” 会被安排在树的底层。而“高频率的结点”则会 被安排在 “根结点附近的地方”。
#3 根结点的频率值 等于 输入中的字符总数量。

因为这是一棵 二叉树 且 字符仅存在于叶子节点中，所以👇
它定义了 这些个字符的前缀码。

由“前缀码单词查找树”能够得到字符集的编译表（如图示），再使用buildCode()方法，就能够得到“原始字符序列”压缩后的输出👇
《原始字符序列》
《构造单词查找树的代码》
《根据编译表与原始字符序列得到编码结果的代码》

《比特字符串》

==
观察👇
这个比特字符串长176位，相比 用“标准的8位ASCII编码”所需要的408位编码（51个字符），
它节省了57%（没有计入 “构造编码”操作的开销，下面会讨论👇）。

结论👇
另外，因为它是一个 “霍夫曼编码”，所以
不会存在任何其他 能够使用更少的比特 来 “把输入进行编码”的前缀码了。

《单词查找树的构造过程》
构造一棵霍夫曼编码单词查找树👆

《单词查找树的构造结果》
字符串"it was the best of times it was the worst of times LF" 的霍夫曼编码👆