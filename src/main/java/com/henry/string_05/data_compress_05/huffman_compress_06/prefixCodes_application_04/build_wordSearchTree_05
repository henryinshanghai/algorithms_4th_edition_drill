==
单词查找树的构造

作为 描述过程的参考，如图 展示了 为 以下输入 构造出 一棵霍夫曼单词查找树 的过程：
it was the best of times it was the worst of times

我们 把 “需要被编码的字符” 放在 “叶子节点” 中，并
在 每个结点 中 维护一个 “名为freq的实例变量” - 用于表示 “以它为根结点的子树”中的 所有字符(??) 出现的频率

==
#1 构造的第一步 是：
创建一片 由 许多个 “只有一个结点（叶子结点）的树” 所组成的 森林。
其中 每棵树（结点） 都表示 输入流中的一个字符。
而 “结点中的freq变量”的值 表示 它 在输入字符序列中的 出现频率；

在 我们的例子 中，输入中 含有8个t，5个e，11个空格 等
（🐖 为了 得到 这些频率，我们 需要读取 整个输入流。
因此“霍夫曼算法”是一个 两轮算法 - 因为只有 先读取输入流 之后，才能 压缩它）。

==
#2 接下来 自底向上地 根据频率 来 构造 这棵用于编码的 “前缀码单词查找树”。

在 构造 时，把它看作 一棵 “结点中含有频率信息”的 二叉树；
在 构造完成 后，我们才把它看作 一棵 “用于编码的单词查找树”。

构造过程如下：
首先 找到 两个 频率最小的结点，
然后 创建一个 “以两者作为子结点的 新结点”（新节点的“频率值” 是 它的两个子结点的频率值 之和）。
    🐖 这个操作 会 把 森林中的树的数量 减一。
再 不断重复 这个过程：找到 森林中 两棵 频率最小的树，并 使用 相同的方式 创建一个 新的结点。

使用 优先级队列 能够 轻易地实现 这个过程，如 框注的buildTrie()方法 所示。
🐖 为了 说明这个过程，图中的 所有单词查找树 都是 有序的。

随着 这个过程的继续，我们 所构造的 单词查找树 会 越来越大，相对地，
森林中的树 会 越来越少（因为 在每一步中，都会 删除两棵树，添加 一棵新的树）。

==
#3 最终，所有的结点 都会 被合并为 一棵单独的单词查找树。
这棵树的“叶子节点” 为： ① 所有 “待编码的字符” 和 ② 它们 在输入中 出现的频率。

特征：
#1 每个 非叶子节点中的频率值 为 它的两个子结点的 频率值 之和。
#2 “频率较低的结点” 会 被安排在 树的底层。而 “高频率的结点”则会 被安排在 “根结点附近的地方”。
#3 根结点的频率值 等于 输入中的 字符总数量。

因为 这是一棵 二叉树 且 字符 仅存在于 叶子节点 中，所以👇
它 定义了 这些个字符的前缀码。

由 “前缀码单词查找树” 能够得到 字符集的编译表（如图示），再 使用 buildCode()方法，就能够得到 “原始字符序列” 经过压缩后的 输出👇
《原始字符序列》
《构造单词查找树的代码》
《根据编译表与原始字符序列得到编码结果的代码》

《比特字符串》

==
观察👇
这个 比特字符串 长176位，相比 用“标准的8位ASCII编码” 所需要的 408位编码（51个字符），
它 节省了 57%（没有计入 “构造编码”操作的 开销，下面会讨论👇）。

结论👇
另外，因为 它 是一个 “霍夫曼编码”，所以 不会存在 任何其他 能够使用 更少的比特 来 “把输入进行编码”的前缀码 了。

《单词查找树的构造过程》
构造一棵 霍夫曼编码 单词查找树👆

《单词查找树的构造结果》
字符串"it was the best of times it was the worst of times LF" 的霍夫曼编码👆