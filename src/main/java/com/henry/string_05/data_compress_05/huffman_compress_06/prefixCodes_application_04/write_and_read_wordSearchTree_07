==
写入和读取 单词查找树

我们已经强调过，前面讨论过的空间节约并不准确👇
因为如果没有单词查找树的话，被压缩/编码的比特流 是无法被解压/解码的。
所以，我们必须 把“用于输出 比特字符串中的单词查找树”的成本 考虑进来。

对于较长的输入，这个成本相对较小。
但是为了 保证“数据压缩流程”的完整，必须要在压缩时，把“树本身”写入比特流，以便能够在展开时读取它 来 解码“编码结果”。

怎么才能 #1 把一棵单词查找树 给编码成为比特流，#2 并展开它呢？
其实，只要 基于“单词查找树的前序遍历结果”，那么
这两个任务（#1 + #2） 都只需要 很简单的递归 就能够完成。

==
#1 把单词查找树，按照特定的规则编码成为比特流

下面框注的writeTrie()方法 会按照 前序规则 来 遍历单词查找树：
当它访问的是 一个内部结点时，它会写入一个比特0；
当它访问的是 一个叶子节点时，它会写入一个比特1，
紧接着是，此叶子节点中的字符的 8位ASCII编码。

A B R A C A D A B R A！的霍夫曼树的比特字符串编码如图（略）。
第一位是0，对应着根结点；
下一个遇到 含有A的叶子节点，所以下一位是1，
紧接着是 01000001，也就是A的8位ASCII编码。
下两位都是0，因为遇到的都是 两个内部节点，等等。

==
#2 展开比特流/编码结果，得到“单词查找树”

相应的readTrie()如框注所示。
它从比特字符串中，重新构造了单词查找树👇
首先读取一个比特 来 得到当前结点的类型；
    Ⅰ 如果是叶子节点（比特为1），那么就读取字符的编码，并创建一个叶子节点；
    Ⅱ 如果是内部节点（比特为0），那么就创建一个内部节点，并（递归地）继续构造它的左右子树。
请一定要理解这些方法：它们的简洁性 有时候 是有欺骗性的。

《代码块》
把单词查找树 按照特定的规则编码为 比特字符串👆

《树的图示 & 对树的编码结果》
按照前序遍历的规则 来 把一棵单词查找树编码成为 比特流👆

《代码块》
从前序表示结果的比特流中，重建单词查找树