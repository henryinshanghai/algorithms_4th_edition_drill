==
最优性

我们已经看到，在“霍夫曼树”/“前缀码单词查找树”中，高频率的字符 比起 低频率的字符 离“根结点”会更近，
因此（按照使用前缀单词查找树对字符进行编码的规则）编码它所需要的比特 就会更少 -> 所以这种编码方式更好。

但为什么这是一种 最优的前缀码呢？

要回答这个问题，首先需要定义 树的“加权外部路径长度”这个概念，
它是所有“叶子节点的权重”（频率）和“深度”（见1.5.2.5节）之积的和。

==
命题T 对于任意前缀码，“编码后的比特字符串”的长度 等于 相应“单词查找树”的“加权外部路径长度”。
证明：每个“叶子节点的深度” 就是 把“该叶子节点的字符”进行编码 所需要的比特数。
因此，“加权外部路径长度” 就是 “编码后的比特字符串”的长度 - 它等于 所有字符的“出现次数” 和 “其编码长度”之积 的和。

在示例中，有一个叶子节点的距离为2（SP，出现频率为11），
三个叶子节点的距离为3（e、s和t，总频率为19=“深度相同的各个结点”上的 “字符的频率” 累加和），
三个叶子节点的距离为4（w、o和i，总频率为10），
五个叶子节点的距离为5（r、f、h、m、a，总频率为9），
两个叶子节点的距离为6（LF和b，总频率为2）.
因此综合为 2*11+3*19+4*10+5*9+6*2=176.
这与 输出的比特字符串的长度预期 相等。

==
命题U 给定一个含有r个符号的集合 和 各个字符的出现频率，使用霍夫曼算法 构造得到的前缀码 是最优的。
证明 数学归纳法。
假设霍夫曼编码对于任意规模小于r的符号集合 都是最优的。
设TH是 使用霍夫曼算法 计算并编码 符号集和相应的频率(s1,f1)...(sr,fr)所得到的输出，
并使用 W(TH) 表示输出的总长度（单词查找树的加权外部路径长度）。

假设(si,fi)和(sj,fj)是最先被选中的两个符号，
那么 算法接下来会计算(si,fi)和(s*,fj)被(s*,fi+j)所替换后的
r-1个符号的编码 来 输出Th*, 其中s*表示 深度为d的某个叶子节点中的新符号。

可以注意到：
W(TH)=W(TH*)-d(fi+fj)+(d+1)(fi+fj)=W(Th*)+(fi+fj)

...

因为T是最优的，等号必然成立，因此TH也是最优的。

==
观察👇
在霍夫曼算法中，当一个结点被选中时，也可能有若干个结点 和它的权重相同。
霍夫曼算法 并没有说明 如何区分它们，也没有说明 应该如何确定 子结点的左右位置。
因此，不同的选择 会得到 不同的霍夫曼编码，
但是 使用它们 把信息进行编码 所得到的比特字符串，在所有前缀码中 总会是（都是）最优的。
