==
最优性

我们 已经看到，在 “霍夫曼树”/“前缀码单词查找树” 中，高频率的字符 比起 低频率的字符 离“根结点” 会 更近，
因此（按照 使用 前缀单词查找树 对 字符 进行编码 的规则）编码它 所需要的比特 就会更少 -> 所以 这种编码方式 更好。

但为什么 这是一种 最优的前缀码 呢？

要回答 这个问题，首先 需要定义 树的“加权外部路径长度” 这个概念，
它是 所有“叶子节点的权重”（频率） 和 “深度”（见1.5.2.5节）之积 的和。

==
命题T 对于 任意前缀码，“编码后的比特字符串”的长度 等于 相应“单词查找树”的“加权外部路径长度”。
证明：每个 “叶子节点的深度” 就是 把 “该叶子节点的字符” 进行编码 所需要的 比特数。
因此，“加权外部路径长度” 就是 “编码后的比特字符串”的长度 - 它 等于 所有字符的“出现次数” 与 “其编码长度”之积 的和。

在示例中，有一个 叶子节点的距离 为 2（SP，出现频率为11），
三个 叶子节点的距离 为3（e、s和t，总频率 为 19=“深度相同的各个结点”上 的 “字符的频率” 累加和），
三个 叶子节点的距离 为4（w、o和i，总频率 为 10），
五个 叶子节点的距离 为5（r、f、h、m、a，总频率 为 9），
两个 叶子节点的距离 为6（LF和b，总频率 为 2）.
因此 综合为 2*11+3*19+4*10+5*9+6*2=176.
这 与 输出的比特字符串的 长度预期 相等。

==
命题U 给定一个 含有r个符号的 集合 和 各个字符的出现频率，使用 霍夫曼算法 构造得到的 前缀码 是最优的。
证明 数学归纳法。
假设 霍夫曼编码 对于 任意规模小于r的符号集合 都是最优的。
设TH是 使用霍夫曼算法 计算并编码 符号集 和 相应的频率(s1,f1)...(sr,fr) 所得到的输出，
并 使用 W(TH) 表示 输出的总长度（单词查找树的 加权外部路径长度）。

假设(si,fi)和(sj,fj)是 最先被选中的 两个符号，
那么 算法 接下来会计算 (si,fi) 和 (s*,fj) 被(s*,fi+j)所替换后的 r-1个符号的编码 来 输出Th*,
其中 s* 表示 深度为d的 某个叶子节点中的 新符号。

可以注意到：
W(TH)=W(TH*)-d(fi+fj)+(d+1)(fi+fj)=W(Th*)+(fi+fj)

...

因为 T 是 最优的，等号 必然成立，因此 TH 也是最优的。

==
观察👇
在 霍夫曼算法 中，当 一个结点 被选中 时，也可能有 若干个结点 和 它的权重 相同。
霍夫曼算法 并没有说明 如何区分 它们，也没有说明 应该 如何确定 子结点的左右位置。
因此，不同的选择 会得到 不同的霍夫曼编码，
但是 使用它们 把 信息 进行编码 所得到的比特字符串，在 所有前缀码中 总会是（都是）最优的。
