==
使用前缀码压缩

在压缩时，我们使用 单词查找树所定义的编码规则 来 构造编译表，
如框注的buildCode()方法所示。
《buildCode()方法代码》
此方法 短小而优雅，其巧妙之处 值得仔细研究。

对于任意的单词查找树，它都能产生一张
把 树中的字符 和 比特字符串（用由0和1组成的String字符串表示） 对应起来的编译表。

“编译表”就是一张 把每个字符和它的比特字符串（编码结果） 相关联的符号表：
为了提升效率，我们使用了一个 由字符索引的数组st[]，而不是普通的符号表。
因为字符的数量不会很多👆

在构造这个“符号表”时，buildCode()会递归遍历整棵树，
并为“每个节点”都 维护一条 从根结点到它的路径 所对应的“二进制字符串/比特字符串”
（0表示左连接，1表示右链接）。

每当到达了一个“叶子结点”的时候，算法 就会
把“该结点所表示的字符”的编码结果 设置为 “该二进制字符串”。

编译表建立完成后，压缩任务就很简单了👇
只需要在编译表中查找出 “输入字符”所对应的编码结果 就可以了。

使用如下框注的编码 来 压缩 A B R A C A D A B R A ！👇
首先 写入0（A的编码结果），
然后是 111（B的编码结果），
然后是 110（R的编码结果）等等。

框注中的这一段代码 所完成的任务是：
#1 查找出 “输入中的每一个字符” 所对应的编码String对象，
#2 把char[]数组中的字符 转化成为 0和1的值，
#3 并写入到 “输出的比特字符串”中。