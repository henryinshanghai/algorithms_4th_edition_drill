==
使用前缀码 进行压缩

在 压缩 时，我们使用 单词查找树 所定义的编码规则 来 构造编译表，
如 框注的buildCode()方法 所示。
《buildCode()方法代码》
此方法 短小而优雅，其巧妙之处 值得 仔细研究。

对于 任意的单词查找树，它都能 产生一张
把 树中的字符 和 比特字符串（用 由0和1组成的 String字符串 表示） 对应起来的编译表。

“编译表” 就是一张 把 每个字符 和 它的比特字符串（编码结果） 相关联的符号表：
为了 提升效率，我们 使用了一个 由字符索引的 数组st[]，而不是 普通的符号表。
因为 字符的数量 不会很多👆

在 构造 这个“符号表” 时，buildCode()会 递归遍历 整棵树，
并 为 “每个节点” 都 维护一条 从 根结点 到 它 的路径，该路径 对应着 一个“二进制字符串/比特字符串”（0 表示 左连接，1 表示 右链接）。

每当 到达了 一个“叶子结点” 的时候，算法 就会
把 “该结点 所表示的字符” 的编码结果 设置为 “该二进制字符串”。

编译表 建立完成 后，压缩任务 就很简单 了👇
只需要 在 编译表 中 查找出 “输入字符”所对应的编码结果 就可以了。

使用 如下框注的编码 来 压缩 A B R A C A D A B R A ！👇
首先 写入0（A的编码结果），
然后是 111（B的编码结果），
然后是 110（R的编码结果）等等。

框注中的 这一段代码 所完成的任务 是：
#1 查找出 “输入中的每一个字符” 所对应的 编码String对象，
#2 把 char[]数组中的字符 转化成为 0和1的值，
#3 并 写入到 “输出的比特字符串” 中。