==
使用前缀码展开

有了 “定义了前缀码”的单词查找树后，展开 “被编码的比特流” 就比较简单了。
左边框注中的expand()方法 实现了 这个过程。
《具体代码参考Huffman》

在从标准输入中，使用后文所述的readTrie()方法，读取了“单词查找树”之后，
用它把“比特流的其余部分”展开👇
#1 根据比特流的输入，从根节点开始向下移动；
    手段：读取一个比特 - 如果为0则移动到左子结点，如果为1则移动到右子节点。
#2 当遇到叶子节点后，输出该结点的字符，并重新回到 根结点。

如果你仔细研究这个方法 在图中的“小型前缀码示例”中的表现，就能够理解这个过程。
比如，在解码 比特流xxx时👇
#1 从根节点开始...
    因为第一个比特是0，所以移动到左子结点，输出A；
#2 回到根结点，向 右子节点移动3次，然后输出B；
#3 回到根结点，向右子节点移动两次，左子结点移动1次，输出R；
如此往复。

🐖 展开的简单性 也是 前缀码（特别是 霍夫曼压缩算法）流行的原因之一。