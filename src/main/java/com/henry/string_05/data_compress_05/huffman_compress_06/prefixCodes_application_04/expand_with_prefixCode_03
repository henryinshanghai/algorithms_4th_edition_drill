==
使用前缀码 进行展开/解码

有了 “定义了前缀码”的 单词查找树 后，展开 “被编码的比特流” 就 比较简单 了。
左边框注中的 expand()方法 实现了 这个过程。
《具体代码参考Huffman》

在 从 标准输入 中，使用 后文所述的readTrie()方法，读取了 “单词查找树” 之后，
用 该单词查找树 来 把 “比特流的其余部分” 展开👇
#1 根据 比特流的输入，从 根节点 开始 向下移动；
    手段：读取 一个比特 - 如果 为0 则 移动到 左子结点；如果 为1 则 移动到 右子节点。
#2 当 遇到 叶子节点 后，输出 该结点的字符，并 重新回到 根结点。

如果你 仔细研究 这个方法 在 图中的 “小型前缀码示例” 中的表现，就能够理解 这个过程。
比如，在 对 比特流xxx 进行解码 时👇
#1 从 根节点 开始...
    因为 第一个比特 是 0，所以 移动到 左子结点，输出A；
#2 回到 根结点，向 右子节点 移动3次，然后 输出B；
#3 回到 根结点，向 右子节点 移动两次，左子结点 移动1次，输出R；
如此往复。

🐖 展开的简单性 也是 前缀码（特别是 霍夫曼压缩算法）流行的原因之一。