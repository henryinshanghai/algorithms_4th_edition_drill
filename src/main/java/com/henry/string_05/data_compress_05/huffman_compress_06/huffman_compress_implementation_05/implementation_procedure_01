==
霍夫曼压缩的实现

算法5.10 加上 之前讨论过的 buildCode(), buildTrie(), readTire()和writeTrie()
（以及一开始展示的expand()方法），就是 霍夫曼压缩算法的完整实现。

为了展开 前文对算法的概述，我们 把 需要压缩的比特流 看作为 8位编码的Char值流，
并按照如下方法压缩：
#1 读取输入；
#2 把输入中的每个char值的出现频率 制作成表格；
#3 根据频率 来 构造相应的霍夫曼编码树；
#4 根据编译表，把 输入中的每个char值 和 一个比特字符串 相关联；
#5 把 单词查找树 编码为 比特字符串，并写入输出流；
#6 把 单词总数 编码为 比特字符串，并写入输出流；
#7 使用编译表 来 翻译每个输入字符。

要展开一条 编码过的比特流，步骤如下👇
#1 读取“单词查找树”（其编码结果在比特流的开头）；
#2 读取“需要解码的字符数量” characterAmount；
#3 使用单词查找树 来 把比特流解码(aka 得到“指定编码所对应的字符”)。

霍夫曼压缩算法 含有4个递归方法 来 处理“单词查找树”，
整个压缩过程 需要7个步骤，它是我们学习的 较为复杂的算法之一，如图。
但因为效率高，所以 它也是 应用最为广泛的算法之一。

《代码》
这段 霍夫曼编码算法的实现 构造了一棵 清晰的编码单词查找树，并使用了 前文所述的各种辅助方法。

《用例执行的结果》 怎么能使用IDEA来执行这些类??
使用霍夫曼编码压缩（编码）和展开（解码）字节流