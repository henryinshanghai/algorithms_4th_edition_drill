==
霍夫曼压缩的实现

算法5.10 加上 之前讨论过的 buildCode(), buildTrie(), readTire()和writeTrie()
（以及一开始展示的expand()方法），就是 霍夫曼压缩算法的完整实现。

为了 展开 前文对算法的概述，我们 把 需要压缩的比特流 看作为 8位编码的Char值流，
并按照 如下方法 进行压缩：
#1 读取 输入；
#2 把 输入中的 每个char值的 出现频率 制作成 表格；
#3 根据 频率 来 构造出 相应的 霍夫曼编码树；
#4 根据 编译表，把 输入中的每个char值 和 一个比特字符串 相关联；
#5 把 单词查找树 编码为 比特字符串，并 写入 输出流；
#6 把 单词总数 编码为 比特字符串，并 写入输出流；
#7 使用 编译表 来 翻译 每个输入字符。

要 展开 一条 编码过的比特流，步骤如下👇
#1 读取 “单词查找树”（其编码结果在比特流的开头）；
#2 读取 “需要解码的字符数量” characterAmount；
#3 使用 单词查找树 来 把 比特流解码(aka 得到“指定编码所对应的字符”)。

霍夫曼压缩算法 含有4个递归方法 来 处理“单词查找树”，
整个压缩过程 需要 7个步骤，它是我们学习的 较为复杂的算法之一，如图。
但因为 效率高，所以 它也是 应用最为广泛的算法之一。

《代码》
这段 霍夫曼编码算法的实现 构造了一棵 清晰的编码单词查找树，并 使用了 前文所述的 各种辅助方法。

《用例执行的结果》 怎么能使用IDEA来执行这些类??
使用霍夫曼编码压缩（编码） 和 展开（解码）字节流