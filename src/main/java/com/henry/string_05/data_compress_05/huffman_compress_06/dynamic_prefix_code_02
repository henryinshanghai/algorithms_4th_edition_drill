==
变长前缀码

和每个字符所相关联的编码 都是一个“比特字符串”。
就好像存在一个 以”字符“为键、以“比特字符串”作为值的 符号表一样。

我们可以试着 把“最短的比特字符串” 赋予 “最常用的字符”，
频率统计：A出现了5次、B出现了2次、C出现了1次、D出现了1次、R出现了1次
据此可进行以下编码👇
把A编码为0、B编码为1、R为00、C为01、D为10、！为11.

这样 A B R A C A D A B R A !的编码就是👇
0 1 00 0 01 0 10 0 1 00 0 11.
这种表示方式 只用了17位，而使用“7位的ASCII编码”时，则使用了 84位。
但这种表示方式 并不完整，因为 它需要使用空格 来 区分字符。

如果没有空格，比特字符串就会变成下面的样子👇
01110010100100011

它也可以 被解码成为 C R R D E C R C B 或者是 其他的字符串。
所以我们需要 为它添加上11个分隔符。
但是即使 17位 加上 11个分隔符，它也要比 标准的编码方式 紧凑的多了，
那些个 没有“用于编码”的比特字符 则不会出现在这条消息中。

进一步设想👇
对于字符集中的任意字符，如果”其字符的编码“ 都不会成为 “其他字符编码的前缀”，那么 就不再需要分隔符了。
因为只需要一直读取比特序列，一旦发现它有对应的编码结果字符，那么 这个字符就一定是唯一的。
下一步我们要做的就是这一点👆

含有”这种性质“的编码规则 叫做 前缀码。
刚才我们给出的编码 并不是 前缀码，因为 ”A的编码“0 就是”R的编码“00 的前缀。

比如，如果我们把A编码为0、B编码为1111、C编码为110、D编码为100、！编码为101，
那么 把以下”长为30的比特字符串“ 进行解码的方式 就只有 A B R A C A D A B R A！这一种了：
《比特字符串》

所有的前缀码的解码方式 都和它一样，是唯一的（不需要任何分隔符），
因此 ”前缀码“ 被广泛应用于 实际生产之中。
注意，像”7位ASCII编码“这样的”定长编码“ 也是 前缀码。
