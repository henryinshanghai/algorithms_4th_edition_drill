==
变长前缀码

和 每个字符 所相关联的 编码 都是一个“比特字符串”。
就好像 存在一个 以”字符“为键、以“比特字符串”作为值的 符号表 一样。

我们 可以试着 把 “最短的比特字符串” 赋给 “最常用的字符”，
频率统计：A 出现了 5次、B 出现了 2次、C 出现了 1次、D 出现了 1次、R 出现了 1次
据此 可进行 以下编码👇
把 A 编码为 0、B 编码为 1、R 为 00、C 为 01、D 为 10、！为 11.

这样 A B R A C A D A B R A ! 字符串的编码结果 就是👇
0 1 00 0 01 0 10 0 1 00 0 11.
这种表示方式 只用了 17位，而 使用“7位的ASCII编码” 时，则 使用了 84位。
但 这种表示方式 并不完整，因为 它需要 使用空格 来 区分字符。

如果 没有空格，比特字符串 就会变成 下面的样子👇
01110010100100011

它 也可以 被解码成为 C R R D E C R C B 或者是 其他的字符串。
所以我们需要 为 它 添加上 11个分隔符。
但是 即使 17位 加上 11个分隔符，它 也要 比 标准的编码方式 紧凑的多了，
那些个 没有“用于编码”的 比特字符 则不会 出现 在这条消息中。

进一步设想👇
对于 字符集中的 任意字符，如果 ”该字符的编码“ 都不会成为 “其他字符编码的前缀”，那么就 不再需要 分隔符 了。
因为 只需要 一直读取 比特序列，一旦发现 它有 对应的 编码结果字符，那么 这个字符 就一定 是 唯一的。
下一步我们要做的 就是这一点👆

含有 ”这种性质“的 编码规则 叫做 前缀码。
刚才我们给出的编码 并不是 前缀码，因为 ”A的编码“0 就是 ”R的编码“00 的前缀。

比如，如果我们 把A 编码为 0、B 编码为 1111、C 编码为 110、D 编码为 100、！编码为 101，
那么 把 以下”长为30的比特字符串“ 进行解码的方式 就只有 A B R A C A D A B R A！这一种了：
《比特字符串》

所有的 前缀码的解码方式 都 和它一样，是 唯一的（不需要 任何分隔符），
因此 ”前缀码“ 被广泛应用于 实际生产之中。
注意，像”7位ASCII编码“这样的”定长编码“ 也是 前缀码。
