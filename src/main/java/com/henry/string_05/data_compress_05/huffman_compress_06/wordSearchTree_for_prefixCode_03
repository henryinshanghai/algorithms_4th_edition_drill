==
前缀码的单词查找树

表示前缀码的 一种简便方式 就是使用 单词查找树（5.2节）。

事实上，任何 含有M个空链接的 ”单词查找树“ 都 为 ”M个字符“ 定义了 一种前缀码方法👇
如果我们 把 ”空链接” 替换成为 指向“叶子节点（也就是 含有两个空链接的结点）“的链接，
那么 每个叶子节点中 就都会 含有一个 “需要被编码的字符”。

这样，对于 每个字符，“其字符编码” 就是 从 根结点 到 该结点的路径 所表示的“比特字符串”，
其中 左链接 表示 比特0，右链接 表示 比特1.
例如，如图 显示了 字符串 A B R A C A D A B R A！中的 字符的两种“前缀码方式”。

《字符串 经由“前缀码1方式” 压缩所得到的 比特字符串》
《字符串 经由“前缀码2方式” 压缩所得到的 比特字符串》

上方的例子 就是 我们刚才提到的 编码方式，下方的编码 得到的比特字符串 为👇
《比特字符串》

该字符串 只有 29位，比起 上一种 少了一位。

==
追问：是否存在 “能够压缩得更多”的 单词查找树呢？
我们 如何才能够找到 “压缩率最高”的前缀码？

实际上，这些问题 都有一个 优雅的解。

有一种算法 能够 为 任意字符串 构造一棵 能够“把比特流最小化”的 单词查找树。
为了 公平地比较 各种编码，还需要 计算“编码本身所需要的空间”（因为 没有它 的话，我们就 没办法 把 字符串 解码👆。）

你会看到，编码的方式 是 和 字符串 相关的。

寻找“最优前缀码”的通用方式 是 D.Huffman 在1952年 发现的（当时他 还是个学生！），
因此被称为 “霍夫曼编码”。