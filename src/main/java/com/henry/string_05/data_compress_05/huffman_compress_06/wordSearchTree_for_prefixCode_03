==
前缀码的单词查找树

表示前缀码的一种简便方式 就是使用单词查找树（5.2节）。

事实上，任何含有M个空链接的”单词查找树“都 为”M个字符“定义了一种前缀码方法👇
如果我们 把”空链接” 替换成为 指向“叶子节点（也就是含有两个空链接的结点）“的链接，
那么 每个叶子节点中 就都会含有一个 “需要被编码的字符”。

这样，对于每个字符，“其字符编码” 就是 从根结点到该结点的路径 所表示的“比特字符串”，
其中左链接表示比特0，右链接表示比特1.
例如，如图显示了 字符串 A B R A C A D A B R A！中的 字符的两种“前缀码方式”。

《字符串经由“前缀码1方式”压缩所得到的比特字符串》
《字符串经由“前缀码2方式”压缩所得到的比特字符串》

上方的例子就是我们刚才提到的编码方式，下方的编码得到的比特字符串为👇
《比特字符串》

该字符串只有29位，比起上一种少了一位。

==
追问：是否存在 “能够压缩得更多”的单词查找树呢？
我们如何才能够找到 “压缩率最高”的前缀码？

实际上，这些问题 都有一个 优雅的解。

有一种算法能够 为任意字符串 构造一棵 能够“把比特流最小化”的单词查找树。
为了 公平地比较 各种编码，还需要 计算“编码本身所需要的空间”
（因为没有它的话，我们就没办法把字符串解码👆。）

你会看到，编码的方式 是 和字符串相关的。

寻找“最优前缀码”的通用方式 是 D.Huffman在1952年发现的（当时他还是个学生！），
因此被称为 “霍夫曼编码”。
