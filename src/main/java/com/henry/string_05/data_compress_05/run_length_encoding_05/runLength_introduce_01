===
游程编码

比特流 中 最简单的冗余形式 就是 一长串重复的比特。
下面我们 学习一种 经典的 游程编码（Run-Length Encoding）,
它 利用 这种冗余 来 压缩数据。
比如，下面这个 40位长的字符串：
00000,00000,00000,11111,11000,00001,11111,11111

这个字符串 包含有 15个0，然后是 7个1，然后是 7个0，然后是 11个1，
因此我们可以 把 这个比特字符串 编码成为 15,7,7,11。

由于 所有的比特字符串 都是 由 交替出现的0和1 所组成的，
因此我们 只需要 对 “游程的长度” 进行编码 即可。 // 游程中具体是0还是1呢??

在这个例子中，如果
#1 使用 4位二进制数 来 表示长度，并且
#2 使用 连续的0 来 作为”二进制数的开头“，那么👇
就可以得到 一个16位长的字符串(15=1111, 7=0111, 7=0111, 11=1011):
    1111,0111,0111,1011

使用”游程这种方式“ 得到的 压缩率 为 16/40=40%。
为了 把 这里的描述 转化成为 一种有效的数据压缩方法。
我们 需要解决 以下几个问题👇
#1 应该使用 多少位的比特 来 记录”游程的长度“？（上例中 使用的是 4位比特）
#2 如果 某个游程的长度 超过了 ”所能够记录的 最大游程长度“ 时，要 怎么处理？
#3 如果 某个游程的长度 所需要的比特位数 少于 ”用于记录游程长度“的比特位数 时，要 怎么处理？

我们 所感兴趣的 比特流类型 是：“在其中 短游程相对较少的 长比特流”
因此 上述问题的答案 是：
#1 游程长度 应该在0-255之间，这样我们 就能够 使用”8位二进制数字“ 来 为其编码；
#2 在 需要的情况 下，使用”长度为0的游程“?? 来保证 所有游程的长度 都会 小于256；// how??
#3 我们也会 把 “短游程” 进行编码（这 会使得 最终的输出 变长）

这些决定 非常容易实现，而且 对于 实际应用中 经常出现的 几种比特流 非常有效。
它们 不适用于 含有大量“短游程”的输入👇
因为 原理上 讲，只有 在”游程的长度“ 大于 ”将它们用二进制表示“所需要的长度 时，才能够 节省空间；
而 短游程 可能会导致 其二进制表示的长度 比起 其本身的长度 还要更长...😳
