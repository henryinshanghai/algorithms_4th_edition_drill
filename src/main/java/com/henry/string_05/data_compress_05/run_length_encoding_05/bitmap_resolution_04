==
提高 位图的 分辨率

游程编码 广泛应用于 位图 的 主要原因是👇
随着 分辨率的提高，它的效果 也会 大大的提高。

证明 这一点 很简单。
假设 把 上一个例子中的分辨率 给 提高一倍，则：
#1 总比特数 变成了 原来的4倍；
#2 其中游程的数量 变成了 差不多原来的2倍；
#3 游程的长度 变成了 差不多原来的2倍；
#4 压缩后的比特数量 变成了 差不多原来的2倍；
#5 因此，压缩率 变成了 原来的一半！

没有使用 “游程编码” 时，如果 分辨率 提高一倍，则：图像所需的空间 就会变成 原来的4倍；
使用了 “游程编码” 之后，如果 分辨率 提高一倍，则：“压缩后的比特流的长度” 只会变成 原来的2倍。

也就是说，随着 所需空间的 增大，压缩比 与 分辨率 成反比；

比如，我们的字母“q”（在 低分辨率 时）的压缩率为74%；
如果 把 分辨率 提高到 64×96，压缩比 就下降为 37%；

我们 从 图中 PictureDump的输出 中，可以明显地 看出 这个变化。

高分辨率的字符图像 所需要的空间 是 低分辨率字符图像的4倍（因为 两个维度上的长度 都加倍了），
但是 压缩后的版本 所需要的空间 就只有 原来的2倍（只 在一个维度上 增倍）。

如果 继续 把 分辨率 提高到 128×192（这 已经接近于 打印所需要的 分辨率），
则 压缩率会 进一步下降到 18%。

小型测试用例(40位)

ASCII文本（96位）

一幅位图（1536位）

一幅分辨率更高的位图（6144位）

图略
使用 游程编码 来 压缩 和 展开 比特流

游程编码 在许多场景中 非常有效，但是 在 许多情况 下 我们想要压缩的比特流
并不会包含有 较长的游程（比如 典型的英文文档）。

下面我们 来 学习两种 适用于 多种类型的文件 压缩算法。
它们的应用 非常广泛，在 从网络上 下载文件 时，就很可能 会使用到它们。