==
二进制的输入输出

今天，大多数系统的 输入输出系统，包括Java，都是基于 8位的字节流 的，
因此 我们的API 也许应该 读写字节流（byte stream），以便 与 “原始数据类型的内部表示”的输入输出格式 相匹配。
原始数据类型的数据 所对应的字节大小 如下👇
#1 char类型 被编码为 一个字节（8位）；
#2 short类型 被编码为 2个字节（16位）；
#3 int类型 被编码为 4个字节（32位），等等。

因为 比特流 是 数据压缩的 主要抽象层次，这就需要 更进一步👇
允许用例 能够读写 ① 单个的比特 以及 ② 原始类型的数据。

我们的目标是 ① 尽量减少 用例 所需要进行的 类型转换，
② 并按照 操作系统的要求 来 表示数据。

下表中的API 从标准输入中 读取比特流。
    readBoolean() 读取 一位数据，并 返回一个 boolean值
    close() 关闭 比特流

与 StdIn 明显不同的是，这份抽象API的一个关键特性 在于👇
标准输入中的数据 并不一定是 与 字节边界 对齐的。

==
如果 输入流 只含有一个字节，则：
用例可以 一个比特一个比特地 调用8次readBoolean()方法 来 读取它。
这里虽然 close()方法 并不十分重要，但是 为了能够 终止输入，
用例 应该使用 close()方法 来 表示 不会再读取 任何数据。

和 StdIn 与 StdOut 一样，使用下表中的 补充API 来 向标准输出中 写入比特流。

write(boolean b) 写入 指定的比特
write(char c) 写入 指定的8位字符
...

==
对于 输出，close()方法 就很重要了：
用例 必须使用 close()方法 来 保证 之前调用write()方法 所处理的所有数据 都写入比特流，
比特流的最后一个字节 必须 用0来补齐 以此来保证 和文件系统的兼容性。

StdIn 与 StdOut 有 In 与 Out这两份API，与之关联，这里
也通过 BinaryIn 和 BinaryOut 来 直接使用 二进制编码的文件。