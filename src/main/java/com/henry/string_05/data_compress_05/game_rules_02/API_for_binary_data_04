==
二进制的输入输出

今天，大多数系统的输入输出系统，包括Java，都是基于 8位的字节流的，
因此 我们的API 也许应该 读写字节流（byte stream），以便 与“原始数据类型的内部表示”的输入输出格式 相匹配。
原始数据类型的数据 所对应的字节大小如下👇
#1 把8位char 给编码为 一个字节；
#2 16位的short 编码为2个字节；
#3 32位的int 编码为4个字节，等等。

因为 比特流 是 数据压缩的主要抽象层次，这就需要 更进一步👇
允许用例读写 ① 单个的比特 以及 ② 原始类型的数据。

我们的目标是 #1 尽量减少 用例所需要进行的类型转换，
#2 并按照操作系统的要求 来 表示数据。

下表中的API 从标准输入中 读取比特流。
readBoolean() 读取一位数据，并返回一个boolean值
close() 关闭比特流

与StdIn明显不同的是，这份抽象API的一个关键特性在于👇
标准输入中的数据 并不一定是 与字节边界对齐的。

==
如果输入流 只含有一个字节，则：
用例可以 一个比特一个比特地调用8次 readBoolean()方法 来 读取它。
这里虽然 close()方法并不十分重要，但是为了能够 终止输入，
用例应该使用close()方法 来表示 不会再读取任何数据。

和StdIn与StdOut一样，使用下表中的补充API 来 向标准输出中写入比特流。

write(boolean b) 写入指定的比特
write(char c) 写入指定的8位字符
...

==
对于输出，close()方法就很重要了：
用例必须使用close()方法 来 保证之前调用write()方法 所处理的所有数据 都写入比特流，
比特流的最后一个字节 必须用0来补齐 以此来保证 和文件系统的兼容性。

StdIn与StdOut 有In与Out这两份API，与之关联，这里
也通过BinaryIn和BinaryOut 来 直接使用 二进制编码的文件。