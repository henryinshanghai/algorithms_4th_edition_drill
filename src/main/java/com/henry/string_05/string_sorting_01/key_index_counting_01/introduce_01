学习一种 适用于小整数键 的简单排序方法。
名称：键索引计数。

在一个班级中，学生 被分成 若干组，组号1、2、3、4.
目标：把 全班同学 按组号来排序。
特征：组号 是一个 比较小的整数；因此可以使用 键索引计数法 来 进行排序。

原始数组a[] 中的每个元素 都保存了 一个名字 与 他所属的组号。
a[i].key() 会返回 指定学生的组号。

算法的步骤：
#1 对 每一个组号对应的组 中的元素数量 进行频率统计；
when a[spot].key() => groupNo, then count[groupNo+1]++
每当 出现 特定组号的元素 时，就把 它累计到 其对应组号的元素数量中；
    手段：把 count[组号+1]这个元素的值 加1；
    变量表示：使用 groupNoPlus1ToGroupSize[] 来 表示count[]

#2 把 频率 转换成为 索引；
目标：计算出 每个组中的键集合 在“最终排序结果”中的 起始索引位置；
手段：从左往右，把 当前groupNo的groupSize 给累加到 下一个groupNo上；
结果：groupNoPlus1ToGroupSize => groupNoToItsStartIndexInFinalSequence[]
特征：这就是为什么在#1中，出现了诡异的groupNo+1。是为了 能够得到 满足使用习惯的数组

#3 得到 有序的辅助数组aux；
目标：根据 原始数组a[], 得到一个 有序的辅助数组aux[];
手段：对于 原始数组a[]的当前元素，使用 groupNoToItsStartIndexInFinalSequence[] 来 确定 它会被排定到的 aux[]的具体位置；
用法：
    对于 Anderson，他的组号 是2，startIndex 是3. 所以 他会被放在 aux[3]的位置上；
    🐖 放置完成 后，把 groupNo所对应的startIndex 给+1. 这样 当 下次遇到 同一组号中别的元素 时，就能够 以正确的方式 顺序放置它。
    对于Brown，他的组号 是3，startIndex 是8，所以 他会被放在 aux[8]的位置上；
        groupNoToItsStartIndexArr[3] = 8 + 1;
    对于Davis，他的组号 是3，startIndex 是9，所以 他会被放在 aux[9]的位置上
    so on and so forth...
特征：同一组号中的多个元素，在排序后 会被聚集到一起，而且 相对顺序 没有变化。

#4 把 有序的辅助数组aux中的元素 回写到 原始数组中，来 完成 对原始数组的排序；

总结：
#1 最终得到的结果序列 并不是 ”元素完全有序的“，但是满足 ① 组间有序（按照组号）与 ② 组内元素的相对顺序不变。
这个更像是 对元素进行“排列”，而不是“排序”。
