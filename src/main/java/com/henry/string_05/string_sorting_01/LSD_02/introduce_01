我们学习的第一个字符串排序算法 叫做 低位优先的字符串排序。

考虑以下应用：
假设有一个工程师 架设了一个设备 来 记录给定时间段内，
某条忙碌的高速公路上经过的所有车辆的车牌号。
他希望直到 总共有多少辆不同的车辆经过了这段高速公路。

一个简单的手段是：把所有的车牌号排序，然后遍历找出所有不同车牌号的数量。
代码：Dedup

车牌号 由数字 和 字母组成；
因此一般都会将它们表示为字符串。
在最简单的情况中，这些字符串的长度都是相同的。
这在排序场景中其实很常见：比如 电话号码、银行账号、IP地址等 都是典型的定长字符串。

对这类字符串排序，可以通过“键索引计数法”来完成。

如果 所有字符串的长度都为 W，那么就 从右向左，以每个位置上的字符作为键，
然后使用 键索引计数法 把字符串排序W遍。

这种方法乍一看，很难相信它能够产生一个有序的数组 —— 事实上，
除非 键索引计数法 是稳定的，否则 这种方法行不通。
在研究 以下证明时，请注意这一点，并参考后面的示例。

命题B： 低位优先的字符串排序算法 能够 稳定地 将定长字符串排序。
证明：此命题完全依赖于 键索引计数法的实现 是稳定的。
在 将它们的最后i个字符 作为键进行排序之后，可以知道，任意两个键 在数组中的顺序 都是正确的（仅考虑这些字符时的结果）。
要么 因为它们的倒数第i个字符不同，所以排序方法 已经把它们的顺序摆放正确  - 组间排序；
要么 它们的倒数第i个字符相同，所以由于排序的稳定性，它们仍旧是有序的 - 组内排序。
由归纳法可知，对于i-1这一点仍旧正确。

代码：LSD

如果想要 将多个 含有W个字符的元素的字符串数组a[] 排序，
需要进行 W次 键索引计数 排序：从右向左，以每个位置的字符 作为键，排序一次。

原理：
#1 使用当前字符 作为元素的键/组号时，它在字母表中是“被排序好的”。因此 可以在步骤#2中，建立 groupNo -> startIndex的映射关系
#2 实现“组内元素的有序性的原理”：
    ① 使用最后一个字符作为键时，最后一位字符已经完成了排序 - 按照字符表顺序正向排序；
    ② 使用倒数第二个字符作为键时，会：
        1 保持 键在①中排序结果的相对顺序 aka 最后一位字符仍旧会是有序的；
        2 对倒数第二个字符完成了排序。
    因此，对于这两个字符，我们会得到 完全有序(组间有序 & 组内有序)的元素集合。
    根据归纳法，对于整个字符串，我们最终会得到 完全有序的元素集合。