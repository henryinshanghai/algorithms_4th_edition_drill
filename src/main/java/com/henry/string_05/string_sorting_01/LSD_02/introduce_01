我们学习的 第一个字符串排序算法 叫做 “低位优先的”字符串排序。

考虑 以下应用：
假设 有一个工程师 架设了 一个设备 来 记录给定时间段内，
某条忙碌的高速公路上 所经过的 所有车辆的车牌号。
他希望知道 总共有多少辆 不同的车辆 经过了 这段高速公路。

一个简单的手段是：把 所有的车牌号 排序，然后 遍历找出 所有不同车牌号的数量。
代码：Dedup

车牌号 由 数字 和 字母 组成；
因此一般都会 将它们表示为 字符串。
在 最简单的情况 中，这些字符串的长度 都是相同的。
这在排序场景中 其实很常见：比如 电话号码、银行账号、IP地址等 都是 典型的“定长”字符串。

对 这类字符串排序，可以通过 “键索引计数法” 来 完成。

如果 所有字符串的长度 都为 W，那么就 从右向左，以 每个位置上的字符 作为键，
然后 使用键索引计数法 把字符串 排序W遍。

这种方法 乍一看，很难相信 它能够产生 一个有序的数组 —— 事实上，除非 键索引计数法 是稳定的，否则 这种方法行不通。
在 研究 以下证明 时，请注意 这一点，并 参考后面的示例。

命题B：“低位优先的”字符串排序算法 能够 ”稳定地“ 将 定长字符串 排序。
证明：此命题 完全依赖于 “键索引计数法”的实现 是 稳定的。
    在 将它们的最后i个字符 作为键进行排序 之后，可以知道，任意两个键 在数组中的顺序 都是正确的（仅考虑这些字符时的结果）。
    要么 因为它们的倒数第i个字符 不同，所以排序方法 已经 把 它们的顺序 摆放正确  - 组间有序；
    要么 它们的倒数第i个字符 相同，所以由于排序的稳定性，它们仍旧是有序的 - 组内相对顺序 不变。
    由 归纳法 可知，对于i-1这一点仍旧正确。

代码：LSD

如果想要 把 “每个元素含有含有W个字符的”字符串数组a[] 排序，
则：需要进行 W次 键索引计数 排序 - 从右向左，以 每个位置的字符 作为键，都 进行一次 键索引计数的排序操作。
