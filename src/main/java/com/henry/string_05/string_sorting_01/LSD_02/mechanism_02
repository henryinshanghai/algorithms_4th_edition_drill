原理：
#1 使用 当前字符 作为 元素的键/组号 时，它 在字母表中 是“被排序好的”。因此 可以 在步骤#2中，建立 groupNo -> startIndex的映射关系
#2 实现 “组内元素的有序性“的原理：
    ① 使用 最后一个字符 作为键 时，最后一位字符 已经完成了排序 - 也就是 按照字符表顺序 正向排序；
    ② 使用 倒数第二个字符 作为键时，会：
        1 保持 键之间 在①中排序结果的相对顺序 aka 在排列结果序列的每个组内，其最后一位字符 仍旧会是 有序的；
        2 对 倒数第二个字符 完成了排序。
    因此，对于 这两个字符，我们会得到 完全有序(组间有序 & 组内有序)的元素集合。
    根据 归纳法，对于 整个字符串，我们最终会得到 完全有序的元素集合。

总结：
#1 ”元素完全排序“ = 组间有序 + 组内有序；
#2 而 键索引计数法 所保证的是：① 组间有序；② 组内元素之间的相对顺序 与 原始数组中 元素之间的相对顺序 相同。
中间的gap是什么呢???
    使用 ”元素之间的相对顺序不变“的特性 来 实现”组内有序“👇
        ① 先保证倒数第一个位置上的字符有序；
        ② 在此基础上，再保证倒数第二个位置上的字符有序；
    结果：由于”元素之间的相对顺序不变“的特性，第②步结束后，倒数第一的位置上的字符 一定是”组内有序“的了。

证明该命题 的另一种方式是 向前看：
#1 如果有两个键，它们之中 没有被检查过的字符 是完全相同的，则：键的不同之处 就仅仅存在于 已经被检查过的字符中。
    由于两个键 已经被排序过了，因此它们将会一直保持有序（因为键索引计数法的稳定性）；
#2 另外，如果 没有被检查过的字符 是不同的，则：已经被检查过的字符 对于两者的最终顺序 没有任何意义.
    之后的某一轮处理 会根据 更高位字符的不同 来 修正这对键的顺序。