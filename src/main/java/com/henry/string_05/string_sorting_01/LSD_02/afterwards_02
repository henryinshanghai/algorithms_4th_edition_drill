证明该命题的另一种方式是 向前看：
#1 如果有两个键，它们之中 没有被检查过的字符 是完全相同的，则：键的不同之处 就仅仅存在于 已经被检查过的字符中。
    由于两个键 已经被排序过了，因此它们将会一直保持有序（因为键索引计数法的稳定性）；
#2 另外，如果 没有被检查过的字符 是不同的，则：已经被检查过的字符 对于两者的最终顺序 没有任何意义.
    之后的某一轮处理 会根据 更高位字符的不同 来 修正这对键的顺序。


老师的卡片打孔排序机 使用的就是 低位优先的基数排序法。
这类机器 开发与20世纪初期，比起 使用计算机处理商业数据的时代 要早上数十年。
这种机器能够 根据卡片上 被选定列中 孔的模式 来 将一组卡片 分别放入10个盒子中。

而如果多个数字 被打在 这组卡片的多个列上，操作员 会使用如下方法 来 将所有卡片排序：
#1 先根据最右边的数字排序；
#2 然后把所有卡片按照顺序叠好，再根据倒数第二个数字排序；
#3 如此这般重复，直到排序到最第一个数字为止。

这里，把所有被排序的卡片 按顺序再次叠放，就是一个稳定的过程 - 键索引计数法 模仿了这个过程。

在整个20世纪70年代，这个版本的低位优先 基数排序法 不仅在商业领域非常重要，
许多严谨的程序员也使用它，因为
他们需要 将程序保存在 打了孔的卡片上（每张卡片上一行孔），
并且 会在 用于完整表示某个程序的一组卡片的 最后几列 打上序号 - 这样即使卡片散乱后，也能把它们重新按顺序排列。

这也是一种 将扑克牌排序的简单方法：
#1 将所有牌，按照大小费城十三堆；
#2 按顺序从13堆牌中，抽取出相同花色的扑克牌；
#3 最后将13堆牌，变成4堆。
特征：分牌的过程是稳定的，因此 某一个花色中的牌也是有序的。
因此，按照花色 把这4堆牌合并，就能够得到 一副已经排序了的扑克牌。
