我们也可以根据 高位优先的字符串排序算法 来 改进快速排序，
根据 键的首字母 进行三向切分，仅
在中间子数组中的下一个字符（因为 键的首字母 与 切分字符相等）继续递归排序。

这个算法的实现并不困难，见算法5.3：
我们只是：
#1 为算法2.5中的递归方法 添加了一个参数 来
    ① 保存 当前的切分字母 并
    ② 让三向切分的代码 使用该字符;
#2 然后适当修改递归调用。
参考 图（略）

尽管排序的方法 有所不同，但三向字符串排序：
#1 根据的仍旧是 键的首字母 并
#2 使用递归方法 将其余部分的键 排序；

对于字符串的排序，这个方法 比起 普通的快速排序 和 高位优先的字符串排序 更友好。
实际上，它就是 这两种算法的结合。

===
三向字符串快速排序 只是将数组切分成三部分，因此
当相应的高位优先的字符串排序 所产生的切分 比较多时，
它所需要移动的 数据量就会变大 - 因为它需要进行一系列的三向切分 才能够
取得 多向切分的效果。

但是 高位优先的字符串排序 可能会创建大量的（空）子数组，
而 三向字符串快速排序的切分 总是只有三个。
因此 三向字符串快速排序 能够很好地处理：
#1 等值键；
#2 有较长公共前缀的键；
#3 取值范围较小的键；
#4 小的数组
所有这些，都是高位优先的字符串排序算法 所不擅长的各种情况。

见图（略）

特别重要的一点是，这种切分方法 能够适应键的不同部分的不同结构。
和快速排序一样，三向字符串排序 也不需要使用额外的空间（递归所需要使用的隐式栈除外），
这也是它 相比于 高位优先的字符串排序 的一大优点，后者 在统计频率和使用辅助数组时，都会需要额外的空间。
