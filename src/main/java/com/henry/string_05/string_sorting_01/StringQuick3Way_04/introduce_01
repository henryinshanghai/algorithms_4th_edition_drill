我们也可以根据 高位优先的字符串排序算法 来 改进”快速排序“，
根据 键的首字母 进行三向切分，仅
在 中间子数组中的下一个字符（因为 键的首字母 与 切分字符相等）继续递归排序。

这个算法的实现 并不困难，见算法5.3：
我们只是：
#1 为 算法2.5中的递归方法 添加了一个参数 来
    ① 保存 当前的切分字母 并
    ② 让 三向切分的代码 使用该字符;
#2 然后 适当修改 递归调用。
参考 图（略）

尽管 排序的方法 有所不同，但 三向字符串排序：
#1 所根据的 仍旧是 键的首字母 并
#2 使用 递归方法 将 其余部分的键 排序；

对于 字符串的排序，这个方法 比起 普通的快速排序 和 高位优先的字符串排序 更友好。
实际上，它就是 这两种算法的结合。

===
三向字符串快速排序 只是 将 数组 切分成 三部分，因此
当 相应的高位优先的字符串排序 所产生的切分 比较多时，
它 所需要移动的数据量 就会变大 - 因为它 需要进行 一系列的三向切分 才能够
取得 多向切分的效果。

但是 高位优先的字符串排序 可能会创建 大量的（空）子数组，
而 三向字符串快速排序的切分 总是只有三个。
因此 三向字符串快速排序 能够很好地处理：
#1 等值键；
#2 有较长公共前缀的键；
#3 取值范围较小的键；
#4 小的数组
所有这些，都是 高位优先的字符串排序算法 所不擅长的各种情况。

见图（略）

特别重要的一点是，这种切分方法 能够适应 键的不同部分 的不同结构。
和 快速排序 一样，三向字符串排序 也不需要使用 额外的空间（递归 所需要使用的隐式栈 除外），
这也是 它 相比于 高位优先的字符串排序 的一大优点，后者 在 统计频率 和 使用辅助数组 时，都会需要 额外的空间。
