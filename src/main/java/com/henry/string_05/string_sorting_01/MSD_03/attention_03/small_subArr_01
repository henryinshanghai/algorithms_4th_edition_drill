高位优先的字符串排序的 基本思想 是很有效的：
在 一般的应用 中，只需要 检查若干个字符 就能够完成 所有字符串的排序。
换句话说，这种方法 能够快速地 把 需要排序的数组 切分成 较小的子数组 集合。

但 这种切分 是一把双刃剑：我们肯定 会需要处理 大量的微型数组 - 所以必须要 能够快速地 处理它们。

小型子数组 对于 高位优先的字符串排序的性能 至关重要。
我们在 其他的递归排序算法中 也遇到过这种情况（快速排序 和 归并排序），
但是 小数组 对于 高位优先的字符串排序 的影响 更加强烈。

例如，你需要 将 数百万个 不同的ASCII字符串（R=256）排序 并且你 对 小数组 不做任何的处理。
则：每个字符串 最终都会产生一个 只含有它自己的子数组 - 这样你 就会需要 把 数百万个 大小为1的子数组 排序。
而 每次排序 都需要 把keyToItsStartIndex[]中的258个元素 初始化为0，并 将 它们 转化为索引。
这个操作的代价 比起 排序的其他部分 要高很多。

在 使用Unicode（R=65536）时，排序过程 可能会 减慢上千倍。
事实上，正因如此，许多 使用排序但考虑不周 的程序，在从 ASCII 切换到 Unicode 后，
运行时间 会从几分钟 暴涨到 几小时。

综上，将 小数组 切换到 插入排序 的这种做法 对于 高位优先的字符串排序算法 是必须的。
为了避免 重复检查 已知相同的字符 所带来的成本，我们使用 如下版本的插入排序👇
略
（对 “前面d个字符都相同的字符串”，执行 插入排序）

它 接受一个 额外的参数d，并假设 所有需要排序的字符串的前面d个字符 都是相同的。
这段代码的效率 取决于 substring()方法 所需要的时间 是不是为常数。// 🐖 网站上 并没有 使用substring()的方式

和 快速排序 以及 归并排序 一样，一个较小的转换阈值 就能够 将性能提高很多，
对于 高位优先的字符串排序算法，它所节约的时间 更是非常可观。

如图 显示了一个 典型应用中的实验结果。
在 长度小于等于10 时，将 子数组 切换到 使用插入排序，能够 将 运行时间 降低为 原来的1/10.
