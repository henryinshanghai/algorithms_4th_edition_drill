===
对“字符串末尾”的约定

在 高位优先的字符串排序算法中，需要 特别注意 都到达 字符串末尾的情况。

在排序中，合理的做法是 把 所有字符都已经被检查过的字符串 所在的子数组 排在 所有子数组的前面???
这样就不需要 递归地将该子数组排序。见5.1.10(图)

为了简化这两步计算，我们使用了一个 接受两个参数的私有方法 toChar() 来
#1 把字符串中的字符索引 转化为 数组索引；
    🐖：当指定位置 超过了 字符串的末尾时，该方法会返回-1.
#2 然后把所有返回值+1，从而得到要给 非负的int值，并用它作为 keyToItsStartIndex[]的索引。

分析：这种转换意味着 字符串中的每个字符 都可能产生 R+1种不同的值：
0表示字符串的结尾、1表示字母表的第一个字符、2表示字母表的第二个字符...

因为 键索引计数法 本来就需要一个额外的位置，所以我们需要使用代码
int keyToItsStartIndex[] = new int[R+2]; 来 创建 用于记录统计频率的数组。

🐖 在某些编程语言中（比如C、C++），已经约定了 字符串结束的表示方法，因此 对这类语言，本节的代码需要进行相应的调整。

有了这些预备知识（递归算法 & 对字符串末尾的约定），就会知道
算法5.2实现 高位优先的字符串排序算法 所需要的新代码 并不多。

增加了一个条件语句 以 在子数组比较小的时候，切换到插入排序。
🐖 这里使用的是一个特殊版本的插入排序，我们会稍后考察。

还添加了一个 键索引计数法的循环 来 完成递归调用。
从下表可知，keyToItsStartIndex[]数组中的值（在 统计频率、转换为索引，并将数据分类后）
正是 将每个字符所对应的子数组 递归排序时所需要的值。

==
指定的字母表

高位优先的字符串排序的成本 与 字母表中的字符数量 有很大的关系。
我们可以很容易地 令排序算法 接受一个 Alphabet对象 来 作为参数，以改进 基于较小的字母表 的字符串排序程序的性能。
完成这一点，需要进行如下改动：
#1 在构造函数中，用一个alpha对象 来 保存字母表；
#2 在构造函数中，将R设置为 alpha.R();
#3 在 charAt()方法中，将s.charAt(d) 替换成为 alpha.toIndex(s.charAt(d));

表略

在本节的示例中，字符串都是 由小写字母组成。
扩展 低位优先的字符串排序算法 以 支持这种特性也很简单，
但是带来的性能提升 一般 比高位优先的字符串排序 小得多。
