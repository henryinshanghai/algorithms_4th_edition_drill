==
对“字符串末尾”的约定

在 “高位优先的” 字符串排序算法中，需要 特别注意 到达 字符串末尾的情况。

在排序中，合理的做法是 把 “所有字符都已经被检查过”的字符串 所在的子数组 排在 所有子数组的前面???
这样 就不需要 递归地 将该子数组排序。见5.1.10(图)

为了简化 这两步计算，我们 使用了一个 接受两个参数的私有方法 toChar() 来
#1 把 字符串中的字符索引 转化为 数组索引；
    🐖：当 指定位置 超过了 字符串的末尾 时，该方法 会返回-1.
#2 然后 把 所有返回值 +1，从而得到 非负的int值，并 用它作为 keyToItsStartIndex[]的索引。

分析：这种转换 意味着 字符串中的每个字符 都可能产生 R+1种不同的值：
0 表示 字符串的结尾、1 表示 字母表的第一个字符、2 表示 字母表的第二个字符...

因为 键索引计数法 本来就需要 一个额外的位置，所以我们需要 使用代码
int keyToItsStartIndex[] = new int[R+2]; 来 创建 用于记录统计频率的数组。

🐖 在 某些编程语言 中（比如C、C++），已经约定了 字符串结束的表示方法，因此 对这类语言，本节的代码 需要进行 相应的调整。

有了 这些预备知识（递归算法 & 对字符串末尾的约定），就会知道 实现”高位优先的“字符串排序算法 所需要的新代码 并不多。

① 增加了 一个条件语句 以便 在 子数组比较小 的时候，切换到 插入排序。
🐖 这里使用的是 一个特殊版本的插入排序，我们会 稍后考察。

② 还添加了一个 键索引计数法的循环 来 完成递归调用。
从下表可知，keyToItsStartIndex[]数组中的值（在 统计频率、转换为索引，并将数据分类后）
正是 将每个字符所对应的子数组 递归排序时 所需要的值。

==
指定的字母表

高位优先的字符串排序 的成本 与 字母表中的字符数量 有很大的关系。
我们 可以很容易地 令 排序算法 接受一个 Alphabet对象 来 作为参数，以改进 基于较小的字母表 的 字符串排序程序 的性能。
完成这一点，需要进行 如下改动：
#1 在 构造函数 中，用一个alpha对象 来 保存字母表；
#2 在 构造函数 中，将 R 设置为 alpha.R();
#3 在 charAt()方法 中，将 s.charAt(d) 替换成为 alpha.toIndex(s.charAt(d));

表略

在 本节的示例 中，字符串 都是 由小写字母组成。
扩展 低位优先的字符串排序算法 以 支持这种特性 也很简单，
但是 能够带来的性能提升 一般 比起 高位优先的字符串排序 小得多。
