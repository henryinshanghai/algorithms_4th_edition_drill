Trie数据结构

作用：存储 并 取出 字符串类型的数据；
应用：用于实现 key为字符串类型的 符号表；
概念：
    字符串key：在 符号表的entry 中，key 是一个 字符串；
    字符串的 字符序列：由 字符串中的字符 顺序连接 所形成的序列；
    字符序列 在Trie中 所对应的路径：在 Trie树 中，由 序列中的当前字符 所对应的链接 所指向的结点 所构成的路径；
原理：
    Trie树的结构 能够 很好地利用 ”字符串前缀“的特性。
步骤：
    #1 从 符号表 中 获取 指定的keyStr 所关联的value值；
        如果 对路径的查询 终止于 一个null，说明 trie中 不存在 这样的路径，则：查找未命中，返回null
        如果 对路径的查询 终止于 keyStr的最后一个字符，说明 trie中 存在有 这样的路径，则：查找命中，返回 路径的最后一个结点 所关联的value；

        如果 当前字符(currentRootNode)查询成功，需要 继续 在trie子树(successorNode)中 递归地查询 路径的剩余部分(startCharacterSpot)；

    #2 向符号表中 添加 keyStr -> value的映射条目；
        如果 对路径的查询 终止于 一个null，说明 trie中 缺少 针对于 路径中的某个字符 的结点，则：创建出 一个空结点 并 正确地链接到 trie树上；
        如果 对路径的查询 终止于 keyStr的最后一个字符，说明 trie中 存在有 这样的路径，则：查找命中，更新 路径的最后一个结点 所关联的value，并 返回该结点

        如果 当前字符 查询成功，需要
            ① 继续在trie子树(successorNode)中 递归地添加 路径中的剩余部分，并
            ② 在添加完成后，把 添加后的子树 绑定回去 原始的子树引用 以此来 更新 原始的树

一句话描述：
    借助 Trie树的特性，符号表 能够回答 很多 关于prefix的问题；