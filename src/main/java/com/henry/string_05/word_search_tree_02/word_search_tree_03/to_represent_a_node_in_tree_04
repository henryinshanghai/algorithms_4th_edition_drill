在本节开头 提到过，我们 为 单词查找树 所绘制的图像 与
我们 在程序中所构造的数据结构 并不完全一致 - 因为 在图像中，我们 没有绘制出 空链接。

把 空链接 考虑进来，能够突出 单词查找树的以下性质：
#1 每个结点都 含有R个链接，用于 对应着 每个可能出现的字符；
#2 字符 和 键 都 隐式地被保存在 数据结构之中。

== 结点中 到底有什么？==
作用：用于 表示一个字符；
特征：结点中 不会保存 它所表示的字符 - 从 Node的代码实现 就能得出 这个结论。

= 那 这个字符信息 是 保存在 什么地方 的呢？=
答：”指向结点“的链接/引用 中；
在 R向单词查找树 中，每个结点都 有R个子结点。
对于 每一个子结点，它所表示的字符 取决于 指向它的链接 所对应的是什么字符（这显然不是 子结点 所能控制的）。

也就是说，“指向结点的链接”的“字符索引” 决定了 “该结点所表示的字符”。

应用：回答 树中 是否存在有 表示”指定字符“的结点？
手段：检查 ”由该字符所索引“的链接 所指向的结点 是不是 为null - 如果 是，说明 不存在。如果 不是，说明 存在

综上，结点所表示的字符 <=> 指向结点的链接 的“字符索引” <-> 父节点的”链接数组“中，”该字符对应的链接 所指向的结点 是否为null“。
用法：如果 在 父结点的”链接数组“ 中，字符h 所对应的链接 所指向的 子结点 不为null。则：树中 存在有 “表示字符h的结点”

在 下图中的单词查找树 中，所有的键都 是 由小写字母组成的，
每个结点 都含有：
    一个值（用于表示 符号表中的key 所对应的value） & 26个链接（它们所组成的数组 用于表示 当前节点 所能够表示的 所有可能的字符）。

链接的用法：
    第一条链接 所指向的子单词查找树 中，所有键的首字母都 是a，
    第二条链接 所指向的子单词查找树 中，所有键的首字母都 是b...
原理：链接的索引 会隐式地定义 其对应的字符；

特征：在 单词查找树 中，键字符串 是 由 从 根结点 到 含有非空值的结点 所构成的路径 来 隐式表示的。
比如，如果 符号表中 存在有 sea -> 2 的映射关系；
则：在 单词查找树 中，有：
    #1 根结点的第19条链接 非空； - 用于表示 第一个字符为s （根结点 其他的链接 有没可能 也是非空的呢？不重要）
    #2 当前结点的第5条链接 非空； - 用于表示 第二个字符为e
    #3 当前结点的第1条链接 非空； - 用于表示 第三个字符为a

特征：在 数据结构 中，既没有 保存字符串sea，也没有 保存字符s、e、a。
事实上，数据结构 不会存储 任何字符串或者字符，它 只是保存了 ”与结点相关联“的链接数组&值；

由于 参数R的作用（决定了 数据结构的形状）非常重要，所以
我们会 把 “基于 包含有R个字符的字母表 所构建出的 单词查找树” 称为 “R向单词查找树”

有了 这些预备知识 之后，算法 5.4 所实现的符号表 TrieST 就容易理解了。
它 也使用了 类似于 第3章中介绍的查找树 所使用的递归算法。

特征👇
它的私有Node类 使用 实例变量val 来 保存 与键相关联的值，并
使用数组next[] 来 保存所有 指向其他Node对象的引用。

这些 递归方法的实现 非常简洁，值得 仔细研究。
下面，我们会 讨论：
#1 接受 一个Alphabet对象 作为参数 的构造函数；
#2 size();
#3 keys();
#4 longestPrefixOf();
#5 keysWithPrefix();
#6 keysThatMatch();
#7 delete()
方法的实现。

理解这些递归方法 不算很困难，只是 每个方法 都会 比起 前一个 更复杂一些。