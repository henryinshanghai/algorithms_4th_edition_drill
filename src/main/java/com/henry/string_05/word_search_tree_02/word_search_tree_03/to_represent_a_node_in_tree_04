在本节开头提到过，我们 为单词查找树所绘制的图像 与
我们 在程序中构造的数据结构 并不完全一致 - 因为在图像中，我们没有绘制出 空链接。

把空链接考虑进来，能够突出 单词查找树的以下性质：
#1 每个结点都含有R个链接，用于 对应着 每个可能出现的字符；
#2 字符和键 都隐式地 被保存在数据结构之中。

== 结点中到底有什么？==
在图中的单词查找树中，所有的键 都是由小写字母组成的，
每个结点 都含有：
    一个值 & 26个链接（所组成的数组）。

链接的用法：
    第一条链接 所指向的子单词查找树中，所有键的首字母都是a，
    第二条链接所指向的子单词查找树中，所有键的首字母都是b...
原理：链接的索引 会隐式地定义 其对应的字符；

特征：在单词查找树中，键 是 由 从根结点到含有非空值的结点所构成的路径 来 隐式表示的。
比如，如果 符号表中 存在 sea -> 2的映射关系；
则：单词查找树中，有：
    #1 根结点的第19条链接非空； - 用于表示第一个字符为s
    #2 当前结点的第5条链接非空； - 用于表示第二个字符为e
    #3 当前结点的第1条链接非空； - 用于表示第三个字符为a

特征：数据结构中，既没有保存 字符串sea，也没有保存字符s、e、a。
事实上，数据结构 不会存储任何字符串或者字符，它只是保存了 与结点相关联的链接数组&值；

由于参数R的作用（决定了数据结构的形状）非常重要，所以
我们会把 “基于 包含有R个字符的字母表 所构建的单词查找树” 称为 “R向单词查找树”

有了这些预备知识之后，算法 5.4所实现的符号表 TrieST就容易理解了。
它也使用了 类似于第3章中介绍的 查找树所使用的递归算法。

特征👇
它的私有Node类 使用 实例变量val 来 保存 与键相关联的值，并
使用数组next[] 来 保存所有指向其他Node对象的引用。

这些递归方法的实现 非常简洁，值得仔细研究。
下面，我们会 讨论：
#1 接受一个Alphabet对象 作为参数的构造函数；
#2 size();
#3 keys();
#4 longestPrefixOf();
#5 keysWithPrefix();
#6 keysThatMatch();
#7 delete()
方法的实现。

理解这些递归方法不算很困难，只是每个方法 都会比起前一个 更复杂一些。

