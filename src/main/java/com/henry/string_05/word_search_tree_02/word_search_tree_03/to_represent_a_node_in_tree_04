在本节开头提到过，我们 为单词查找树所绘制的图像 与
我们 在程序中构造的数据结构 并不完全一致 - 因为在图像中，我们没有绘制出 空链接。

把空链接考虑进来，能够突出 单词查找树的以下性质：
#1 每个结点都含有R个链接，用于 对应着 每个可能出现的字符；
#2 字符和键 都隐式地 被保存在数据结构之中。

== 结点中到底有什么？==
作用：用于 表示一个字符；
特征：结点中 不会保存它所表示的字符 - 从Node的代码实现就能得出这个结论。

= 那这个字符信息 是保存在什么地方的呢？=
答：指向结点的链接/引用；
R向单词查找树中，每个结点都有R个子结点。
对于每一个子结点，它所表示的字符 取决于 指向它的链接 所对应的是什么字符（这显然不是子结点所能控制的）。

也就是说，“指向结点的链接”的“字符索引” 决定了 “结点所表示的字符”。

应用：回答 树中是否存在有 表示指定字符的结点？
手段：检查 字符所索引的链接 所指向的结点 是不是为null - 如果是，说明不存在。不过不是，说明存在

综上，结点所表示的字符 <-> 指向结点的链接 的“字符索引” <-> 父节点的”链接数组“中，”字符所对应的链接/结点“。
用法：如果 在父结点的”链接数组“中，字符h所对应的链接 指向的子结点不为null。则：树中存在有“表示字符h的结点”

在图中的单词查找树中，所有的键 都是由小写字母组成的，
每个结点 都含有：
    一个值（用于表示 符号表中的key所对应的value） & 26个链接（所组成的数组 用于表示 当前节点所表示的所有可能的字符）。

链接的用法：
    第一条链接 所指向的子单词查找树中，所有键的首字母都是a，
    第二条链接 所指向的子单词查找树中，所有键的首字母都是b...
原理：链接的索引 会隐式地定义 其对应的字符；

特征：在单词查找树中，键 是 由 从根结点到含有非空值的结点所构成的路径 来 隐式表示的。
比如，如果 符号表中 存在 sea -> 2的映射关系；
则：单词查找树中，有：
    #1 根结点的第19条链接非空； - 用于表示第一个字符为s （根结点其他的链接有没可能也是非空的呢？）
    #2 当前结点的第5条链接非空； - 用于表示第二个字符为e
    #3 当前结点的第1条链接非空； - 用于表示第三个字符为a

特征：数据结构中，既没有保存 字符串sea，也没有保存字符s、e、a。
事实上，数据结构 不会存储任何字符串或者字符，它只是保存了 与结点相关联的链接数组&值；

由于参数R的作用（决定了数据结构的形状）非常重要，所以
我们会把 “基于 包含有R个字符的字母表 所构建的单词查找树” 称为 “R向单词查找树”

有了这些预备知识之后，算法 5.4所实现的符号表 TrieST就容易理解了。
它也使用了 类似于第3章中介绍的 查找树所使用的递归算法。

特征👇
它的私有Node类 使用 实例变量val 来 保存 与键相关联的值，并
使用数组next[] 来 保存所有指向其他Node对象的引用。

这些递归方法的实现 非常简洁，值得仔细研究。
下面，我们会 讨论：
#1 接受一个Alphabet对象 作为参数的构造函数；
#2 size();
#3 keys();
#4 longestPrefixOf();
#5 keysWithPrefix();
#6 keysThatMatch();
#7 delete()
方法的实现。

理解这些递归方法不算很困难，只是每个方法 都会比起前一个 更复杂一些。

