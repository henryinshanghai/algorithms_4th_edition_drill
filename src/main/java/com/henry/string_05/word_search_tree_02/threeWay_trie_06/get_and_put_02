用三向单词查找树 来 实现符号表API中的 查找和插入操作 非常简单。

== 查找算法 ==
#1 在查找时，我们首先 比较键的首字母 和 根结点的字母。
    如果键的首字母更小，则：在树的左链接中 继续查找；
    如果键的首字母更大，则：在树的右链接中 继续查找；
    如果相等，则：在树的中链接中 继续查找；
#2 然后递归地使用 相同地查找算法。

如果 查找路径遇到了空链接 或者 当键结束的时候，尾字符对应的结点为空，则：查找未命中。
如果 键结束时，结点的值为非空，则：查找命中。

== 插入算法 ==
在插入一个新键的时候，首先进行查找。
然后 与在单词查找树中一样，在树中补全 键末尾的所有结点。
算法5.5给出了 get(), put()方法的实现细节。


这种实现方式 等价于 将 R向单词查找树中的每个结点(node) 实现为
以 非空链接所对应的字符 作为键 的二叉查找树(tree)；
不同的是，算法5.4使用的是 由键来索引的数组。

如图显示了 一棵单词查找树 与 它所对应的三向单词查找树。

按照第3章中所述的二叉查找树 和 其他排序算法之间的对应关系来看，
我们可以发现：
    三向单词查找树 与 三向字符串快速排序 之间的对应关系
    同 二叉查找树 与 快速排序 之间的对应关系
    以及 单词查找树 与 高位优先的排序 之间的对应关系
是一样的.

图5.1.12 和 图5.1.17 分别显示了
高位优先的字符串排序 与 三向字符串快速排序 的递归调用结构，
它们 与 图5.2.10中 由同一组键所构造的 “单词查找树” 和 “三向单词查找树” 正好完全对应。

单词查找树中的链接 所占用的空间 即为 高位优先的字符串排序中，计数器所占用的空间。
三向分支为两者(??)都提供了一个 非常有效的解决方案，参考 图5.2.11 和 图5.2.12.

代码参考：TSTWebsite.java

这段实现使用 含有一个char类型的值 character 和 三条链接的结点Node 来 构建了 三项单词查找树，
其中子树的键的首字母 分别 小于、等于和大于 character。

🐖 链接的位置 表明了 子节点 相对于 父结点的字符大小，这与二叉查找树非常类似。

对于中链接（二叉查找树中没有这条链接）：
它用于指向 所有 以“当前节点字符”开头的键 的链接。

🐖 结点本身的字符，用于判定 （查询/插入）路径的前进方向：如果当前字符 与 结点字符相等，则：走中间链接。以此类推


