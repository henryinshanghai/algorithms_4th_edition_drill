用 三向单词查找树 来 实现符号表APIs中的 查找 和 插入操作 非常简单。

== 查找算法 ==
#1 在 查找 时，我们首先 比较 键的首字母 和 根结点的字母。
    如果 键的首字母 更小，则：在 树的左链接 中 继续查找；
    如果 键的首字母 更大，则：在 树的右链接 中 继续查找；
    如果 相等，则：在 树的中链接 中 继续查找；
#2 然后 递归地使用 相同的查找算法。

如果 查找路径 遇到了 空链接 或者 当 键结束 的时候，尾字符 所对应的结点 为空，则：查找未命中。
如果 键结束 时，结点的值 为非空，则：查找命中。

== 插入算法 ==
在 插入一个新键 的时候，首先 进行查找。
然后 与 在单词查找树中 一样，在树中 补全 键末尾的所有结点。
算法5.5 给出了 get(), put()方法的 实现细节。


这种实现方式 等价于 将 R向单词查找树中的每个结点(node) 实现为
“以 非空链接所对应的字符 作为键” 的二叉查找树(tree)；
不同的是，算法5.4 使用的是 “由键来索引”的数组。

如图显示了 一棵单词查找树 与 它所对应的 三向单词查找树。

按照 第3章中所述的二叉查找树 和 其他排序算法 之间的对应关系 来看，
我们 可以发现：
    三向单词查找树 与 三向字符串快速排序 之间的对应关系
    同 二叉查找树 与 快速排序 之间的对应关系
    以及 单词查找树 与 高位优先的排序 之间的对应关系
是一样的.

图5.1.12 和 图5.1.17 分别显示了
高位优先的字符串排序 与 三向字符串快速排序 的递归调用结构，
它们 与 图5.2.10中 “由同一组键所构造的” 单词查找树 和 三向单词查找树 正好 完全对应。

单词查找树中的 链接 所占用的空间 即为 高位优先的字符串排序 中，计数器 所占用的空间。
三向分支为两者(??)都 提供了一个 非常有效的 解决方案，参考 图5.2.11 和 图5.2.12.

代码参考：TSTWebsite.java

这段实现 使用 含有一个char类型的值character 和 三条链接的结点Node 来 构建了 三向单词查找树，
其中子树的 键的首字母 分别 小于、等于和大于 character。

🐖 链接的位置 表明了 子节点 相对于 父结点的字符大小，这与 二叉查找树 非常类似。

对于 中链接（二叉查找树中 没有这条链接）：
它 用于指向 所有 以“当前节点字符”开头的键 的链接。

🐖 结点本身的字符，用于判定 （查询/插入）路径的前进方向：
    如果 当前字符 与 结点字符 相等，则：走 中间链接。
    以此类推
