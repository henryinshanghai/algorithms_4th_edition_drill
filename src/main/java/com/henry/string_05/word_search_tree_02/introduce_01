和 排序 一样，我们也可以 利用 字符串的性质 来
开发出 比起 ”第3章中所介绍“的通用算法 更为有效的 查找算法。
这样的算法 能够应用于 以字符串作为键的 一般应用程序。

具体来说，本节中所讨论的算法 在 一般的应用场景 中（甚至对于 巨型的符号表）
都会能够 得到以下的性能：
#1 查找命中 所需的时间 与 被查找的键的长度 成正比；
#2 查找未命中 只需要检查 若干个字符。

仔细思考 过后，你就会发现，上面👆的性能 是 非常惊人的。
它们 是 算法研究的最高成就 之一，也是
建设成功 现今可以便捷、快速地 访问海量信息 所依赖的基础设施 的重要因素。

更重要的 是，我们可以 扩展符号表的API，来 添加 ”基于字符的、用于处理字符串类型键“的操作。
这些个操作 在 实际应用 中 非常强大。

为 字符串键的符号表 所添加的 新的API：
#1 把 泛型的Key类型 换成了 具体类型String;
#2 添加了 3个新的方法：
    ① keyWhoIsLongestPrefixOf(given_string), 指定字符串的最长前缀键?
    ② keysWithPrefix(given_prefix), 拥有指定前缀的所有键
    ③ keysThatMatch(given_pattern); 匹配指定模式的所有键

遵守的约定：
#1 不接受 重复的键、空键；
#2 值 不能 为空。

从 字符串的排序算法 中 可以看到，指定 字符串所使用的字母表 常常是 非常重要的。
对于小型字母表的 简单而高效的实现 不适用于 大型字母表 - 因为 后者 消耗的空间 太多。

基于 这种情况，应该 添加一个 构造函数 来 允许用例指定 自己所使用的字母表。
我们会 在本节稍后 讨论 这个构造函数的实现，但暂时先 不在API中 列出它。
现在 先 把精力集中在 字符串类型的键上。
