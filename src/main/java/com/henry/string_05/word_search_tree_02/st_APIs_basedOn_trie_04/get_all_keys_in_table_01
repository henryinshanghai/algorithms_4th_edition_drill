因为 字符和键 都被隐式地表示在 单词查找树 中，所以
如果 用例 想要 遍历符号表中所有的键 就会变得 有些困难。

在 二叉查找树 中，我们 把 所有的字符串键 都保存在了 一个队列 中。
但对于 单词查找树 来说，不但需要 在数据结构中 找到 这些字符串键，还需要 显式地 把它们 展示出来（因为 树本身 没有存储 任何字符串）

手段：我们 使用一个 类似于size()的、私有、递归方法 collect() 来 完成 这个任务。
原理：它 维护了 一个字符串 用来保存 ”从根结点出发的路径上“的 一系列字符。
用法描述??：收集 ”以 指定结点 作为 根结点 的“ 单词查找子树 中，所存在的 所有“键”；
用法：第一个参数 是 “待查结点”，第二个参数 “与该结点相关联的 字符串”(aka 从 根结点 到 此节点路径上的 所有字符 所组成的字符串)
算法步骤：
    #1 在 访问第一个结点 时，如果 它的值 非空，我们 把 与它相关联的字符串 添加到队列中；
    #2 再 递归地访问 当前节点的链接数组 所指向的 所有可能的 字符结点。
    🐖 每次调用 之前，都 把“链接对应的字符” 附加到 当前键的末尾，然后 把它作为 递归调用的参数键。
应用：
    支持 keys()、keysWithPrefix()这些个API - 收集 符号表中的所有键。

===
实现keys()
手段：使用 空字符串 作为参数 来 调用keysWithPrefix()方法；

===
实现 keysWithPrefix()
手段：
    #1 先 使用get()方法 来 找出 给定的前缀 所对应的单词查找树（不存在时，返回null）；
    #2 再 使用collect()方法 来 收集 单词查找树中，以 #1中的单词查找树的 指定叶子结点 作为 根结点 的 所有子树的数量。

===
在 单词查找树 中，collect()方法的调用轨迹（直观的 图像）：略
调用collect()方法 时，第二个参数的值 & 队列的内容（客观的 数值变化）：略

===
代码: 收集 一棵树中 所有键 的集合（即便 那些 没有绑定值的键???）

public Iterable<String> getIterableKeys() {
    // 等价于 以 空字符串 作为前缀的所有键
    return keysWithPrefix("");
}