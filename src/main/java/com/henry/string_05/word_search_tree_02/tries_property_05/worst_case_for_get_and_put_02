最坏情况下，查找 和 插入操作 的时间界限

在 单词查找树 中，找到 指定的键值对 需要花多久时间？
对于 二叉查找树、散列表 以及 第3章中所介绍的 其他算法，
都需要使用 “数学分析” 来 回答 这个问题。

但是 对于 单词查找树，这个问题 很简单。
命题G 在 单词查找树 中，查找一个键 或是 插入一个键 时，访问数组的次数 最多是 键的长度+1.
证明
    根据代码 可以知道，put()和get()方法的递归实现，都使用了 一个参数 currentCharacterSpot。
    它的初始值 是 0，每次调用都 会+1，当 该位置 等于 键的长度 时，递归调用 就会停止。

从 理论的角度 来说，命题G 意味着 单词查找树 对于“命中的查找” 是 最为理想的 ——
我们 不能奢求 查找所需要的时间 比起 “与 被查找键的长度 成正比” 更好。
因为 无论使用 什么样的算法 和 数据结构，我们 都需要
① 先 检查完 字符串键中的所有字符，② 才能够 真正判断出 是否找到了 该键。

从 实际角度 来说，这个保证 也非常重要 —— 因为它 说明：查找时间 与 符号表中键的数量 是 无关的。
当我们 在处理 类似于车牌号码的 7个字符的键 时，可以知道 查找或插入操作 最多只需要 检查8个结点；
当我们 在处理20个字符的数字账号 时，最多只需要 检查21个结点，就能够完成 查找或插入操作。