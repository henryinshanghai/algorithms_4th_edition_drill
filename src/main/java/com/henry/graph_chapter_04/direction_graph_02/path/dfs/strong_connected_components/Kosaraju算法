强连通性

== 强连通的结点 ==
如果顶点v和顶点w是相互可达的，则：称它们是强连通的。
aka 即存在有 从v到w的有向路径，又存在从w到v的有向路径。

== 强连通的有向图 ==
如果一幅有向图中，任意的两个顶点之间，都是强连通的。
则：称这幅有向图是强连通的。

== 有向图中存在有 多少个 强连通的子图？ ==
计算 无向图中的连通分量 只是深度优先搜索 的一个简单应用。

怎么在有向图中高效地 计算强连通分量呢？
代码参考：KosarajuStrongConnectedComponentsLite

算法步骤/构造器中的操作:
#1 对于给定的有向图G，先获取它的反向图G', 再获取到G'的逆后序遍历的结果序列(逆后序排列)；
    手段：#1 对于currentVertex 与 它所有的adjacentVertex，以相反的方向来addEdge 就能够得到反向图G';
    #2 在对图G'进行DFS过程中，先收集到 后序遍历的结果序列，然后 从后向前遍历这个序列，就能够得到图G'的逆后序遍历的结果序列；
#2 在G中进行 标准的深度优先搜索，但是 要按照 刚刚计算得到的顺序，而不是 标准的顺序 来 访问 所有没有被标记过的顶点；
#3 在构造函数中，在某一次递归调用中，所访问到的所有顶点，都会在同一个连通分量中。

===
对 Kosaraju算法的正确性证明

#1 在G中 进行深度优先搜索（Kasaraju SCC）：
    假设 v对于s是可达的，则：G中必然含有 一条从s到v的路径（s -> v）；
#2 在G^R中 进行深度优先搜索（DepthFirstOrder）：
    深度优先搜索 必然在离开s之前，就离开了v，否则 G中，dfs(v)的调用 就会发生在 dfs(s)之前。
    🐖 G^R中，必定含有一条 v -> s的路径。
这个证明过程，没有讲清楚 要证明的命题是什么？ 证明过程的本身是什么？

===
这个方法容易实现，但难以理解。
但是如果你能够 一步一步地理解 下面这个命题的证明，并参考 图4.2.15，那么 你一定能够 理解这个算法的正确性。

命题H 如果：#1 使用深度优先搜索 查找指定的有向图G的反向图G^R，然后
#2 根据由此得到的所有顶点的逆后序，再使用 深度优先搜索 来 处理有向图G（Kasaraju算法），
则：其构造函数中的每一次递归调用 所标记的所有顶点，都会存在于 同一个强连通分量之中。

证明：
#1 首先要使用反证法 来 证明 “每个 与s强连通的顶点v 都会 在构造函数所调用的dfs(G, s)中，被访问到”。
    假设 存在有一个 与s强连通的顶点v，它不会 在构造函数所调用的dfs(G, s)中，被访问到。
    #1 由于存在有 s -> v的路径（强连通性），所以v肯定 在之前就已经被标记过了;
    #2 但是也存在 从v -> s的路径（强连通性），所以 在dfs(G, v)的调用中，s肯定会被标记 -> 所以递归调用时，应该就不再会调用dfs(G, s)了。
    矛盾，说明假设不成立。

#2 其次，要证明 “构造函数所调用的dfs(G, s) 所到达的任意顶点v，都必定与s是强连通的。”
    设v是dfs(G, s)所能够到达的某个顶点。则：G中，必然存在一条 s->v的路径 - 对应到G‘中，就是v->s的路径。
    所以 只需要证明 G中还存在有一条 v->s的路径 即可。对应到G'（G的逆向图）中，就是要证明 其中存在有一条 s->v的路径。

#3 等价证明的核心在于，如果 按照逆后序的结点序列 来 进行深度优先搜索（aka 遍历“有向图中结点”的顺序） 意味着/则：
    在G’中所进行的深度优先搜索中，dfs(G, v)[对结点v的处理完成]必然 在dfs(G, s)[对结点s的处理完成]之前就已经结束了。
        标记结点 - 这是dfs()调用开始就会做的事情；
        处理完成结点 - 标记结点 & 标记所有由当前结点指出的所有结点，这是当前dfs()调用结束才能完成的事情；
    这样的约束（dfs(v)的完成 先于 dfs(s)的完成）下，dfs(G, v)的调用 就只会出现两种情况：
        #1 调用 发生在dfs(G, s)的调用之前（并且 也在dfs(G, s)的调用之前 就完成了）；
        #2 调用 发生在dfs(G, s)的调用之后（并且 也在dfs(G, s)的调用结束之前 就完成了）

        第一种情况是不可能出现的，因为在G‘中，存在有一条 v->s的路径(???) - 推论：对结点s的处理完成 一定先于 对结点v的处理完成；
        第二种情况（先调用dfs(s), 再调用dfs(v),然后v完成，最后s再完成）则说明：G’中，存在有一条 s->v的路径（#2中的需证得证）。

至此，证毕。

===
如图是 Kosaraju算法 在处理tinyDG.txt时的轨迹。
在每次dfs()调用轨迹的右侧 都是 有向图的一种画法，顶点 按照搜索结束的顺序排列。

因此，从下往上来看，左侧这副有向图的反向图 得到的就是 所有顶点的逆后序，
也就是 在原始的有向图中，进行深度优先搜索时，所有未被标记的顶点 会被检查的顺序。

你可以从图中看到，在第二遍深度优先搜索中，首先调用的是 dfs(1) 用于标记顶点1，
然后调用的是 dfs(0) 标记了 顶点0、5、4、3和2，
然后检查了顶点2、4、5和3，
再调用dfs(11) 标记了 顶点11、12、9和10，
在检查了9、12和10之后，调用dfs(6) 标记了顶点6，
最后调用dfs(7) 标记了顶点7、8.

在反向图中进行深度优先搜索（ReversePost）时，
会按照以下顺序 来 检查所有未被标记的顶点：0 1 2 3 4 5 6 7 8 9 10 11 12

在原始的有向图中进行深度优先搜索时，
会按照以下顺序 来 检查所有未被标记的顶点：1, 0 2 4 5 3, 11 9 12 10, 6, 7 8

Kosaraju算法，用于 在一幅有向图中搜索 所有的强连通分量。