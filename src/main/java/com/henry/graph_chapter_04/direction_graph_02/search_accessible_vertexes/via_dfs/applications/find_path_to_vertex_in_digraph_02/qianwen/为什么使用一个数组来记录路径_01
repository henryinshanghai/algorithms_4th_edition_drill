在有向图的路径相关问题中，为什么要使用一个数组 来 记录到达目标节点的路径？

===
这是一个非常关键的问题！
在有向图（或无向图）的路径相关算法（如 Dijkstra、BFS、DFS、Bellman-Ford 等）中，
使用一个数组（如 prev[]、parent[] 或 edgeTo[]）来 记录 到达每个节点的 “前驱”信息，是为了 高效重建 从 源点 到 任意目标节点 的具体路径。

下面我们从目的、原理、必要性和实际价值几个角度详细解释。

===
一、核心目的：分离 “距离计算” 与 “路径重建”

大多数最短路径算法的核心任务是：
    计算从 源点s 到 所有 其他顶点v 的最短距离 dist[v]。

但很多时候，我们不仅想知道“最短距离是多少”，还想知道：
    “具体走哪条路 才能达到 这个最短距离？”

而直接 在算法过程中 保存 完整路径（比如 每个节点 都存一个 List<Node>）代价太高（空间爆炸）。

于是，聪明的做法是：
✅ 只记录“每一步是 从哪个节点来的” → 即前驱（predecessor）。

===
二、前驱数组（prev[]）的工作原理

假设我们有一个数组：
    int[] prev = new int[V];  // prev[v] 表示在最短路径上，v 的前一个节点是谁

① 初始化：prev[s] = -1（源点没有前驱）
② 在松弛（relaxation）操作中，一旦发现 更短路径：
    if (dist[u] + weight(u, v) < dist[v]) {
        dist[v] = dist[u] + weight(u, v);
        prev[v] = u;   // 记录到 v的最短路径 是 通过u来的
    }

==
路径重建（回溯）：
要得到从 s 到 t 的路径：
    path = []
    curr = t
    while curr != -1:
        path.append(curr)
        curr = prev[curr]
    path.reverse()  # 得到 s → ... → t

🎯 这就是“用一个数组 记录路径”的本质：记录一棵 以s为根 的最短路径树（Shortest Path Tree）。

===
三、为什么必须用数组？能不能不用？

❌ 如果不记录 前驱，会发生什么？
① 你 只能知道 dist[t] = 5，但 不知道 是 s→a→b→t 还是 s→c→t。
② 对于 导航、网络路由、依赖分析 等应用，路径本身 比 距离 更重要。

❌ 为什么不直接存完整路径？
方法                   |	    空间复杂度	        | 是否可行
每个节点存完整路径（List） | O(V × L)，L 是平均路径长度	| ❌ 不现实（大图会爆内存）
只存前驱（prev[]）	  | O(V)                    | ✅ 高效简洁
例如：100 万个节点的图，prev[] 只需 4MB（int 数组），而存完整路径可能需要 GB 级内存。

===
四、在有向图中的特殊意义

有向图的边 具有方向性，路径 不是 对称的。这使得 路径记录 更加必要：
    ① 从 A 到 B 存在有 路径，不代表 从 B 也存在到 A 有路径；
    ② 最短路径 可能是唯一的、非直观的（如绕远路 但 权重小）；
    ③ 只有 通过 prev[] 回溯，才能 准确还原 这条有向路径。
💡 例如，在 任务调度DAG 中，prev[] 可以告诉你 “执行任务 C 之前，最后一个 必须完成的任务 是 B”。

===
五、实际应用场景
场景	                | 为什么需要 prev[]
GPS 导航	            | 用户 需要知道 “下一步左转还是右转”，不只是“还有 5 公里”
网络路由              | 路由器 需要知道 下一跳（next hop），而 prev[] 反向可得
依赖解析（如 Makefile）| 找出 导致 某个文件 需要重新编译 的依赖链
社交网络	            | “A 是 如何认识 Z 的？”——找出 最短推荐链
游戏 AI	            | 角色寻路：不仅要 走到目标，还要知道 每一步往哪走

===
六、常见变体
① edgeTo[v]：存储 指向 v 的那条边（而不仅是 前驱节点），适用于 需要边属性（如权重、ID）的场景；
② parent[v]：在 BFS 树 或 DFS 树中 记录父节点，用于 拓扑排序、环检测等；
③ 多源路径？→ 通常只记录 单源最短路径树；多源 需多次运行 或 用其他结构（如 APSP 的 next[][]）。

===
总结

使用一个数组（如 prev[]）记录路径，是为了 以 O(V) 的 极小空间开销，支持 O(L) 时间 重建 任意最短路径（L 为路径长度）。
它不是“麻烦”，而是工程与理论上的最优解：
✅ 空间高效
✅ 实现简单
✅ 通用性强（适用于 BFS、Dijkstra、Bellman-Ford 等）
✅ 完美适配有向图的方向性约束

🌟 记住：算法算出“有多远”，prev[] 告诉你“怎么走”。