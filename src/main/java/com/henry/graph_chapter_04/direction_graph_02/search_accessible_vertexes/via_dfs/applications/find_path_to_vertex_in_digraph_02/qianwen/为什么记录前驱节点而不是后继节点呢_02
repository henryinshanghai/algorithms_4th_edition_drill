那为什么这个数组记录的是 前驱节点，而不是 后继节点呢？记录后继节点 一样也能得到 完整的路径吧？

===
这是一个非常敏锐且深刻的问题！

“为什么记录前驱（predecessor）而不是后继（successor）？” —— 表面上看，两者似乎都能重建路径，
但实际上，在单源最短路径（或 BFS/DFS 树）的上下文中，记录前驱 是自然、高效且唯一可行的选择。
下面我们从多个角度解释原因。

===
一、核心原因：我们是从源点出发，向外扩展的

在 Dijkstra、BFS、Bellman-Ford 等单源路径算法中：

① 算法从一个源点 s 开始；
② 逐步 探索并确定 到其他节点的最短路径；
③ 每当一个节点 v 被“确认”（如 Dijkstra 中出队），我们就知道：
    “到达 v 的最短路径，是通过 某个 已确认的邻居 u 过来的。”

因此，自然的信息流是：u → v，所以 v的前驱 是 u。

✅ 前驱关系 天然反映了 算法的构建过程。

===
二、为什么“记录后继”不可行？

==
❌ 问题 1：一个节点可能有 多个后继，但 只有一个前驱（在最短路径树中）
① 在 最短路径树（SPT）中，每个节点（除源点）有且仅有一个父节点（前驱）。
② 但一个节点 可能有 多个子节点（后继）。

结构  |	前驱数组           |	后继结构
空间	 | prev[v] = u（O(V)）| succ[u] = [v1, v2, ...]（O(V + E)）
唯一性|	每个 v 只存一个值	 | 每个 u 要存一个列表

📌 如果 用后继 表示整棵树，你 需要存储 整个树的邻接表，空间更大，且冗余。

==
❌ 问题 2：你不知道 目标节点 是谁，无法 从源点“正向遍历”到它
假设你想找 s → t 的路径：
    ① 如果你 只有 后继列表（即 每个节点 知道它 能去哪），那你必须 从s开始 做一次搜索（DFS/BFS） 才能找到 t。
    ② 但如果你有 前驱数组，只需 从 t 直接回溯到 s，无需搜索！

    # 前驱方式：O(L) 直接回溯
    path = []
    curr = t
    while curr != -1:
        path.append(curr)
        curr = prev[curr]

    # 后继方式：需要从 s 开始搜索整棵树才能找到 t 的路径！
🔥 前驱 支持 O(1) 定位任意目标的 路径；后继 不支持！

==
❌ 问题 3：后继关系 在算法运行时 无法确定
① 当你 刚确定 dist[v] 时，你知道 v 是从 u 来的（所以设 prev[v] = u）。
② 但此时你 不知道 v 未来会 作为 哪些节点的前驱（即它的后继是谁）——那些节点 还没被处理！

💡 前驱是“已知的过去”，后继是“未知的未来”。
算法 只能记录 已经发生的关系，无法 预知未来。

===
三、类比：家谱 vs 子女列表

① 前驱数组 ≈ 每个人 记录 自己的父亲是谁。
    想知道“你是谁的后代？”→ 一路往上 查祖先，直到始祖。

② 后继结构 ≈ 每个人 记录 自己的所有子女。
    想知道“始祖怎么传到你？”→ 必须 从始祖 开始遍历 整棵家族树，直到找到你。
显然，查祖先 比 回溯家族树 高效得多！

===
五、总结：为什么一定是前驱？
原因	          | 说明
✅ 算法方向匹配  | 单源扩展 ⇒ 自然产生“前驱”关系
✅ 空间最优	  | O(V) vs 后继的 O(V + E)
✅ 查询高效	  | 任意目标 可 O(L) 回溯，无需搜索
✅ 信息可用性	  | 前驱 在节点 被确认时 已知，后继未知
✅ 结构唯一	  | 最短路径树中 每个节点 只有一个前驱

🌟 记录前驱，是因为路径是 从源点“生长”出来的，而我们 要的是 “回溯生长轨迹”。

所以，虽然理论上你可以用 后继+搜索 得到路径，但在 实际算法设计 中，前驱数组 是唯一高效、简洁、自然的选择。