对 Kosaraju算法的正确性证明

#1 在G中 进行 深度优先搜索（Kasaraju SCC）：
    假设 v 对于s是可达的，则：G中 必然含有 一条 从s到v的路径（s -> v）；
#2 在G^R中 进行 深度优先搜索（DepthFirstOrder）：
    深度优先搜索 必然 在离开s之前，就离开了v，否则 G中，dfs(v)的调用 就会发生在 dfs(s)之前。
    🐖 G^R中，必定含有 一条 v -> s的路径。
这个 证明过程，没有讲清楚 要证明的命题 是什么？证明过程的本身 是什么？

===
这个方法 容易实现，但 难以理解。
但是如果你能够 一步一步地理解 下面这个命题的证明，并参考 图4.2.15，那么 你一定能够 理解 这个算法的正确性。

命题H
如果（条件）：#1 使用 深度优先搜索 查找 指定的有向图G的 反向图G^R，然后
#2 根据 由此得到的 所有顶点的逆后序序列，再使用 深度优先搜索 来 处理 有向图G（Kasaraju算法），
则（结论）：其构造函数中的 某一次递归调用 所标记的 所有顶点，都会来自于 同一个强连通分量。

证明：
#1 首先 要使用 反证法 来 证明 “每个 与s强连通的顶点v 都会 在 构造函数所调用的dfs(G, s) 中 被访问到”。
    假设 存在有一个 与s强连通的顶点v，它不会 在构造函数所调用的dfs(G, s)中，被访问到。
    #1 由于 存在有 s -> v的路径（强连通性），所以v 肯定 在之前就已经 被标记过了;
    #2 但是 也存在 从v -> s的路径（强连通性），所以 在 dfs(G, v)的调用 中，s肯定会 被标记 -> 所以 递归调用时，应该就不再会 调用dfs(G, s)了。
    两者矛盾，说明 假设不成立。

#2 其次，要证明 “构造函数所调用的dfs(G, s) 所到达的任意顶点v，都必定与s是强连通的。”
    设v是 dfs(G, s)所能够到达的 某个顶点。则：G中，必然存在一条 s->v的路径 - 对应到 G‘ 中，就是 v->s的路径。
    所以 只需要证明 G中 还存在有一条 v->s的路径 即可。对应到 G'（G的逆向图）中，就是要证明 其中存在有 一条 s->v的路径。

#3 等价证明的核心 在于，如果 按照 逆后序的结点序列 来 进行 深度优先搜索（aka 遍历“有向图中结点”的顺序） 意味着/则：
    在G’中 所进行的深度优先搜索 中，dfs(G, v)[对结点v的处理完成]必然 在  dfs(G, s)[对结点s的处理完成]之前 就已经结束了。
        标记结点 - 这是dfs()调用开始 就会做的事情；
        处理完成结点 - 标记结点 & 标记所有 由当前结点指出的所有结点，这是 当前dfs()调用结束 才能完成的事情；
    这样的约束（dfs(v)的完成 先于 dfs(s)的完成）下，dfs(G, v)的调用 就只会出现 两种情况：
        #1 调用 发生在dfs(G, s)的调用 之前（并且 也在dfs(G, s)的调用之前 就完成了）；
        #2 调用 发生在dfs(G, s)的调用 之后（并且 也在dfs(G, s)的调用结束之前 就完成了）

        第一种情况 是 不可能出现的，因为 在G‘中，存在有 一条 v->s的路径(???) - 推论：对结点s的处理完成 一定先于 对结点v的处理完成；
        第二种情况（先 调用dfs(s), 再 调用dfs(v),然后 v完成，最后 s再完成）则说明：G’中，存在有一条 s->v的路径（#2中的需证得证）。

至此，证毕。