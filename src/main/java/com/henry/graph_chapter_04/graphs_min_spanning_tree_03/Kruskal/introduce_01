算法思想：按照 边的权重顺序（从小到大）来 处理它们 - 以此顺序 来 把边（图中的黑色边）加入到最小生成树MST中。
特征：
    #1 新加入的边 不会 与 已加入的边 构成环；
    #2 当MST中 含有V-1条边 时，算法 结束。
    #3 这些 黑色的边 会逐渐 由 一片森林 合并为 一棵树，aka 图的最小生成树。

以上算法过程 被叫做 Kruskal算法。

===
与 Prim算法 做比较

Prim算法的过程是：一条边一条边地 来 构造MST - 每一步都 为MST 添加一条边；
Kruskal算法的过程是：同样也是 一条边一条边地 构造MST，但 不同的是 - 它 寻找到的边 会 连接一片森林中的两棵树。

我们从一片 由 V棵 单顶点的树 所构成的森林 开始，然后不断 使用“可以找到的最短边” 来 把 两棵树 合并，
直到 只剩下一棵树 - 这就是 MST。

针对于具体图的步骤：针对tinyEWG图
#1 权重最小的边 都被加入到了 最小生成树中；
#2 随后算法 判断出 1-3、1-5和2-7 已经失效，并 把 4-5 添加到 MST中；
#3 最后1-2、4-7和0-4 失效，6-2 被添加到了 MST中。

有了本书中，我们已经学习过的很多工具，实现 Kruskal算法 不算太难：
#1 使用 优先队列 来 把边 按照权重大小排序；
#2 使用一个 UnionFind数据结构 来 识别“会形成环的边”；
#3 使用 队列 来 保存MST中的所有边。

🐖 使用队列来保存边 意味着 用例在遍历时，会按照 权重的升序 来 得到 MST中的所有边。