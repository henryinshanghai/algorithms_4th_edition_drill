Prim即时实现中，图节点到MST的最小边要怎么理解？
是 把MST看作一个整体，某个图节点 存在有 多条横切边 能连接到MST，通过 比较 得到 其中权重最小的边 吗?

===
是的，你的理解完全正确！👏

在 Prim 算法的即时实现（Eager Implementation） 中：
“图中 某个非树顶点 到 MST 的最小边”

就是指：
该顶点 与 当前MST 之间 所有横切边 中 权重最小的那一条。

===
🌟 详细解释如下：

1. 什么是“横切边”（crossing edge）？
① 横切边 = 一端在 MST 内部，另一端在 MST 外部（即非树顶点） 的边。
② 对于 任意一个 尚未加入MST的顶点w，它 可能 通过 多条边 连接到 MST中的不同顶点（比如 v1, v2,…），这些边 都是 横切边。

2. 为什么只关心 “最小”的那条？
① Prim 算法的核心贪心策略是：每次选择 权重最小的横切边 来 扩展 MST。
② 对于 顶点 w 来说，只有 当前最短的那条横切边 有可能 在未来 被选中。
③ 其他 更长的边 永远不会 再被考虑（因为一旦 w 被加入 MST，就 不再需要 连接它的边；而在此之前，我们 只关心 最短的）。
✅ 所以：保留最小边 = 保留 未来可能用到的 最优候选边。

==
🧩 举个例子
假设 当前 MST 包含顶点 {A, B}，非树顶点 有 C 和 D，边如下：

A --2-- C
B --3-- C
A --5-- D
B --1-- D

那么：
① 对于顶点 C：
    1.横切边有：A-C (2)、B-C (3)
    2.最小边是 A-C (2)
② 对于顶点 D：
    1.横切边有：A-D (5)、B-D (1)
    2.最小边是 B-D (1)
👉 在 即时实现 中，优先队列里 只会存 这两条边：
    (C, 2)
    (D, 1)
而不是 把 全部 4条边 都塞进去（那是 延迟实现 的做法）。

===
🔧 即时实现 如何维护 这个“最小边”？
使用 索引优先队列（IndexedMinPQ），为 每个非树顶点 w 维护：
    ① distTo[w]：当前已知的 w 到 MST 的最短距离（即最小边权重）
    ② edgeTo[w]：对应的那条最小边

当新顶点 v 被加入 MST 后：
    ① 遍历 v 的所有邻接边 v-w
    ② 如果 w 不在 MST 中，且 weight(v-w) < distTo[w]，则：
        1.更新 distTo[w] = weight(v-w)
        2.更新 edgeTo[w] = v-w
        3.调用 pq.decreaseKey(w, newWeight) 更新优先队列
✅ 这样，每个非树顶点 在队列中 始终 只对应 一条边———当前最优的横切边。

===
✅ 总结你的理解：
你的说法	                    | 是否正确	|   说明
“把 MST 看作一个整体”	        | ✅	    | 是的，MST 是一个连通子图，我们关心 外部顶点 如何 以最小代价接入
“某个图节点有多条横切边连接到 MST”| ✅	    | 正确，只要它和 MST 中多个顶点相邻
“比较得到其中权重最小的边”	    | ✅	    | 这正是 即时实现 的核心优化：只保留 最小者

💡 关键思想：
即时实现 = 动态维护 每个 非树顶点 到MST的“最佳接入点”，

从而避免 像延迟实现那样 在队列中 堆积大量 无效或次优的边。