为什么Prim的即时实现中，维护 一个节点->它到MST的最小边的权重 的数组的同时，还需要维护一个 同样作用的 索引优先队列呢？这不是重复了吗?

===
但其实，这两个数据结构的 作用完全不同，缺一不可。
下面我来彻底解释清楚：

✅ 核心结论先说：
    ① distTo[] 数组 用于 存储和快速查询 每个顶点的当前最小距离；
    ② 索引优先队列 用于 高效找出 所有非树顶点中 距离最小的那个。

它们是互补关系，不是重复！

===
一、各自的角色是什么？
数据结构	      | 作用	                                                | 时间复杂度
distTo[v] 数组 | 存储 顶点 v 到当前 MST 的最短距离（即最小横切边权重）
                → 支持 O(1) 查询/更新	                                | O(1)
索引优先队列 pq | 动态维护 所有 尚未加入MST的顶点，并能 快速取出 distTo 最小的那个
                → 支持 O(log V) 取最小 + O(log V) 更新	                | O(log V)

===
二、为什么不能只用 distTo[] 数组？
假设你只有 distTo[] 数组，没有优先队列：
① 你知道 每个顶点 的 当前最小距离。
② 但当 你需要找 “哪个非树顶点 离 MST 最近”时，你必须：

    int minVertex = -1;
    double minDist = INF;
    for (int v = 0; v < V; v++) {
        if (!inMST[v] && distTo[v] < minDist) {
            minDist = distTo[v];
            minVertex = v;
        }
    }

① 这个操作是 O(V) 的！
② 而 Prim 算法 要执行 V 次这样的操作（每次加一个顶点），
③ 总时间复杂度 变成 O(V²) —— 这其实是朴素 Prim 的实现，适合 稠密图，但 对 稀疏图 效率低。
🔍 所以：没有优先队列，你就无法 高效找到最小值。

===
三、为什么不能只用索引优先队列，不要 distTo[]？
索引优先队列虽然能：
    ① pq.delMin() → 返回最小顶点
    ② pq.keyOf(v) → 查询某个顶点的 key
但它本身 不提供 O(1) 的随机访问语义（虽然 keyOf(v) 是 O(1)，但 通常实现中 仍依赖内部 keys[] 数组）。

更重要的是：
🚫 问题1：算法逻辑 需要频繁读取 distTo[w]

在松弛（relax）过程中：
    for each neighbor w of v:
        if (!inMST[w] && weight(v, w) < distTo[w]) {
            distTo[w] = weight(v, w);
            edgeTo[w] = v-w;
            pq.decreaseKey(w, distTo[w]);
        }
这里必须 快速比较 weight(v,w) 和当前 distTo[w]。

如果 每次都要 调用 pq.keyOf(w)，虽然可行，但：
    ① 代码可读性差
    ② 隐藏了“距离”这一核心状态
    ③ 多数教材和实现 都 显式维护 distTo[] 以 清晰表达 算法意图

🚫 问题2：distTo[] 还有独立用途
① 最终结果：distTo[v] 就是顶点 v 在 MST 中的“接入成本”
② 可用于 后续计算（如总权重 = sum of distTo[v] for v ≠ start）
③ 调试时 可直接打印 整个数组

💡 实际上，索引优先队列的内部实现本身 就包含一个 keys[] 数组（等价于 distTo[]）！

所以你不是“重复存储”，而是把 队列内部的状态 暴露出来，便于 算法使用。

===
五、类比理解
想象你 要管理 一群学生的成绩，并 随时找出 最低分的学生：

方式	              |   说明
只有成绩单（数组）	  | 你知道每个人分数，但 找最低分 要遍历全部 → O(n)
只有排行榜（优先队列）|	你能 快速拿到 最低分是谁，但想 查某人的分数 还得翻榜
两者都有	          | ✅ 成绩单 快速查分 + 排行榜 快速找最低 → 最佳组合
Prim 的 distTo[] + IndexedMinPQ 就是这个道理！

===
✅ 总结：不是重复，而是分工协作
组件          |	职责                                        |	不可替代性
distTo[] 数组 |	存储和提供 O(1) 访问每个顶点到 MST 的当前最短距离  | 必须存在，否则无法 高效比较和更新
索引优先队列	 | 高效维护非树顶点集合，并支持 O(log V) 取最小 + 更新 | 必须存在，否则 找最小值 需 O(V)
🌟 它们共同实现了“动态维护 + 快速查询 + 高效选取”三位一体的贪心策略，

这正是 Eager Prim 能达到 O(E log V) 时间复杂度的关键！
所以，放心地同时使用它们吧——这不是冗余，而是精妙的设计！