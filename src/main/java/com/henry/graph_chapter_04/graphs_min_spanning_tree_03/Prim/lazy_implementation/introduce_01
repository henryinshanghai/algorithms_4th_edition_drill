We use a priority queue to hold the crossing edges and find one of minimal weight.
我们使用一个 优先队列 来 存储 所有的横切边 并且 找到其中权重最小的边。

Each time that we add an edge to the tree, we also add a vertex to the tree.
每次我们向MST中添加一条边，我们也就向树中添加了一个节点。

To maintain the set of crossing edges, we need to
add to the priority queue all edges from that vertex to any non-tree vertex.
为了维护 横切边的集合，我们需要 向优先队列中添加 所有由该节点指向其他任何非树节点的边。

But we must do more:
any edge
connecting the vertex just added
to a tree vertex that is already on the priority queue
now becomes ineligible (it is no longer a crossing edge because it connects two tree vertices).
但我们必须要做更多：
任何 连接着 刚刚添加的节点 与 已经在优先队列中的一个树节点，
现在都变得不适当了（它已经不再是一个横切边了 因为它连接了两个树节点）

The lazy implementation leaves such edges on the priority queue,
deferring(延迟) the ineligibility test（无效性测试） to when we remove them.
这个懒实现 把这样的边 留在了优先队列了，把这种无效性测试 给延迟到 当我们需要移除他们时。