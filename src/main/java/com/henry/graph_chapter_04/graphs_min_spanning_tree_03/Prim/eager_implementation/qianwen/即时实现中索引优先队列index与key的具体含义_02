Prim即时实现中，索引优先队列的index与Key 具体分别是什么呢?

===
✅ 简明回答：
成分	    | 含义                       |	具体是什么
index	| 非树顶点的标识符	            | 图中顶点的编号（如 0, 1, 2, ..., V-1）
key	    | 该顶点 到 当前 MST 的最短距离 | 即连接 该顶点 与 MST 的最小横切边的权重

🧠 详细解释
1. index = 顶点编号（Vertex ID）
① 每个 图中的顶点 都有一个 唯一整数 ID（通常从 0 到 V-1）。
② 在 Prim 算法中，我们关心的是：每个 尚未加入MST的顶点，如何 以 最小代价 连接到 MST。
③ 所以，索引优先队列中的“索引” 就是 这些顶点的 ID。
例如：顶点 5 → index = 5

2. key = 当前已知的最小横切边权重
① 对于顶点 v，key[v] 表示：从 v 到当前 MST 的所有横切边中，权重最小的那个值。
② 初始时，除 起点 外，所有顶点的 key = +∞（表示尚未连接）。
③ 随着 MST 扩展，每当有 新顶点u 加入 MST，我们就 检查 u的邻居 w：
    如果 边 u-w 的权重 < key[w]，就 更新 key[w] = weight(u-w)
例如：key[5] = 3.2 表示：顶点 5 到 当前 MST 的最短边 权重 是 3.2

===
📊 索引优先队列在 Prim 中的核心作用
操作	                     | 含义
pq.insert(v, key)	     | 开始跟踪 顶点 v，其 初始最短距离 为 key
pq.contains(v)	         | 判断 顶点v 是否还未加入 MST（即是否仍在队列中）
pq.keyOf(v)	             | 获取 顶点v 当前到 MST 的最短距离
pq.decreaseKey(v, newKey)| 发现 更短的边 后，更新 顶点v的最短距离
pq.delMin()	             | 返回 key最小的顶点（即 下一个要加入MST 的顶点）
💡 注意：delMin() 返回的是 index（顶点编号），不是 key！

===
❓ 常见疑问解答
Q1: 为什么不用普通优先队列？
① 普通PQ 无法 通过顶点 ID 更新已有项，只能 不断插入新副本（导致重复和无效边）。
② 索引PQ 允许 O(log V) 时间内 更新 特定顶点的优先级。

Q2: key 是不是就是 distTo[v]？
是的！ 在 Prim 中，key[v] 就等同于 distTo[v]（到 MST 的最短距离）。

Q3: 起点的 key 为什么是 0？
因为起点已在 MST 中，它到 MST 的距离为 0。这是算法启动的关键。

===
✅ 总结
概念	    | 在 Eager Prim 中的具体含义
index	| 图中顶点的编号（0 ~ V-1）
key	    | 该顶点 到 当前 MST 的 最小横切边 权重（即最短接入距离）
队列作用	| 动态维护 所有非树顶点的“最佳接入代价”，并 高效选出 最小者

🌟 记住：
索引优先队列 = 一个能按 “顶点到 MST 的距离” 排序，并 支持 动态更新的 智能容器。