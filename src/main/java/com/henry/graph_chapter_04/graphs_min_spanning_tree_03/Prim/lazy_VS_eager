Prim算法的延迟实现：
#1 把 起始节点 先添加为MST节点；
#2 把 当前所有MST节点的 所有横切边(一个端点是MST节点，另一个端点是图节点) 添加到 横切边PQ中；
#3 开启一个while循环，动态处理 横切边PQ中的边，直到 PQ为空：
    ① 获取 PQ中的最小横切边；
    ② 验证 该最小横切边 的有效性；
    ③ 把 该有效的最小横切边 添加到 MST边的集合中；
    ④ 对 该有效的最小横切边 中的图节点 执行#1+#2.

特征：
#1 它对 所有节点 进行了 MST节点的标记；
#2 它把 所有MST的边 收集到了一个 集合中；
#3 它会把 所有MST节点的横切边 一股脑都添加到PQ中，然后 借助
    ① PQ的delMin() 与
    ② 横切边有效性检查 来 添加MST边；
#4 这种做法会导致 PQ中 有 无效边。
    原因：添加横切边 与 取出横切边 的动作存在有时间差，添加时是有效的，但取出时可能就是无效的了（因为其图节点可能已经被添加为MST节点了）
#5 它表示MST的方式 是 把 所有 对的MST边 添加到 一个队列中；

===
Prim算法的即时实现：
#1 先向 indexMinPQ(vertex -> weight)中添加 (0, 0) 来 表示 把节点0添加到MST中；
#2 开启一个while循环 来 动态处理 indexMinPQ中的有效横切边，直到 indexMinPQ为空；
    ① 先 获取到 indexMinPQ中的 权重值最小的图节点；
    ② 把 该图节点 添加为 MST节点；
    ③ 对于 该MST节点的 所有邻居图节点，尝试 在 数组 与 indexMinPQ 中，更新 该邻居图节点的 到MST的最小边(及权重值)；

特征：
#1 它的起点 是 indexMinPQ的一个元素；
#2 它只 对 节点 进行了 MST节点的标记，而没有 显式地 收集 MST边；
#3 它的操作 针对的是 图节点 到MST的最小权重边，在 每次 添加 新的MST节点 时，它会 添加/新增 邻居节点 到 MST的最小权重边；
    所以 indexPQ中 不会有 无效边
#4 它表示MST的方式 是 为 每个节点 维护 其连接到MST的横切边（一个数组）；
