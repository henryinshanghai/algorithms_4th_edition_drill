Prim算法的延迟实现：
#1 把 起始节点 先添加为MST节点；
#2 把 MST节点的所有相邻图节点 添加到 横切边PQ中；
#3 开启一个while循环，动态处理 横切边PQ中的边，直到 PQ为空：
    ① 获取 PQ中的最小横切边；
    ② 验证 该最小横切边的有效性；
    ③ 把 该有效的最小横切边 添加到 MST边的集合中；
    ④ 对 该有效的最小横切边 中的图节点 执行#1+#2.

特征：
#1 它对 所有节点 进行了 MST节点的标记；
#2 它把 所有MST的边 收集到了一个 集合中；
#3 它会把 所有MST节点的横切边 一股脑都添加到PQ中，然后 借助PQ的delMin() 与 横切边有效性检查 来 添加MST边；所以 PQ中会有 无效边
#4 它表示MST的方式 是把所有对的MST边 添加到一个队列中；

===
Prim算法的即时实现：
#1 先向 indexMinPQ(vertex -> weight)中添加 (0, 0) 来 表示 把节点0添加到MST中；
#2 开启一个while循环 来 动态处理 indexMinPQ中的有效横切边，直到 indexMinPQ为空；
    ① 先 获取到 indexMinPQ中的 权重值最小的图节点；
    ② 把 该图节点 添加为 MST节点；
    ③ 对于 该MST节点的 所有邻居图节点，尝试在数组与indexMinPQ中，更新 该邻居图节点的 到MST的最小边(及权重值)；

特征：
#1 它的起点是indexMinPQ的一个元素；
#2 它只对 节点进行了MST节点的标记，而没有 显式地 收集MST边；
#3 它的操作 针对的是 图节点 到MST的最小权重边，在每次添加新的MST节点时，它会添加/新增 邻居节点到MST的最小权重边；所以 indexPQ中 不会有 无效边
#4 它表示MST的方式 是为每个节点维护其连接到MST的横切边（一个数组）；
