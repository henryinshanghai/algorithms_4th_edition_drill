什么时候应该使用 记录前驱节点的数组prev[]? 什么时候又应该使用 记录 前驱边的数组edgeTo[]呢？

===
这是一个非常实用 且 体现工程权衡的问题！

prev[]（记录前驱节点）和 edgeTo[]（记录前驱边） 都用于 在图算法中重建路径，
但它们的 适用场景、信息粒度 和 实现复杂度 有所不同。
下面我们 从多个维度对比，并给出 明确的使用建议。

===
一、核心区别
特性	    | prev[v]            |	edgeTo[v]
存储内容	| 前驱顶点（如 int u）	 | 前驱边（如 Edge e 或 (u, v, weight)）
空间开销	| 小（通常 O(V) 个整数）| 稍大（ O(V)条 边对象，每条含 起点、终点、权重等）
信息粒度	| 仅知“从谁来”	     | 知道 “通过哪条边来”，包括 权重、ID、方向等 属性
重建路径	| 只能得到 顶点序列	 | 能得到 完整的边序列 及 其属性

===
二、何时用 prev[]？✅
当你 只关心 路径上的顶点顺序，不关心 具体的边信息 时。

典型场景：
① 无权图的最短路径（BFS）
    1.所有边权重为 1，只需知道 跳了几步、经过哪些点。
    2.例如：社交网络中“六度人脉”路径 → 只需 人名列表。

② 拓扑排序、DFS 树构建
    1.只需知道 父子关系，无需 边属性。

③ 内存受限环境
    1.嵌入式系统、大规模图（十亿级节点）中，节省空间 至关重要。

④ 边无额外属性
    1.图 只是 邻接关系（如网页链接图），边 没有 权重、标签、ID 等。

示例（BFS 路径重建）：
    // prev[v] = u 表示的是 v的前驱 是 u
    List<Integer> path = new ArrayList<>();
    for (int x = target; x != source; x = prev[x])
        path.add(x);
    path.add(source);
    Collections.reverse(path); // 得到 source → ... → target

===
三、何时用 edgeTo[]？✅
当你需要知道 路径上 每条边的具体信息（如权重、ID、类型等）时。

典型场景：
① 带权图的最短路径（Dijkstra、Bellman-Ford）
    1.不仅要知道 走哪几个点，还要知道：
        Ⅰ 每段路的距离/时间/费用；
        Ⅱ 总成本是多少（虽然 dist[] 也有，但边级明细更可靠）；
        Ⅲ 是否经过收费路段、高速等（边有属性）。

② 需要输出 完整路径描述
    1.导航系统：“从 A 出发，沿 G4 京港澳高速（80km） 到 B，再走 省道 S101（20km） 到 C”。
    2.这里的“G4”、“S101”、“80km”都 来自 边对象。

③ 边具有 唯一标识 或 元数据
    1.网络路由：每条链路 有 带宽、延迟、运营商；
    2.电路设计：每条连线 有 电阻、电容；
    3.游戏地图：每条移动边 有 地形消耗、是否可通行。

④ 多图或动态图
    1.同一对顶点间 可能有 多条边（平行边），仅靠 prev[v] = u 无法区分 走的是哪一条。

示例（Dijkstra 路径重建）：
    // edgeTo[v] = Edge(u, v, weight)
    Stack<Edge> path = new Stack<>();
    for (Edge e = edgeTo[target]; e != null; e = edgeTo[e.from])
        path.push(e);

    while (!path.isEmpty())
        System.out.println(path.pop()); // 输出每条边的详细信息

===
四、关键决策树：选哪个？

你需要 路径上的边属性 吗？（权重、ID、标签等）
│
├─ 是 → 用 edgeTo[]
│
└─ 否 →
     │
     ├─ 图是 无权的？ → 用 prev[]
     │
     └─ 图有权 但你 只关心 顶点序列？ → 仍可用 prev[]（但需确保无平行边）
⚠️ 特别注意：如果图中 存在 平行边（两个顶点间有多条边），必须用 edgeTo[]，否则 无法确定 具体走了哪条边。

===
五、实际代码风格参考（以经典教材为例）
算法	                            |     实现者         |	使用方式
《算法》（Algorithms, Sedgewick）	| Robert Sedgewick	| 统一使用 edgeTo[]
                                                    （即使 BFS 也存边，保持 API 一致）
CLRS（《算法导论》）	            | Cormen et al.	    | 主要用 prev[]（记为 π[v]）
                                                    （侧重理论，假设 边权 可通过 邻接表 查）
LEETCODE / 编程竞赛	            | 通用	            | 无权图 用 prev[]，带权图 用 edgeTo[] 或 只存 prev[] + 邻接表查权

💡 Sedgewick 的做法更工程化：用 edgeTo[] 一统江湖，避免混淆。

===
六、总结：一句话指南
场景	                            | 推荐
只需要 顶点序列（如人名、城市名列表）	| ✅ prev[]（简洁高效）
需要 边的详细信息（权重、ID、描述）	| ✅ edgeTo[]（信息完整）
存在平行边	                    | ✅ 必须用 edgeTo[]
追求代码统一性（教学/库设计）	        | ✅ 优先用 edgeTo[]

🌟 记住：
① prev[] 回答 “经过哪些点？”
② edgeTo[] 回答 “走了哪些路？每段路什么样？”

根据 你的应用 需求选择，就能在效率与功能之间取得最佳平衡！