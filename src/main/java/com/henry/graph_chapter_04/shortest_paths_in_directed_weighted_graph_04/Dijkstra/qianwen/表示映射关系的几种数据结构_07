数组作为数据结构也记录了 index->item的映射关系，相比于 其他记录映射关系的数据结构(比如 Map，indexPQ) 它们各自有什么优缺点呢?

是一个非常本质且实用的问题！

数组、Map（哈希表）、索引优先队列（Indexed Priority Queue） 都可以看作“从键到值的映射”，
但它们在 键的类型、操作支持、时间/空间效率 和 适用场景 上有根本区别。

下面我们系统对比 这三种结构，聚焦于 它们作为 “映射容器” 的角色：

一、核心对比表
特性	     | 数组（Array）	    | Map（如 HashMap）                        |	索引优先队列（IndexedMinPQ）
键的类型	 | 非负整数（0 ~ N-1） | 任意可哈希对象（String, Integer, 自定义等） | 固定范围整数（0 ~ N-1）
底层结构	 | 连续内存块	        | 哈希表（数组 + 链表/红黑树）	              | 二叉堆（通常用数组实现）+ 反向索引数组
插入	     | O(1)（直接赋值）	| 平均 O(1)，最坏 O(n)	                  | O(log N)（insert(i, key)）
查找（get）|	O(1)（arr[i]）	| 平均 O(1)	                              | 不支持任意 get！
                                                                        只能通过外部 keys[] 数组查
更新	     | O(1)（arr[i] = x）| 平均 O(1)	                              | O(log N)（decreaseKey(i, newKey)）
删除	     | O(1)（但可能需移动）| 平均 O(1)	                              | O(log N)（delMin() 或 delete(i)）
额外能力	 | —	        	| 支持遍历键/值                             | ✅ 高效获取 最小键值对（delMin() / min()）
空间开销	 | 极小（仅存值）	    | 较大（桶数组 + 指针 + 负载因子冗余）	      | 中等（堆数组 + qp[] 反向索引）
缓存友好性 |	⭐⭐⭐⭐⭐（连续内存）| ⭐⭐（指针跳转）	                          | ⭐⭐⭐（堆是数组，但访问不连续）

===
二、详细分析

==
✅ 1. 数组（Array）
优点：
    ① 极致的 O(1) 随机访问：CPU 缓存友好，速度最快；
    ② 内存紧凑：无额外指针或哈希开销；
    ③ 简单可靠：无哈希冲突、无扩容抖动。
缺点：
    ① 键 必须是 连续/稠密的小整数（如 0~10⁶）；
    ② 稀疏键 浪费空间：若键是 {1, 1000000}，需分配 1000001 个槽，99.9% 空；
    ③ 不支持 动态键集：大小 通常固定。
适用场景：
    ① 图算法中 顶点ID 为 0~V-1（如 distTo[v]）；
    ② 计数排序、DP 表、棋盘游戏状态等 键空间 已知且密集 的场景。

==
✅ 2. Map（HashMap / TreeMap）
优点：
    ① 键类型灵活：String、自定义对象、大整数等；
    ② 动态伸缩：自动处理 稀疏键；
    ③ 标准接口：put(k,v), get(k), containsKey(k) 等。
缺点：
    ① 哈希开销：计算哈希、处理冲突；
    ② 内存膨胀：负载因子通常 0.75，实际内存 > 数据量；
    ③ 最坏情况退化：O(n) 查找（哈希攻击或大量冲突）；
    ④ 无序（HashMap）或 O(log n) 访问（TreeMap）。
适用场景：
    ① 顶点 是 字符串（如城市名 "Beijing"）；
    ② 键空间 未知 或 稀疏（如用户 ID 为 UUID）；
    ③ 需要 频繁增删 任意键值对。
💡 Map 是“通用映射”的首选，但不是“高性能 密集整数映射”的首选。

==
✅ 3. 索引优先队列（Indexed PQ）
📌 注意：它不是通用 Map！它的核心能力是 “带索引的优先队列”。

核心设计：
    ① 假设键 是 0 ~ N-1 的整数（即“索引”）；
    ② 内部维护：
        1.pq[]：堆，用于存储 索引；
        2.keys[]：keys[i] 是 索引i 所对应的优先级（值）；
        3.qp[]：qp[i] 是 索引i 在堆中的位置（用于 O(1) 定位）。
优点：
    ① 支持 decreaseKey(i, newKey)：这是普通 PQ 做不到的！
    ② 高效获取 最小元素：delMin() → O(log N)；
    ③ 适合 Dijkstra、Prim 等 需要 动态更新优先级 的算法。
缺点：
    ① 仅支持 整数索引（0~N-1）；
    ② 不支持 任意查询：想查 keys[i]？需 额外维护 keys[] 数组；
    ③ 实现复杂：需维护 pq[] 和 qp[] 的双向映射。
适用场景：
    ① Dijkstra 算法：动态更新 顶点距离 并 取最小；
    ② Prim 最小生成树：动态更新 边权重；
    ③ 事件驱动模拟：按 时间戳 调度，且 事件优先级 可变。
🔑 Indexed PQ = 数组（存值） + 堆（维护顺序） + 反向索引（支持快速定位）

===
三、如何选择？—— 决策指南

你的键是 0 ~ N-1 的连续整数吗？
│
├─ 是 →
│    ├─ 只需 get/set/update？ → ✅ 用 **数组**
│    └─ 还需要 高效取最小/最大，并 支持 decreaseKey？ → ✅ 用 **Indexed PQ**
│
└─ 否（键是字符串、大整数、对象等）→ ✅ 用 **Map**

🌰 例子：
场景	                        |   推荐结构	          | 理由
图有 10⁵ 个顶点，ID=0~99999	| double[] distTo	  | 密集整数，O(1) 访问
城市名到距离（"Paris" → 1200）	| Map<String, Double> |	键是字符串
Dijkstra中 动态选 最小距离顶点	| IndexedMinPQ<Double>|	需 delMin() + decreaseKey()
统计单词频率	                | Map<String, Integer>|	键未知、稀疏

===
四、常见误区澄清
误区	                    | 正确理解
“Indexed PQ 是一种 Map”	| ❌ 它是 优先队列的增强版，虽能 存 键值对，但主要用途是 调度，不是 查询
“数组不能做映射”	        | ❌ 数组是 最高效的 整数键 → 值 映射
“HashMap 总是比数组好”	| ❌ 对 密集整数键，数组更快、更省空间


五、总结
结构	        | 本质	            | 核心优势	                | 典型用途
数组	        | 密集整数键的直接映射	| 速度最快、内存最省	        | 图算法、DP、计数
Map	        | 通用键值存储	    | 灵活、动态	                | 字典、缓存、稀疏数据
Indexed PQ	| 可更新的优先队列	    | 支持 decreaseKey + delMin	| Dijkstra、Prim、任务调度

🌟 选择数据结构的本质，是匹配“操作模式”与“数据特征”。

数组、Map、Indexed PQ 各司其职，没有“最好”，只有“最合适”。