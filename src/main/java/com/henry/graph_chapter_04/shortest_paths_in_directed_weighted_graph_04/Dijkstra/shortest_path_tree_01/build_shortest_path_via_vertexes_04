== 换个角度看问题 ==
根据 算法的证明，我们可以 从另一个角度 来 理解它。
我们 可以确信地说，对于 所有树结点，它们所对应的vertexToItsPathWeight[]值，都是 最短路径的长度/成本。

对于 优先队列中的 任意顶点x，vertexToItsPathWeight[x] 表示 从s->x的最短路径的长度，
这条路径的“中间节点”在树中，并且 路径结束于 “横切边 vertexToItsTowardsEdge[x]”。

“优先级最小”的顶点的 vertexToItsPathWeight[]值，就是 “最短路径”的权重：
它 不会小于 已经被放松过的 任意顶点的 最短路径的权重，
也 不会大于 还未被放松过的 任意顶点的 最短路径的权重。
所以 这个顶点 就是下一个 “要被放松的顶点”。

所有 由s可达的顶点 都会按照 最短路径的权重顺序 被放松。

算法构造 最短路径树的过程 描述 👇
略

算法按照 当前顶点到起始顶点的 最短路径的长度/权重的正序 来 把他们添加到 最短路径树中。