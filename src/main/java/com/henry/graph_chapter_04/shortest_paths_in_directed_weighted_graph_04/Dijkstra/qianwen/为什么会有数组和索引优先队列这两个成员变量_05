为什么同样都是记录 vertex -> its lightest path weight的映射关系？
Dijkstra的类中 需要一个 数组成员变量，还需要一个 索引优先队列的成员变量呢?

===
这是一个非常深刻的问题，触及了 Dijkstra 算法高效实现的核心机制。

表面上看，distTo[] 数组 已经记录了 每个顶点到源点的当前最短距离，那 为什么还需要一个 索引最小优先队列（Indexed Min Priority Queue） 呢？

答案是：
✅ distTo[] 负责 “存储” 最短距离，而 优先队列 负责“高效选择 下一个要放松（relax）的顶点”。两者分工不同，缺一不可。

下面我们从 目的、角色、协作机制和必要性 四个角度详细解释。

===
一、两个数据结构的职责分工
数据结构	        |   作用                                                    |	类比
distTo[v] 数组	| 存储：记录从 源点s 到 每个顶点v 的 当前已知最短距离（上界）	       | 像一本“距离笔记本”，随时可查 任意点的距离
索引优先队列 pq	| 调度：高效地选出 distTo[]中 最小且未处理的顶点，用于 下一步松弛操作 | 像一个“待办事项清单”，总是 优先处理 “代价最小”的任务
🔑 关键：算法 需要 反复做一件事——“找出 当前‘未确定最短路径’的顶点 中，distTo最小的 那个”。

如果没有 优先队列，每次都要 扫描整个distTo[] 数组（O(V)），总复杂度 变成 O(V²)；
有了优先队列，这个操作只需 O(log V)。

===
二、为什么不能只用 distTo[]？
假设我们 不用 优先队列，而是每次 线性扫描 找最小值：

    while there are unvisited vertices:
        u = vertex with min distTo[u] among unvisited  # O(V) 扫描！
        mark u as visited
        for each neighbor v of u:
            relax(u, v)

① 时间复杂度：O(V² + E)
    1.对于稠密图（E ≈ V²），这是 可以接受的（如 Floyd 是 O(V³)）；
    2.但对于 稀疏图（E ≈ V），O(V²) 就太慢了！

而使用索引最小优先队列后：
① 插入/更新：O(log V)
② 取最小：O(log V)
③ 总复杂度：O((V + E) log V) → 对稀疏图更优！

💡 优先队列 是为了 加速“选最小”这个操作，避免 每次都全扫描。

===
三、为什么不能 只用 优先队列？
优先队列 虽然能 快速给出 最小元素，但它 无法直接回答 “某个 顶点v的 当前最短距离 是多少”。

① 例如，在 松弛边 (u, v) 时，你需要比较：
    if (distTo[u] + weight(u, v) < distTo[v]) { ... }
    这里必须 快速读取 distTo[v] 的当前值。
② 优先队列 不支持 O(1) 查询 任意键的值（除非 额外维护）。

此外，当 distTo[v] 被更新时，我们需要：
① 更新 优先队列中 v的优先级（即 decreaseKey(v, newDist)）；
② 这要求 优先队列 是 索引型（Indexed PQ），能通过 顶点编号 直接定位 其在堆中的位置。
📌 所以：distTo[] 提供 O(1) 查询，pq 提供 O(log V) 调度，二者互补。

===
四、它们如何协同工作？（以 eager Dijkstra 为例）
// 初始化
distTo[s] = 0;
pq.insert(s, 0);

while (!pq.isEmpty()) {
    int u = pq.delMin();          // 从pq中 取出 当前最小距离的顶点

    for (Edge e : adj[u]) {
        int v = e.to();
        double newDist = distTo[u] + e.weight();

        if (newDist < distTo[v]) {
            distTo[v] = newDist;                 // 更新距离（O(1)）
            edgeTo[v] = e;                       // 记录路径

            if (pq.contains(v))
                pq.decreaseKey(v, newDist);      // 更新 pq 中 v 的优先级
            else
                pq.insert(v, newDist);
        }
    }
}
① distTo[] 始终保存 最新距离；
② pq 始终包含 所有“尚未确定最短路径”的顶点，并 按 distTo 排序；
③ 当 distTo[v] 变小时，同步更新 pq，确保下次 delMin() 能正确选出 全局最小。

===
五、类比理解：餐厅点餐系统 🍽️
① distTo[] = 厨房的订单台账：记录 每桌客人 点了什么、花了多少钱（随时可查）；
② pq = 上菜优先级队列：服务员 根据“哪桌最先下单”或“哪桌最饿（距离最小）”决定先上哪桌的菜；
③ 如果只有 台账，服务员 得 挨桌问“谁最先点的？”——效率低；
④ 如果只有 队列，厨房 不知道 某桌具体点了啥——信息不全。
✅ 两者配合，才能又快又准地服务所有客人！

===
六、特殊情况：何时可以 不用 优先队列？
① 图是 稠密的（如完全图），且 V 不大 → 用 O(V²) 版本更简单（无需实现 Indexed PQ）；
② 边权 为 小整数 → 可用 Dial 算法（桶排序优化）；
③ 教学演示 → 为了简化，常先讲 无优先队列版本。
但 在 通用、高效的实现 中（如 Sedgewick 的《算法》），distTo[] + IndexedMinPQ 是标准组合。

===
总结
问题                |  	答案
为什么需要 distTo[]？ | 快速查询/更新 任意顶点的当前最短距离（O(1)）
为什么需要优先队列？   | 高效选出 下一个要处理的顶点（O(log V) 而非 O(V)）
能否只用一个？	       | ❌ 不能：一个管“存储”，一个管“调度”，功能互补
核心思想	           | 分离关注点：状态存储 vs 决策调度

🌟 Dijkstra 的优雅之处，就在于 用两个简单结构的 协作，实现了 贪心策略的高效执行。